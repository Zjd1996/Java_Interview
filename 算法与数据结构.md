# 数据结构

## 基础

存储和组织数据的集合。

### 分类

**逻辑结构**

- 集合结构：集合元素同属与一个集合，无其他关系
- 线性：数据元素存在一对一关系
- 树型：数据元素存在一对多关系
- 图型：数据元素存在多对多关系

**物理结构**

- 逻辑结构在计算机中真正的表示方式。
- 顺序结构：如数组，内存地址连续
- 链式结构：如链表，数据单元之间通过指针指向

### 线性结构与非线形结构

线性结构：

- 最常用，数据元素之间存在一对一的线性关系
- 顺序存储结构和链式存储结构，顺序表（元素存储连续）/链表（元素存储不一定连续）
- 常见：数组、队列、链表、栈

非线形结构：

- 不是一对一了
- 二维数组、多维数组、广义表、树、图

### Array

#### sparsearray稀疏数组

记录了很多没有意义的数组，压缩->稀疏数组。

当一个数组中大部分元素为0或同一个只，可以使用稀疏数组来保存。节省空间

![image-20200531133548816](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200531133548816.png)

### Stack

先进后出的线形结构。入顺序和出顺序相反。

元素的插入和删除只在线性表的一端进行，称为栈顶，另一段为栈底。

应用场景：

- 子程序的调用
- 递归调用
- 表达式的转换：中缀表达式转后缀表达式
- 二叉树的遍历
- 图深度优先搜索

#### 数组模拟栈

```java
class ArrayStack {
    private int maxSize;
    private int[] stack;
    private int top = -1;
    
    publi ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }
    
    public boolean isFull() {
        return top == maxSize - 1;
    }
    
    public boolean isEmpty() {
        return top == -1;
    }
    
    public void push(int value) {
        if(isFull()) {
            return;
        }
        top++;
        stack[top] = value;
    }
    
    public int pop() {
        if(isEmpty()) {
            thr
        }
        return stack[--top];
    }
    
    public void list() {
        // cong top start
        if(isEmpty()) {
            sout;
        }
        for (int i = top; i >= 0; i--) {
            sout;
        }
    }
}
```

#### 用栈完成计算器

数栈、符号栈

![image-20200531214619788](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200531214619788.png)

#### 前缀、中缀、后缀表达式（逆波兰）

前缀：从右到左扫描，遇到数字压入栈，遇到运算符，弹出栈顶两个数运算，结果入栈。重复。例如-x+3456=(3+4)x5-6

中缀：人用的

后缀：(3+4)x5-6=34+5x6-，从左向右扫描，遇到数字，压入栈，遇到运算符弹出两个元素运算，结果入栈，重复。

#### 中缀转后缀

![image-20200531215826280](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200531215826280.png)

![image-20200531215833087](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200531215833087.png)

![image-20200531220541995](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200531220541995.png)

### Queue

#### 什么是队列

队列是数据结构中比较重要的一种类型，它支持FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。可以用**数组**或**链表**实现。

#### 队列种类

- 单队列（单队列就是常见的队列，每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况）
- 循环队列（避免了“假溢出”的问题）

#### Java集合框架中的队列Queue

Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。 Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。 除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。

#### 数组模拟队列

```java
class ArrayQueue {
    private int maxSize;
    private int front;
    private int rear;
    private int[] arr;
    
    public ArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = -1;
        rear = -1;
    }
    
    public boolean isFull() {
        return rear == maxSize - 1;
    }
    
    public boolean isEmpty() {
        return rear == front;
    }
    
    public void add(int n) {
        if(isFull()) {
            thr/sout;
            return;
        }
        arr[++rear] = n;
    }
    
    public int poll() {
        if(isEmpty()) {
            throw;
        }
        return arr[++front];
    }
    
    public void list() {
        if(isEmpty()) {
            sout(empty);
            return;
        }
        for(int i = front + 1; i <= rear; ++) {
            sout;
        }
    }
    
    public int peek() {
        if(isEmpty()) {
            throw;
        }
        return arr[front+1];
    }
}
```

#### 数组模拟环形队列

```java
class CircleArrayQueue {
    private int maxSize;
    private int front;
    private int rear;
    private int[] arr;
    
    public ArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = 0;
        rear = 0;//指向队列最后一个元素的后一个位置，因此需要队列预留一个空间，所以呢数组最大空间要比实际应用大
    }
    
    public boolean isFull() {
        return (rear + 1) % maxSize == front;
    }
    
    public boolean isEmpty() {
        return rear == front;
    }
    
    public void add(int n) {
        if(isFull()) {
            thr/sout;
            return;
        }
        arr[rear++] = n;
        rear = rear % maxSize;
    }
    
    public int poll() {
        if(isEmpty()) {
            throw;
        }
        int ret = arr[front];
        front = (front + 1) % maxSize;
        return ret;
    }
    
    public void list() {
        if(isEmpty()) {
            sout(empty);
            return;
        }
        for(int i = front; i <= front + (rear - front) % maxSize; i++) {
            sout; i % maxSize;
        }
    }
    
    public int peek() {
        if(isEmpty()) {
            throw;
        }
        return arr[front];
    }
}
```



### Set

#### 什么是set

Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合，主要HashSet和TreeSet两大实现类。

在判断重复元素的时候，HashSet集合会调用HashCode()和equal()方法来实现；TreeSet集合会调用compareTo方法来实现。

#### 有序集合与无序集合

- 有序集合：集合里的元素可以根据key或index访问（List、Map）
- 无序集合：集合里的元素只能遍历。（Set）

#### HashSet和TreeSet底层数据结构

HashSet是哈希表结构，主要利用HashMap的key来存储元素，计算插入元素的hashCode来获取元素在集合中的位置；

TreeSet是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序。

### Linked List

链表，以节点的方式存储，每个节点包含data域和next域，next域指向下一个节点。

#### 手写单链表

```java
class HeroNode {
	public int no;
    public String name;
    public String nickName;
    public HeroNode next;
    
    // cons
    
    // toString
    
    
}

class SingleLinkedList {
    // init head node
    private HeroNode head = new HeroNode(0,"","");
    
    public void add(HeroNode heroNode) {
        HeroNode tmp = head;
        while (true) {
            if(tmp,next == null) {
             	break;   
            }
            tmp = tmp.next;
        }
        tmp.next = heroNode;
    }
    
    public void list() {
        if(head.next == null) {
            sout(k);
            return;
        }
        HeroNode tmp = head;
        while (true) {
            if(tmp,next == null) {
             	return;
            }
            sout();
            tmp = tmp.next;
        }
    }
 	
    public void addByOrder(HeroNode heroNode) {
        HeroNode tmp = head;
        boolean flag = false;
        while(true) {
            if(tep.next == null) {
                break;
            }
            if(tmp.next.no > heroNode.no) {
                break;
            } else if (tmp.next.no == heroNode.no) {
                flag = true; //存在
                break;
            }
            tmp = tmp.next;
        }
        if (flag) {
            // cunzai
        } else {
            heroNode.next = tmp.next;
            tmp.next = heroNode;
        }
        
    }
    
    public void update(HeroNode newHeroNode) {
        if(head.next == null) {
            return;
        }
        HeroNode tmp = head.next;
        boolean flag = false;
        while (true) {
            if (tmp == null) {
                break;
            }
            if(tmp.ni == newHeroNode.no) {
                flag = true;
                break;
            }
            tmp = tmp.next;
        }
        if(flag) {
            tmp.name = newNode.name;
            tmp.nickName = newHeroNode.nickName;
        } else {
            // meizhaodao
        }
    }
    
    public void delete(int no) {
        HeroNode tmp = head;
        boolean flag =  flase;
        while (true) {
            if(tmp.next == null) {
                break;
            }
            if(tmp.next.no == no) {
                flag = true;
            }
            tmp = tmp.next;
        }
        if(flag) {
            tmp.next = tmp.next.next;
        } else {
            // meizhaodao
        }
    }
    
}
```

#### 面试题

- 遍历单链表
- get单链表倒数第k个元素：两次遍历/双指针
- 单链表的反转：头插法/双（三）指针
- 反向打印单链表：栈/数组存储引用，倒序打印；先反转（会改变原结构）
- 合并两个有序单链表，合并后依然有序
- 约瑟夫问题，丢手帕问题，单向环形链表，打印出来的顺序

#### 双向链表

单链表只能查找一个方向，双向链表可以向前或向后。

单链表不能自我删我，需要借助辅助节点，双链表可以自我删除。

#### 手写双向链表

```java
class DoubleLinkedList {
    private HeroNode head = new HeroNode(...);
    // 基本类似吧
}

class HeroNode {
    public int no;
    public String name;
  	public String nickName;
    public HeroNode pre = null;
    public HeroNode next = null;
    
}
```

#### 单向环形链表

约瑟夫问题：两个指针，curr->指向头节点，last->指向尾节点，尾节点.next=头节点，报k的出圈，那么curr和last移动k-1步，然后移除curr节点，新的curr为curr的next，继续出圈。直到只剩一个节点即last==curr，直接出圈即可。

```java
class Boy {
    private int no;
    private Boy next;
    
    // cons
    
    //get/set
}

class CircleSingleLinkedList {
    private Boy first = new Boy(-1);
    
    public void add(int i) {
        // 校验i
        
    }
}
```



### List

#### 什么是List

在List中，用户可以精确控制列表中每个元素的插入位置，另外用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。与Set不同，List通常允许重复的元素。另外List是有序集合而Set是无序集合。

#### List常见实现类

**ArrayList** 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。

**LinkedList** 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率高。

**Vector** 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。

**Stack** 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。

### 哈希表

散列表，根据关键字而直接进行访问的数据结构，加快查找的速度。通过关键字映射到数组一个位置，映射函数叫做散列函数。

Demo

```java
class Emp {
    public int id;
    public String name;
    public Emp next;
    
    // cons
    
}

class EmpLikedList {
    private Emp head;
    
    // 假定id自增
    public void add(Emp emp) {
        if (head == null) {
            head = emp;
            return;
        } else {
            Emp curr = head;
            while (!curr.next == null) {
                curr = curr.next;
            }
            curr.next = emp;
        }
    }
    
    public void list() {
        if(head == null) {
            return;
        }
        Emp curr = head;
        while(curr != null) {
            sout(curr);
            curr = curr.next;
        }
    }
    
    public Emp findById(int id) {
        if(head == null) {
            return null;
        }
        Emp curr = head;
        while(curr != null && curr.id != id) {
            curr=curr.next;
        }
        if(curr == null) {
            return null;
        }
        return curr;
    }
    
    
}

class HashTab {
    // guanli 多个链表
    private EmpLinkedList[] data;
    private int size;
    
    public HashTab(int cap) {
        data = new EmpLinkedList[cap]; // 只创建了数组 没有链表
        // 分别初始化
        for(int i = 0; i < size; i++) {
            data[i] = new EmpLinkedList();
        }
        this.size = cap;
    }
    
    public void add(Emp emp) {
        // 根据id得到index
        int no = hash(emp.id);
        data[no].add(emp);
    }
    
    public void listAll() {
        for(EmpLinkedList e : data) {
            e.list();
        }
    }
    
    public Emp findById(int id) {
        int index = hash(id);
        Emp emp = data[no].findById(id);
        if(emp == null) {
            sout("no");
            return null;
        } else {
            return Emp;
        }
    }
    
    public int hash(int id) {
    	return id % size;    
    }
}
```



### 树

数组：下标访问，速度快，有序数组还可以二分。缺点，检索具体某个值，插入值会整体移动

链表：插入删除快，查找慢

树：能提高存储和读取效率，比如二叉排序树，还能保证查找速率

#### 术语

节点：

跟节点：

父节点：

子节点：

叶子节点：没有子节点的节点

节点的权：节点的值

路径：从root到该节点的路线

层：1、2、3

子树：

树的高度：最大层数

森林：多颗子树构成森林

#### 二叉树

每个节点最多有两个字节点，左子节点、右子节点。

(1)[完全二叉树](https://baike.baidu.com/item/完全二叉树)——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布（叶子节点连续），这就是完全二叉树。

(2)[满二叉树](https://baike.baidu.com/item/满二叉树)——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。**所有叶子节点都在最后一层，节点数为2^n-1；n为层数**

(3)[平衡二叉树](https://baike.baidu.com/item/平衡二叉树/10421057)——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

#### 二叉树的遍历

- 前序遍历

  ```java
  class HeroNode {
      xxxx;
      HeroNode left;
      HeroNode right;
  }
  
  public static void preOrder(HeroNode root) {
      sout(root);
      if(root.left != null)
  	    preOrder(root.left);
      if(root.right != null)
      	preOrder(root.right);
  }
  
  public static void infixOrder(HeroNode root) {
      if(root.left != null)
          infixOrder(root.left);
      sout(root);
      if(root.right != null) 
          infixOrder(root.right);
  }
  
  public static void postOrder(HeroNode root) {
      
      if(root.left != null)
  	    preOrder(root.left);
      if(root.right != null)
      	preOrder(root.right);
      sout(root);
  }
  
  
  ```

  

- 中序遍历

- 后序遍历



#### 顺序存储二叉树

数组存储方式和二叉树的存储方式可以互相转换。

特点：n的左2n+1，n的右为2n+2，n的父亲(n-1)/2，n表示第几个节点，通常跟节点为0

数组的先序遍历：

```java
class ArrayBinaryTree {
    private int[] arr;
    // constructor
    
    public void preOrder(int index) {
        if(arr == null || arr.length == 0) return;
        sout(arr[index]);
        if (2 * index + 1 < arr.length) {
            preOrder(2*index+1);
        }
        if (2 * index + 2 < arr.length) {
            preOrder(2*index+2);
        }
    }
    
    public void infixOrder(int index) {
        if(arr == null || arr.length == 0) return;
        if (2 * index + 1 < arr.length) {
            preOrder(2*index+1);
        }
        sout(arr[index]);
        if (2 * index + 2 < arr.length) {
            preOrder(2*index+2);
        }
    }
    
    public void postOrder(int index) {
        if(arr == null || arr.length == 0) return;
        if (2 * index + 1 < arr.length) {
            preOrder(2*index+1);
           
        }
        if (2 * index + 2 < arr.length) {
            preOrder(2*index+2);
        }
        sout(arr[index]);
    }
    
}
```

#### 线索化二叉树

n个节点的二叉链表中，含有n+1个空指针域，，利用空指针域来存储某种遍历次序下的前驱和后继节点指针，这种附加指针称为线索。

- 前序线索化二叉树
- 中序线索化二叉树
- 后续线索化二叉树

![image-20200602000141098](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200602000141098.png)

线索化后：

- left可能是左子树，也可能是前驱
- right可能是右子树，也可能是后继

中序线索化：

```java
class HeroNode {

    private int leftType;//0左 前1
    private int rightType;//0 右1后
    
    
}

class BinaryTree {
    private HeroNode root;
    
    
    
    
    priavte HeroNode pre = null; //线索化过程中 保存前一个节点
    public void infixThreadedNodes(HeroNode root) {
        if(root == null) return;
        
        // 先线索化左子树
        infixThreadedNodes(root.left);
        // 线索化当前节点
        if(root.left == null) {
            root.left = pre;
            root.leftType = 1;
        }
        if(pre != null && pre.right == null) {
            pre.right = root;
            pre.rightType = 1;
        }
        pre = root;
        
        // 线索化右子树
        infixThreadedNodes(root.right);
    }
    
    
    // 遍历线索化中序二叉树
    public void list() {
        HeroNode node = root;
        while(node != null) {
            // 找到第一个leftType=1的节点 也就是中序遍历第一个节点，该节点lefttype=1，left=null
            node = node.left;
        }
        sout(node);
        while (node.rightType = 1) {
            node = node.right;
        }
        node = node.right;
    }
}


```



#### 二叉查找树（BST）

也叫二叉排序树。

- 数组未排序，直接在数组末尾添加，快，但是查找慢
- 数组排序，可以使用二分查找，但是插入需要整体移动，慢
- 链表，不管是否有序，查找都慢，添加快，因为不需要整体移动

二叉查找树的特点：

1. 若任意节点的左子树不空，则左子树上所有结点的 值均小于它的根结点的值；
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于（等于）它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点（no duplicate nodes）。（？）

```java
class Node {
    int val;
    Node left;
    Node right;
    
    
    public void add(Node node) {
        if (node == null) {
            
        }
        
        if(node.val < this.val) {
            if(this.left == null) {
                this.left = node;
            } else {
                this.left.add(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node); 
            }
        }
    }
    // 删除：
    // 1。 删除叶子
    // 2。 删除只有一个子树的节点
    // 3。 删除有两个子树的节点
    
    
    public Node search(int value) {
        if(value == this.value) {
            return this;
        } else if (value < this.value) {
            if(this.left == null) {
                return null;
            } else {
            	this.left.search(value);    
            }
            
        } else {
            if(this.right == null) {
                return null;
            } else {
                this.right.search(value);
            }
        }
    }
    
    
    // 写的不好，值可以相同
    public Node searchParent(int value) {
        if((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
            if(value < this.value && this.left != null) {
                return this.left.searchParent(value);
            } else if(value >= this.value && this.right != null) {
                return this.right.searchParent(value);
            } else {
                return null;
            }
        }
    }
}

class BinarySortTree {
    private Node root;
    
    public void add(Node node) {
        if(root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }
    public Node search(int value) {
        if(root == null) {
            return null;
        } else {
            return root.search(value);
        }
    }
    
    public Node searchParent(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searchParent(value);
        }
    }
    
    public void delNode(int value) {
        if(root == null) {
            return;
        } else {
            Node target = search(value);
            if(target == null) {
                return;
            }
            // 如果rarget没有父节点，即根节点
            if(root.left == null && root.right == null) {
                root = null;
                return;
            }
            
            Node parent = searchParent(value);
            if(targetNode,left == null && target.right == null) {
                // 叶子
                if(parent.left != null && parent.left.value == target.val) {
                    parent.left = null;
                } else {
                    parent.right = null;
                }
            } else if (target.left != null && target.right != null) {
                // 有左右孩子
                // 找右子树的最小节点
int minVal =                 delRightTreeMin(target.right);
                target.value = minVal;
                
                
            } else {
                // 只有一个孩子
                if(target.left != null) {
                    if(parent != null) {
                        
                    
                        if(parent.left.value = value) {
                            parent.left = target.left;
                        } else {
                            parent.right = target.left;
                        }
                    } else {
                        root = target.left;
                    }
                } else {
                    if(parent != null) {
                        
                    
                        if(parent.left.value = value) {
                            parent.left = target.right;
                        } else {
                            parent.right = target.right;
                        }
                    } else {
                        root = target.right;
                    }
                }
            }
        }
    }
    
    
    // 返回最小节点的值
    // 删除该节点
    public int delRightTreeMin(Node node) {
        Node target = node;
        while(target.left != null) {
            target = target.left;
        }
        delNode(target.value);
        return target.value;
    }
}
```



#### 平衡二叉树（Self-balancing binary search tree）

平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等

平衡二叉搜索树，保证查询效率：

- 它是一颗空树或它的左右两个子树的高度差不超过1，并且两个子树也是avl

左旋转：

- 创建一个新节点，值等于当前根节点的值
- newNode.left = curr.left
- newNode.right = curr.right.left;
- curr.val = curr.right.val
- Curr.right = curr.right.right
- Curr.left = newNode

![image-20200603145739549](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603145739549.png)

```java
// 添加完节点后判断，左右子树高度差，如果右子树高度-左子树高速>1,进行左旋
if（rightHeighr() - leftHeight > 1) {
    if(curr.right != null &&)
}
public void leftRotate() {
    Node curr;
    Node newNode = new Node(curr.value);
    newNode.left = curr.left;
    newNode.right = curr.right.left;
    curr.value = curr.right.value;
    curr.right = curr.right.right;
    curr.left = newNode;
}
```

右旋转：

- 创建一个新节点，值等于当前根节点的值
- newNode.right = curr.right
- newNode.left = curr.left.rightt;
- curr.val = curr.left.val
- Curr.left = curr.left.left
- Curr.right = newNode

![image-20200603150529542](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603150529542.png)

```java
public void rightRotate() {
    Node curr;
    Node newNode = new Node(curr.value);
    newNode.right = curr.right;
    newNode.left = curr.left.right;
    curr.value = curr.left.value;
    curr.left = curr.left.left;
    curr.right = newNode;
}
```

双旋转：





![image-20200603151717328](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603151717328.png)

- 符合右旋
- 他的左子树的右子树高度大于左子树左子树的高度
- 先对这个节点的左节点进行左旋
- 然后再对根右旋

```java
if（leftheight - rightheight > 1) {
    if(left != null && left.rightHeight > left.leftHeight) {
        // 先左旋转
        left.leftRotate();
        curr.rightRotate();
    } else {
        curr.rightRotate();
    }
    
    return !!
}

if(rightHeight - leftHeight > 1) {
    if(right != null && right.leftHeight > right.rightHeight) {
        // 先右旋
        right.rightRotate();
        curr.leftRotate();
    } else {
        curr.leftRotate();
    }
    
    return!!!
}
```



#### 红黑树

红黑树特点:

1. 每个节点非红即黑；
2. 根节点总是黑色的；
3. 每个叶子节点都是黑色的空节点（NIL节点）；
4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

红黑树的应用：

TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。

##### 为什么要用红黑树

简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

##### 问题：hashmap为什么不使用AVL树而使用红黑树？

最主要的一点是：

**在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，
如果插入时间过长必然等待时间更长，而红黑树相对AVL树他的插入更快！**

红黑树和AVL树都是**最常用的平衡二叉搜索树**，它们的查找、删除、修改都是O(lgn) time

AVL树和红黑树有几点比较和区别：
（1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。
（2）红黑树更适合于插入修改密集型任务。
（3）通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。

**总结**：
（1）AVL以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。
（2）两种实现都缩放为a O(lg N)，其中N是叶子的数量，但实际上AVL树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。另一方面，插入和删除方面，AVL树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。
（3）在AVL树中，从根到任何叶子的最短路径和最长路径之间的差异最多为1。在红黑树中，差异可以是2倍。
（4）两个都给O（log n）查找，但平衡AVL树可能需要O（log n）旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查O（log n）节点以确定旋转的位置）。旋转本身是O（1）操作，因为你只是移动指针。

#### 多路查找树

二叉树：

- 如果节点很多，构建二叉树时需要多次io操作
- 如果节点很多，会造成树高度很大，降低查找效率

##### B树：

- 重新组织节点，降低树的高度
- 利用磁盘预读原理，如果将一个节点设置为一个页，这样每个节点需要一次IO就可以完全载入
- 将树的度设置为1024，在600亿个元素中最多4次IO操作就可以读取到元素，B树广泛用于文件存储系统以及数据库系统
- ![image-20200603154035765](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603154035765.png)

##### 2-3树：

- 简单的B树
- 所有叶子都在同一层
- 有两个子节点的节点叫做二节点，二节点要么没有子节点，要么有两个子节点
- 有三个子节点的节点叫做三节点，三节点要么没有子节点，要么有三个子节点
- 2-3树由二节点和三节点构成
- 插入时，如果不能满足上面要求，就绪要拆，先向上拆，如果上层慢，则拆本层，
- 对于三节点的子树的值大小遵守BST的规则
- ![image-20200603154550498](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603154550498.png)
- ![image-20200603154643664](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603154643664.png)

##### 2-3-4树：

##### B树：

![image-20200603154901611](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603154901611.png)

- B树的阶：节点的最多子节点的个数
- B树的搜索，从根节点开始，对节点内的关键字序列进行二分查找，如果命中结束，否则进入儿子
- 关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据
- 搜索可能在非叶子节点结束
- 搜索性能等价于在关键字全集内进行一次二分查找

##### B+树

![image-20200603155100033](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603155100033.png)

- 叶子节点才命中，所有关键字都在叶子节点中
- 非叶子节点相当于叶子节点的索引，叶子节点是存储（关键字）数据的数据层
- 适合于文件索引系统
- B树和B+树有自己的应用场景

##### B*树

B+树的变体，在B+树的非根非叶子节点之间，增加指向兄弟的指针。

![image-20200603155650770](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603155650770.png)



#### B-、B+、B*树

B-树（或B树）是一种平衡的多路查找（又称排序）树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance)

1. B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。
2. B+树支持range-query（区间查询）非常方便，而B树不支持。这是数据库选用B+树的最主要原因。
3. B\*树 是B+树的变体，B\*树分配新结点的概率比B+树要低，空间使用率更高；

#### LSM树

B+树最大的性能问题是会产生大量的随机IO

为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。

#### 应用

##### 堆排序

- 一种选择排序，Onlongn，不稳定。
- 堆事具有以下性质的完全二叉树：每个节点的值都大于或等于其左右的，称为大顶堆；节点值小于等于其左右的，称为小顶堆
- 思想：
  - 将待排序数组构成一个大顶堆（构建时，从最后一个非叶子节点开始调整）
  - 将堆顶元素与末尾元素交换，则末尾即为最大值
  - 将剩余元素重新构建大顶堆，再交换、再构建

```java
// 升序排列、大顶堆
public static void heapSort(int[] arr) {
    for(int i = arr.length / 2 - 1; i>= 0; i--) {
        // 从最后一个非叶子开始构建堆
        adjustHeap(arr, i, arr.length);
    }
    
    for(int j = arr.length - 1; j > 0; i--) {
        int tmp = arr[j];
        arr[j] = arr[0];
        arr[0] = tep;
        
        adjustHeap(arr, 0, j);
    }
}
// 构建堆（调整堆）
// i非叶子节点的索引
// len表示堆多少个元素建堆
public static void adjustHeap(int[] arr, int i, int len) {
    int curr = arr[i];
    // k开始为i的左子节点
    for (int k = i * 2; k < length; k = k * 2 + 1) {
        if(k + 1 < length && arr[k] < arr[k + 1]) { //左子小于右子
            k++;
        }
        if(arr[k] > curr) {
            // 子节点大于父
            arr[i] = arr[k];
            i = k; // 继续循环比较
        } else {
            break;
        }
    }
    /// 相当于将tmp下沉
    
    // for循环后，将以i为root的树的最大值放在了i位置
    arr[i] = temp;
}
```

##### 哈夫曼树

- 给定n个权值作为n个叶子节点，狗仔一颗二叉树，若该**树的带权路径长度**达到最小，称这样的二叉树为最优二叉树，也称哈夫曼树。
- 节点的带权路径：节点的权*路径长度
- 树的带权路径长度：所有叶子节点的带权路径长度至和
- 哈夫曼树是带权路径长度最短的树，权值较大的节点离根较近

构建哈夫曼树：

- 从小到大排序，每一个数据都是一个节点，每个节点可以堪称是一颗最简单的二叉树
- 取出根节点权值最小的两颗二叉树 
- 组成一颗新的二叉树，该心的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
- 再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4步骤，直到数列中，所有的数据都被处理，就得到一颗哈夫曼树

例如：1、3、6、7、8、13、29

![image-20200603001848540](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603001848540.png)

```java
// 给一个数列，要求转为哈夫曼
class Node implements Comparable<Node> {
    int value;
    Node left;
    Node right;
    
    
    @Override
    public int compareTo(Node o) {
        return this.value - o.value; // 从小到大
    }
}

public static void createHuffmanTree(int[] arr) {
    List<Node> nodes = new ArrayList<>();
    for(int value : arr) {
        nodes.add(value);
    }
    
    while (nodes.size() > 1) {
        Collections.sort(nodes);

        Node left = nodes.get(0);
        Node right = nodes.get(1);

        Node parent = new Node(left.value + right.value);
        parent.left = left;
        parent.right = right;

        nodes.remove(left);
        nodes.remove(right);

        nodes.add(parent);
    }
    return nodes.get(0);
    
}


```

##### 哈夫曼编码

- 一种编码方式，是哈夫曼树 在电讯通信中的经典应用之一
- 广泛地用于数据文件压缩，压缩率在20%~90%
- 是可变长编码（VLC）的一种，称为最佳编码 

原理：

- 定长编码，如果用ASCII编码，每个字母、符号都是8bit。
- 变长，根据字母、字符出现的频次，频次高的编码长度短，频次相当于哈夫曼树的节点权，路径即为编码，比如左为0，右为1
- 并且，字符的编码不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码，哈夫曼编码符合此，用了哈夫曼树，因为编码的字符都是叶子节点，所以不会出现前缀
- 注意：构建哈夫曼树的时候，可能导致编码的不同，即出现多个权重相同的字符。可以规定，每次生成的新的二叉树总是排在相同的二叉树的最后

```java
class Node implements Comparable<Node> {
    Byte data;
    int weight;
    Node left;
    Node right;
    
    @Override
    public int CompareTo(Node o) {
        return this.weight - o.weight;
    }
}

public static List<Node> getNodes(byte[] bytes) {
    ArrayList<Node> nodes = new ArrayList<>();
    Map<Byte, Integer> counts = new HashMap<>();
    for(byte b : bytes) {
        Integer count = counts.get(b);
        if(count == null) {
            counts.put(b, 1);
        } else {
            counts.put(b, count + 1);
        }
    }
    
    // 把kv转到nodes
    for(Map.Entry<Byte, Integer> e : counts.entrySet()) {
        nodes.add(new Node(e.getKey(), entry.getValue()));
    }
}

public static Node create(List<Node> nodes) {
    while(nodes.size() > 1) {
        Collections.sort(nodes);
        Node left = nodes.get(0);
        Node right = nodes.get(1);
        Node parent = new Node(-1, left.eight + right.weight);
        parent.left = left;
        parent.right = right;
        
        nodes.remove(left);
        nodes.remove(right);
        nodes.add(parent);
    }
    return nodes.get(0);
}

// StringBuilder多余了。。。
public static Map<Byte, String> huffmanCodes = new HashMap<>();
public static StringBuilder sb = new StringBuilder();
public static void getCodes(Node node ,String code, StringBuilder sb) {
    StringBuilder sb2 = new StringBuilder(sb);
    sb2.append(code);
    if(node != null) {
        if (node.data == null) {
            getCodes(node.left, "0", sb2);
            getCodes(node.right, "1", sb2);
        } else {
            huffmanCodes.put(node.data, sb2.toString());
        }
    }
}


// 数据压缩
public static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
    StringBuilder sb = new StringBuilder();
    for(byte b : bytes) {
        sb.append(huffmanCodes.get(b));
    }
    
//    将sb转bytes数组
    int len;
    if(sb.length() % 8 == 0) {
        len = sb.length() / 8;
    } else {
        len = sb.length() / 8 + 1;
    }
    
    byte[] res = new byte[len];
    int index = 0;
    for(int i = 0; i < sb.length(); i+=8) {
        String s
        if(i + 8 > sb.length()) {
    		s = sb.subString(i);        
        } else {
	        s = sb.subString(i, i + 8);    
        }
        
        
        //转
        res[index++] = (byte)Integer.parseInt(s, 2);
    }
    return res;
        
        
}


// 解压缩
public static bytes[] decode(byte[] bytes, Map<Byte, String> huffmanCodes) {
	StringBuilder sb = new StringBuilder();
    for(int i = 0; i < bytes.length - 1; i++) {
		sb.append(byteToBitString(false, bytes[i]));
    }
    
    sb.append(byteToBitString(true, bytes[bytes.length - 1]));
    // sb得到二进制字符串
    
    // 解码，利用哈夫曼编码表
    Map<String, Byte> map = new HashMap<>();
    for(Map.Entry<Byte, String> e : enset(),) {
        map.put(e.getValue(), e.getKey());
    }
    
    List<Byte> list = new ArrayList<>();
    // binli sb
    for(int i = 0; i < sb.length(); ) {
        int count = 1;
        boolean flag = true;
        Byte b = null;
        while(flag) {
            Stirng key = sb.subString(i, i + count);
            b = map.get(key);
            if(b != null) {
                flag = false;
            } else {
                count++;
            }
        }
        i += count;
        list.add(b);
    }
    
    return list.toArray(new byte[0])
    
}

// flag表示是否需要补位
public static String byteToBitString(boolean flag, byte b) {
    int temp = b;
    if(flag) temp |= 256;
    String str = Integer.toBinaryString(temp);  //这里返回Integer的二进制补码
    StringBuilder sb = new StringBuilder();
    if(flag) {
        return str.subString(str.length() -8)  // 直接截取后8位即可，因为从低数第8位的符号位不影响比如，8位的补码，转成32位，就是在前面增加符号位，0的话增加0，1 的话增加1
    } else {
        return str;
    }
}

public static void zipFile(String src, String dest) {
    FileInputStream is = null;
    OutputSTream os = null;
    ObjectOutputSTream oos = null;
    try {
	    is = new FileInputStream(src);
        byte[] b = new byte[is.available()];
        is.read(b);
        byte[] huffmanBytes = huffmanZip(b);  //对前面比周的封装
        os = new FileOutputSTream(dest);
        oos = new ObjectOuputStream(os);
        oos.writeObject(huffmanBytes);// 以对象流的方式写入，方便恢复
        oos.writeObject(huffmanCodes)；// 编码方式，编码表
            
            
        
    } catch(Exception e) {
        
    } finally {
        try {
            is.close();
            oos.close();
            os.close();
        } catch (Exception e) {
            sout;
        }
    }

}

public static void unzipFile(String src, String dest) {
    InputStream is = null;
    ObjectInputStream ois = null;
    OutputStream os = null;
    try {
        is = new FileInputStream(src);
        ois = new ObjectInputStream(is);
        byte[] b = (byte[])ois.readObject();
        Map<Byte, String> map = (Map<Byte, String>)ois.readObject();
        byte[] bytes = decode(b, map);
        
        // 写入
        os = new FileOutputStream(dest);
        os.write(bytes);
        os.flush();
    } catch () {
        
    } finally {
        try {
            os.close();
            ois.close();
            is.close();    
        } catch () {
            
        }
        
    }
}

```

注意事项：

- 已经过压缩的文件，压缩率不高
- 重复字符不多的文件，压缩率不高
- 哈夫曼按字节处理，可以处理所有的文件（二进制、文本文件）

### 堆

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

### 图

BFS以及DFS。

处理多对多的关系。一个节点可以有0个或多个相邻元素，节点之间的连接称为边，节点可以称为顶点。

- 顶点：vertex
- 边：edge
- 路径
- 无向图
- 有向图
- 带权图，边有权重值

#### 图的表示方式

邻接矩阵：二维数组，0表示不连通，1表示连通

邻接表：链表，邻接矩阵存在空间的损失，邻接表用数组+链表，数组表示各个节点，每个元素为一个链表，链表中存放与该节点相连的节点

```java
public List<STring> vertexList;
public int[][] edges;
public int numOfEdges;

public Graph (int n) {
    edges = new int[n][n];
    vertexList = new ArrayList<Stirng>(n);
    numOfEdges = 0;
}

public void insertVertex(String vertex) {
    vertexList.add(vertex);
}

public void insertEdge(int v1, int v2, int weight) {
    edges[v1][v2] = weight;
    edges[v2][v1] = weight;
    numOfEdges++;
}

public int getNumOfVertex() {
    return vertexList.size();
}

public int getNumOfEdges() {
    return numOfEdges;
}

public String getValueByIndex(int i) {
    return vertexList.get(i);
}

public int getWeight(int v1, int v2) {
    return egdes[v1][v2];
}

public void show() {
    for(int[] link : edges) {
        sout(Arrays.toString(link));
    }
}

// dfs，深度优先，从访问节点出发，首先访问第一个邻接节点，然后再将这个邻接节点作为初始节点，继续访问。深挖，递归过程
private boolean[] isVisited = new boolean[5]; // 可放在构造器传
public void getFirstNeighbor(int index) {
    for (int j = 0; j < vertexList.size(); j++) {
        if(edges[index][j] > 0) {
            return j;
        }
    }
    return -1;
}

public getNextNeighrbor(int v1, int v2) {
    for (j = v2 + 1; j <vertexList.size(); j++) {
        if(edges[v1][j] > 0) {
            return j;
        }
        return -1;
    }
}


public void dfs(boolean[] isVisited, int i) {
    sout(getValueByIndex(i));
    isVisited[i] = true;
    int w = getFirstNeighbor(i);
    while(w != -1 ) {
        if(!isVisited[w]) {
            dfs(is, w);
        }
        w = getNextNeighbor(i, w);
    }

}

public void dfs() {
    for(int i = 0; i < xx; i++) {
        if(isVisited[i]) continue;
	    dfs(is, i);         
    }

}

// bfs 广度优先搜索，分层搜索过程，需要一个队列
public void bfs(boolean[] isv,int i) {
    int u;
    int w;
    LinkedList<Integer> queue = new LinkedList<>();
    sout(i);
    isv[i] = true;
    queue.addLast(i);
    while (!queue.isEmpty()) {
        u = queue.removeFirst();
        w = getFisrtNeighbor(u);
        while(w != -1) {
            if(!isV[w]) {
                sout(w);
                isV[w] = true;
                queue.addLast(w);
            } 
            w = getNextNeighbor(u, w);
        }
    }
}

// 非联通

public void bfs() {
    for(int i = 0; i <xx; i++) {
		if(!isv[i]) {
            bfs(isv, i);
        }
    }
}


```



## 布隆过滤器

整明白儿的！

1. 什么是布隆过滤器？
2. 布隆过滤器的原理介绍。
3. 布隆过滤器使用场景。
4. 通过 Java 编程手动实现布隆过滤器。
5. 利用Google开源的Guava中自带的布隆过滤器。
6. Redis 中的布隆过滤器。

### 什么是布隆过滤器

布隆过滤器（Bloom Filter）是一个叫做Bloom的哥们1970年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的List、Map、Set等数据结构，它**占用空间更少，并且效率更高**，但是**缺点是其返回的结果是概率性的，而不是非常准确的。**理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。

![image-20200327011030598](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327011030598.png)

位数组中的每个元素都只占用1bit，并且每个元素只能是0或者1。这样申请一个100W个元素的位数组只占用1000000Bit/8 = 125000Byte=125000/1024 KB = 122KB的空间。

总结：**一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。**

### 布隆过滤器的原理介绍

当一个元素加入布隆过滤器中的时候，会进行如下操作：

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）；
2. 根据得到的哈希值，在位数组中把对应下标的的值置1。

当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为1，如果值都为1，那么说明这个值在布隆过滤器中，如果存在一个值不为1，说明该元素不在布隆过滤器中。

例子：

![image-20200327012532954](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327012532954.png)

如图，当字符串存储到要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后在对应的位数组的下标的元素设置为1（当位数组初始化时，所有位置均为0）。当第二次存储相同字符串时，因为先前的对应位置已设置为1，所以很容易知道此值已经存在（去重非常方便）。

如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

**同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。**

综上，我们可以得出：**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

### 布隆过滤器使用场景

1. 判定给定数据是否存在：比如判断一个数字是否在于包含大量数字的数字集中（数字集很大，5亿以上）、防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。
2. 去重：比如爬给定网址的时候对已经爬取过的URL去重。

### 通过Java编程手动实现布隆过滤器

如果你想要手动实现一个的话，你需要：

1. 一个合适大小的位数组保存数据
2. 几个不同的哈希函数
3. 添加元素到位数组（布隆过滤器）的方法实现
4. 判断给定元素是否存在于位数组（布隆过滤器）的方法实现。

下面给出一个我觉得写的还算不错的代码（参考网上已有代码改进得到，对于所有类型对象皆适用）：

```java
import java.util.BitSet;

public class MyBloomFilter {

    /**
     * 位数组的大小
     */
    private static final int DEFAULT_SIZE = 2 << 24;
    /**
     * 通过这个数组可以创建 6 个不同的哈希函数
     */
    private static final int[] SEEDS = new int[]{3, 13, 46, 71, 91, 134};

    /**
     * 位数组。数组中的元素只能是 0 或者 1
     */
    private BitSet bits = new BitSet(DEFAULT_SIZE);

    /**
     * 存放包含 hash 函数的类的数组
     */
    private SimpleHash[] func = new SimpleHash[SEEDS.length];

    /**
     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样
     */
    public MyBloomFilter() {
        // 初始化多个不同的 Hash 函数
        for (int i = 0; i < SEEDS.length; i++) {
            func[i] = new SimpleHash(DEFAULT_SIZE, SEEDS[i]);
        }
    }

    /**
     * 添加元素到位数组
     */
    public void add(Object value) {
        for (SimpleHash f : func) {
            bits.set(f.hash(value), true);
        }
    }

    /**
     * 判断指定元素是否存在于位数组
     */
    public boolean contains(Object value) {
        boolean ret = true;
        for (SimpleHash f : func) {
            ret = ret && bits.get(f.hash(value));
        }
        return ret;
    }

    /**
     * 静态内部类。用于 hash 操作！
     */
    public static class SimpleHash {

        private int cap;
        private int seed;

        public SimpleHash(int cap, int seed) {
            this.cap = cap;
            this.seed = seed;
        }

        /**
         * 计算 hash 值
         */
        public int hash(Object value) {
            int h;
            return (value == null) ? 0 : Math.abs(seed * (cap - 1) & ((h = value.hashCode()) ^ (h >>> 16)));
        }

    }
}
```

```java
        String value1 = "https://javaguide.cn/";
        String value2 = "https://github.com/Snailclimb";
        MyBloomFilter filter = new MyBloomFilter();
        System.out.println(filter.contains(value1)); // f
        System.out.println(filter.contains(value2)); // f
        filter.add(value1);
        filter.add(value2);
        System.out.println(filter.contains(value1)); // t
        System.out.println(filter.contains(value2)); // t
```

### 利用Google开源的Guava中自带的布隆过滤器

依赖

```java
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>28.0-jre</version>
        </dependency>
```

使用：

我们创建了一个最多存放 最多 1500个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）

```java
        // 创建布隆过滤器对象
        BloomFilter<Integer> filter = BloomFilter.create(
                Funnels.integerFunnel(),
                1500,
                0.01);
        // 判断指定元素是否存在
        System.out.println(filter.mightContain(1));
        System.out.println(filter.mightContain(2));
        // 将元素添加进布隆过滤器
        filter.put(1);
        filter.put(2);
        System.out.println(filter.mightContain(1));
        System.out.println(filter.mightContain(2));
```

在我们的示例中，当`mightContain（）` 方法返回*true*时，我们可以99％确定该元素在过滤器中，当过滤器返回*false*时，我们可以100％确定该元素不存在于过滤器中。

**Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。**

### Redis中的布隆过滤器

Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。

RedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。

#### 使用Docker安装

```
➜  ~ docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest
➜  ~ docker exec -it redis-redisbloom bash
root@21396d02c252:/data# redis-cli
127.0.0.1:6379> 
```

#### 使用命令

> 注意：key：布隆过滤器的名称，item：添加的元素。

1. **`BF.ADD`**：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：`BF.ADD {key} {item}`。
2. **`BF.MADD`** : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式`BF.ADD`与之相同，只不过它允许多个输入并返回多个值。格式：`BF.MADD {key} {item} [item ...]` 。
3. **`BF.EXISTS` ** : 确定元素是否在布隆过滤器中存在。格式：`BF.EXISTS {key} {item}`。
4. **`BF.MEXISTS`** ： 确定一个或者多个元素是否在布隆过滤器中存在格式：`BF.MEXISTS {key} {item} [item ...]`。

另外，`BF.RESERVE` 命令需要单独介绍一下：

`BF.RESERVE {key} {error_rate} {capacity} [EXPANSION expansion]`。

1. key：布隆过滤器的名称
2. error_rate :误报的期望概率。这应该是介于0到1之间的十进制值。例如，对于期望的误报率0.1％（1000中为1），error_rate应该设置为0.001。**该数字越接近零，则每个项目的内存消耗越大，并且每个操作的CPU使用率越高**。
3. capacity: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。

可选参数：

- expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以`expansion`。默认扩展值为2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。

#### 实际使用

```shell
127.0.0.1:6379> BF.ADD myFilter java
(integer) 1
127.0.0.1:6379> BF.ADD myFilter javaguide
(integer) 1
127.0.0.1:6379> BF.EXISTS myFilter java
(integer) 1
127.0.0.1:6379> BF.EXISTS myFilter javaguide
(integer) 1
127.0.0.1:6379> BF.EXISTS myFilter github
(integer) 0
```

# 算法

## 递归

### 应用

- 数学问题：8皇后、汉诺塔、阶乘、迷宫、球和篮子。。。
- 算法：快排、归并、二分查找、分治
- 用栈解决的问题-->转为递归

### 重要规则

- 当程序执行到一个方法时，就会开辟一个独立的空间（栈帧）
- 方法的局部变量是独立的，相互不影响。如果是引用类型，会共享该对象（数组、对象）
- 递归必须向退出递归的条件逼近，否则无限递归，StackOverflowError
- 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

### 迷宫问题

![image-20200531223914881](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200531223914881.png)

```java
public static void main(String[] args) {
    int[][] map = new int[8][7];
    //1表示墙，
    // 上下左右全置1	
    for(int i = 0; i < 7; i++) {
        map[0][i] = 1;
        map[7][i] = 1;
    }
    
    for(int i = 0; i < 8; i++) {
        map[i][0] = 1;
        map[i][6] = 1;
    }
 	
    // 再设置一些墙
    
    map[3][1] = 1;
    map[3][2] = 1;
    
    // 使用递归回溯给小球找路
    
    
}

// map为地图，i、j表示出发位置，我们找右下角map[6][5],map=1表示没走过，1表示不能走，2表示可以走，3表示走过但是走不通，策略，需要确定一个策略，例如先往下走再往右走，再往上走，再往左走（走不通换方向)，走不通回溯
public static boolean setWay(int[][] map, int i, int j) {
    if(map[6][5] == 2) {
        return true;
    } else {
        if(map[i][j] == 0) {
            // 没走过，按策略走
            map[i][j] = 2; //嘉定可以走通
            
            if(setWay(map, i + 1, j)) {
                // 向下走
                return true;
            } else if (setWay(map, i , j + 1)) {
                return true;
            } else if (setWay(map, i - 1, j)) {
                return true;
            } else if (setWay(map, i , j - 1)) {
                return true;
            }
            // 回，这个点不行
            map[i][j] = 3;
            
        } else {
//             map[i][j] != 0  可能是123，都不能走了
            return false;
        }
    }
}
```

#### 如何找最短路

1. 与找路策略有关

#### 八皇后问题

8x8棋盘，摆八个皇后，不能再同一行同一列，同一斜线。92种

![image-20200531225806504](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200531225806504.png)

```java
int max = 9;
int count = 0;
int[] array = new int[max]; // 存储结果  下标为行，值为列

private void print() {
    for(int i = 0; i < array.length; i++) {
        sout(array[i]);
    }
}

private void check(int n) {
    if(n == max) {
        // 8个已经放好
        print();
        count++;
        return;
    } 
    // 依次放入冰判断冲突
    
    for(int i = 0; i < max; i++) {
        // 把第n个皇后放到该行i列
        array[n] = i;
        if(judge(n)) {
            check(n+1);
        }
        // 冲突的话，conti
        
    }
}

// n表示第n个皇后
private boolean judge(int n) {
    for (int i = 0; i < n; i++) {
        if(array[i] == array[n] // 同一列
          || Math.abs(n-i) == Math.abs(array[n] - array[i])) { // 斜线
            return false
    }
    }
}

public static void main(String[] args) {
    check(0);
}
```

## 排序

排序算法，将一组数据按制定的顺序排列的过程。

分类：

- 内部排序：数据全部加载到内存进行排序
- 外部排序；数据量过大，无法全部加载到内存，需要借助外部存储进行排序

![image-20200601124618563](/Users/zhaojiangdong/Documents/Postgraduate/认知自组网/image-20200601124618563.png)

### 算法时间复杂度

1. 事后统计方法：运行，查看运行时间。
   1. 需要实际运行该程序
   2. 依赖于硬件软件环境因素，需要在同样机器上才能比较两种算法优劣
2. 事前估算方法：通过算法时间复杂度判断

#### 时间频度

T(N)：时间频度，一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它话费时间就多。

- 忽略常数项
- 忽略低次项
- 忽略系数

#### 时间复杂素

![image-20200601125825979](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200601125825979.png)

常见时间复杂度：

- 常数 1
- 对数 log2n
- 线性 n
- 线形对数 nlog2n
- 平方 n2
- 立方 n3
- k次方 nk
- 指数 2 n
- n!

#### 平均与最坏

![image-20200601130430841](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200601130430841.png)

#### 空间复杂度

耗费的存储空间。多讨论时间复杂度哦，一些缓存和算法的本质就是空间换时间。

### 冒泡排序

Bubble Sorting，通过对待排序序列从前向后，依次比较相邻元素的值，若发现逆序则交换，使值大的元素逐渐从前向后移动。

稳定：遇到相同元素不交换，使得其稳定。

```java
for(int i = 0; i < arr.length - 1; i++) {
    boolean flag = false;
	int temp = 0;
    for(int j = 0; j < arr.length - 1 - i; j++) {
        if(att[j] > arra[j + 1]) {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
            flag = true;
        }
    }
    if(!flag) break;
    else flag = false;
}
```

### 选择排序

从0-n-1选最小的，与arr[0]交换，再从1-n-1选最小的，与arr[1]交换。n-1次选择

```java
public static void selectSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex;
        for (int j = i + 1; j < arr.length; j++) {
            if(arr[minIndex] > arr[j]) {
                minIndex = j;
            }
        }
        int tmp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = tmp;
    }
}
```

### 插入排序

将n个待排序元素序列，看成一个有序表、一个无序表，开始时有序表只包含第一个元素，

```java
public static void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int insertValue = arr[i];
        int insertIndex = i - 1;
        while (insertIndex >= 0 && insertValue < arr[insertIndex]) {
            arr[insertIndex + 1] = arr[insertIndex];
            insertIndex--;
        }
        arr[++insertIndex] = insertValue;
    }
}
```

### 希尔排序

插入的优化。比如[2,3,4,5,6,1]后面有个1，导致前面都得移动一下。希尔增量大，排1的时候一次性可以移动很多，消除很多逆序对。移动次数会减少。

```java
public static void shellSort() {
    // 交换法
	for (int h = arr.length / 2; h >= 1; h/=2) {
        for(int i = h; i <arr.length; i++) {
            for (int j =i - h; j >=0; i-=h) { // 交换法写法，交换次数太多，时间慢
                if(arr[j] > arr[j + h]) {
                    int temp = arr[j];
                    arr[j] = arr[j + h];
                    arr[j + h] = temp;
                }
            }
    	}	
    }
    
    // 移动法
    for (int h = arr.length / 2; h >= 1; h/=2) {
        for(int i = h; i < arr.length; i++) {
            // 直接插入
            int j = i;
            int temp = arr[j];
            if(arr[j] < arr[j - h]) {
                while(j - h >=0 temp < arr[j-h]) {
                    // 移动
                    arr[j] = arr[j-h];
                    j -= h;
                }
                arr[j] = temp;
            } // else 不需要移动
    	}	
    }
 	   
}
```

### 快速排序

对冒泡的改进，通过一趟排序将要排序的数据分割成对立两部分，其中一部分比另一部分的所有数据都要笑，然后再递归对两部分分别排序。

```java
/**
 * @program Interview
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/04/19 00:22
 */
public class Quick {
    public static void main(String[] args) {
        int[] nums = new int[]{5, 8, 7, 10, 1, -3, 99};
        quickSort(nums);
        for (int i : nums) {
            System.out.println(i);
        }
    }

    public static void quickSort(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int left, int right) {
        if (left < right) {
            int pivot = partition(nums, left, right);
            quickSort(nums, left, pivot - 1);
            quickSort(nums, pivot + 1, right);
        }
    }

    private static int partition(int[] nums, int left, int right) {
        int pivot = nums[left];
        while (left < right) {
            while (left < right && nums[right] >= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left < right && nums[left] <= pivot) {
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        return left;
    }
}
```

### 归并排序

分治策略，大问题分解为小问题，然后修补在一起。需要额外空间。

```java
public static void merge(int[] arr, int left, int mid, int right) {
    int i = left; // 左边初始
    int j = mid + 1; // 右边初始
    int t = 0;
    int[] tmp = new int[right - left + 1];
    
    // 填充到tmp 
    while ( i <= mid && j <= right) {
        if(arr[i] <= arr[j]) {
            tmp[t++] = arr[i++];
        } else {
            tmp[t++] = arr[j++];
        }
    }
    
    while (i <= mid) {
        tmp[t++] = arr[i++];
    }
    while (j <= right) {
        tmp[t++] = arr[j++];
    }
    //done
    int index = 0;
    for (int k = left; k <= right; k++) { // while更快一些
        arr[k] = tmp[index++];
    }
}

public static void sort(int[] arr, int left, int right) { //传tmp数组的话 数组可以复用
    if(left < right) {
        int mid = left + (right - left) / 2;
        sort(arr, left, mid);
    	sort(arr, mid + 1, right);
	    merge(arr, left, mid +1, right)
    }
}
```

### 基数排序

分配式排序，是桶排序的扩展，稳定的排序，是效率高的稳定性排序算法。。通过键值的各个位的值，将要排序的元素分配至某些桶中，达到排序的作用。

思想：将所有带比较树值统一位同样的数位长度，数位较短的数前面补0，然后从最低位开始，一次进行一次排序，这样从最低位排序一直到最高位排序完成后，就有序了。

```java
public static void radixSort(int[] arr) {
    // 防止溢出，那么桶大小只能为a r r.length，基数排序是空间换时间
    int[][] bucket = new int[10][arr.length];
    int[] cout = new int[10]; //记录有效数据数量
    // 得到最大数的位数
    int max = arr[0];
    for(int i = 0; i < arr.length; i++) {
        if(arr[i] > max) {
            max = arr[i];
        }
    }
    int mazLength = (max + "").length();
    
    for ( int i = 0, n = 1; i < maxLength; i++, n*=10) {
        
        

        for(int j = 0; j < arr.length; j++) {
            int digitOfElement = arr[j] / n % 10;
            bucket[digitOfElement][count[digitOfElement]] = arr[j];
            count[digitOfElement]++;
        }
        int index = 0;
        // 放回
        for (int k = 0; k < count.length(); k++) {
            if(count[k] > 0) {
                for (int l =0; l < count[k]; l++) {
                    arr[index++] = bucket[k[l];
                }
            }
            count[k] = 0;
        }
     }                            
                                      
}
```

### 总结

![image-20200601212340340](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200601212340340.png)



### Arrays.sort?

## 查找

- 线性查找
- 二分/折半查找
- 插值查找
- 斐波那契查找 算法（黄金分割法）

### 二分查找

有序情况下。

```java
public int static binarySearch(int arr[], int left, int right, int target) {
    if(left > right) return -1;
    
    int mid = left + (right - left) / 2;
    int midVal = arr[mid];
    
    if (target > midVal) {
        return binarySearch(arr, mid + 1, right, target);
    } else if (target < midVal) {
        return binarySearch(arr, left, mid, target);
    } else {
        return mid;
    }
}

// 找几个相同的
public static List<Integer> binarySearch(int arr[], int left, int right, int target) {
    // 找到mid后，向左向右扫面
    if(left > right) return -1;
    
    int mid = left + (right - left) / 2;
    int midVal = arr[mid];
    
    if (target > midVal) {
        return binarySearch(arr, mid + 1, right, target);
    } else if (target < midVal) {
        return binarySearch(arr, left, mid, target);
    } else {
        List<Integer> list = new ArrayList<Integer>();
        int tmp = mid - 1;
        while(true) {
            if (temp < 0 | arr[temp] != target) {
                break;
            }
            list.add(temp--);
        }
        list.add(mid);
        temp = mid + 1;
        while (true) {
            if(temp > arr.length - 1 | arr[temp] != target) {
                break;
            }
            lisr.add(temp++);
        }
        return list;
    }
}
```

### 插值查找

对二分的改进？对mid的改进

关键字分布比较均匀时比较快。

![image-20200601214251295](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200601214251295.png)

```java
public int static insertValueSearch(int arr[], int left, int right, int target) {
    if(left > right || target < arr[0] || target > arr[arr.length - 1]) return -1;
    
    int mid = left + (right - left) * (target - arr[left]) / (arr[right] - arr[left]);
    int midVal = arr[mid];
    
    if (target > midVal) {
        return binarySearch(arr, mid + 1, right, target);
    } else if (target < midVal) {
        return binarySearch(arr, left, mid, target);
    } else {
        return mid;
    }
}
```

### 斐波那契查找0.618_黄金分割法

斐波那契数列，相邻两个元素的比例无限接近于黄金分割值0.618

原理：类似于插值，mid用黄金分割点附近

![image-20200601215403967](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200601215403967.png)

```java
// 非递归
public static int fibSearch(int[] arr, int target) {
    int low = 0;
    int high = arr.length - 1;
    int k = 0;
    int mid = 0;
    int f[] = fib();
    while(high > f[k] - 1) {
        k++;
    }
    // f[k] 可能大于arr的长度
    int[] temp = Arrays.copyOf(arr, f[k]); //不足部分0填充
    // 实际上需要使用arr最后的数填充
    for (int i = arr.length - 1; i < f[k]; i++) {
        temp[i] = arr[high];
    }
    
    while (low <= high) {
        mid = low + f(k - 1) - 1;
        if(target < temp[mid]) {
            // left
            high = mid;
            k--;
        } else if( target > temp[mid]) {
            low = mid + 1;
            k-=2;
        } else {
            if (mid <= high) {
                return mid;
            } else {
                return high;
            }
        }
    }
}

public static int[] fb)_ {
    int[] f = new int[maxSize];
    f[0]=1;f[1]=1;
    for(int i = 2; i < maxSize; i++) {
        f[i] = f[i-1]+f[i-2];
    }
    return f;
}
```

## 十种常用算法

### 二分查找非递归

```java
public static int binarySearch(int[] arr, int target) {
    // 返回下标
    
    int left = 0;
    int right = arr.length - 1;
    int mid = left + (rigth - left) / 2;
    while (left <= right) {
		if(arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}
```

### 分治算法

分而治之。

求解的经典问题：

- 二分搜索
- 大整数乘法
- 棋盘覆盖
- 归并排序
- 快速排序
- 线形时间选择
- 最接近点对问题
- 玄幻日程表
- 汉诺塔

步骤：

1. 分解问题，规模小，相对独立，形式相同的子问题
2. 若问题比较小则直接解决，否则递归分
3. 最后合并结果

案例：汉诺塔

1. n>=2的情况，可以看作是两个盘，最下面的盘，上面的盘
2. 先把上面的盘A-b
3. 把最下面的盘a-c
4. 把上面的盘移动回C

```java
public static void hanoiTower(int num, char a, char b, cahr c) {
    if(num == 1) {
        sout(cong a - >c);
    } else {
        hanoiTower(num - 1, a, c, b);
        sout(cong a - >c);
        hanoiTower(nums - 1, b, a, c);
    }
}
```

### 动态规划算法

#### 背包问题

![image-20200603164930163](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603164930163.png)

核心思想：

- 将大问题划分为小问题，从而一步一步获取最优的处理算法
- 与分治类似，也是分解
- 区别是，动态规划求解的问题，分解得到的子问题往往不是独立的，即下一个子阶段的解建立在上一个子阶段的解的基础上进一步求解
- 动态规划可以通过填表的方式来逐步推进，得到最优解

背包问题：

- 01背包，现在这个问题就是01背包，每个物品最多放一个
- 完全背包，每种物品都有无限件可用

此问题思想：

- 每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包。即根据重量和价值，令vij表示在前i个物品中能够装入容量为j的背包中的最大价值。
- Vi0 = v0j = 0
- 当w[i] > j时，vij=vi-1j，商品大于背包容量，直接用上一个结果
- 当j>=w[i]时，vij = max{vi-1j, vi-1j-w[i] + v[i]}

```java
int weight = {1,4,3};
int value = {1500, 3000, 2000}
int m = 4; //包容量
int n = val.length; //物品种类

//dp表示在前i个物品中，能装入容量为j的背包的最大价值
int[][] dp = new int[n + 1][m + 1];
    
for (int i = 0; i < v.length; i++) {
    v[i][0] = 0;
}
for (int i = 0; i < v[0].length; i++) {
    v[0][i] = 0;
}

for(int i = 1; i < v.length; i++) {
    for (int j = 1; j < v[0].length; j++) {
        if(w[i-1] > j) {
            v[i][j] = v[i-1][j];
        } else {
            v[i][j] = Math.mac(v[i-1][j], v[i-1] + v[i-1][j-w[i-1]]);
        }
    }
}

// 没有记录如何存放的

```

![image-20200603171710391](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603171710391.png)



### KMP算法

字符串查找算法，knuth-Mirris-Pratt。

通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去大量的时间。详细见后

```java
public static int[] kmpNext(String s) {
    int[] next = new int[s.length()];
    next[0] = 0;
    for(int i = 1, j = 0; i < s.lengthl i++) {
        while(j > 0 && s.charAt(i) != s.charAt(j)) {
            j = next[j - 1];
        }
        if(s.charAt(i) == s.charAt(j)) { //部分匹配+1
            j++;
        }
        next[i] = j;
    }
    return next;
}

public static int kmpSearch(String str1, String str2, int[] next) {
    for(int i =0, j = 0; i < str1.length(); i++) {
        while(j > 0 && str1.charAt(i) != str2.charAt(j) {
            j = next[j - 1];
        }
        if(str1.charAt(i) == str2.charAt(j)) {
            j++;
        }
        if(j == str2.length()) {
            return i - j - 1;
        }
    }
}
```

### 贪心算法

![image-20200603184506224](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603184506224.png)

每一步都选最优的，从而希望导致结果也是最优的。但是所得到的结果不一定是最优的结果。

思路：

- 因为需要覆盖全部地区的最小集合
- 遍历所有的广播电台，找到一个覆盖了最多未未覆盖地区的电台
- 将这个电台加入到一个集合中，想办法把该电台覆盖的地区在下次比较时去掉
- 重复1

### Prim算法

![image-20200603194013766](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603194013766.png)

最小生成树问题。

- 在包含n个节点的连通图中，找出只有n-1条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图
  - ![image-20200603194222741](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603194222741.png)

```java
class MGrapg {
    int verx;
    char[] data;
    int[][] weight;
	
    public MGraph(int n) {
        verx = n;
        data = new char[verx];
        weight = new int[n][n];
    }
    
    
}

class MinTree {
    public void createGraph(MGraph graph, int verxs, char[] data, int[][] weight) {
        int i, j;
        for(i = 0; i < verx; i++) {
            graph.data[i] = data[i];
            for(j = 0; j < verxs; j++) {
                graph.weight[i][j] = weight[i][j];
            }
        }
        
    }
    
    public void showGraph() {
        
    }
    
    // v 起始点
    public void prim(MGraph graph, int v) {
        // 标记节点是否被fang wen n
        int[] visited = new int[graph.verx];
        // Jilu 下表
   		int h1 = -1;
        int h2 = -1;
        int minWeight = 10000; // 大数
        for (int k = 0; k < gramph.verx; k++) {
            for (int i = 0; i < graph.verx; i++) {
                for(int j = 0; j < graph.verx; j++) {
                    if(visited[i] == 1 && visited[j] == 0 && graph.weight[i][j] < minWeight) {
                        minWeight = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            visited[h2] = 1;
            minWeight = 10000;
        }
        
        
    }
    
    
}
```

### Kruskal算法

也是最小生成树算法。

![image-20200603195806966](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200603195806966.png)

思想：

- 从小到大顺序选择n-1条边，并保证这些边部形成环路
- 首先构造一个只含有n个节点的森林，然后依权值从小到大葱连通网中选择变加入到森林中，并使森林无回路，直到形成一棵树



```java
class KruskalCase ;
int edgeNum;
char[] vertexs; //顶点数组
int[][] matrix; //邻接矩阵
private static final int INF = Integer.MAX_VALUE; //表示不连通

class EData {
    char start; // 边的起点
    char end; //边的另外一个点
    int weight;
    public EData(char start, char end, int weight) {
        
    }
    
    
    
    
}

// maopao
private void sortEdge(EData[] edgse) {
    for (int i = 0; i < edges.length - 1; i++) {
        for (int j = 0; j < edges.length - 1 - i; j++) {
            if(edges[j].weight > edges[j] + 1) {
                swap;
            }
        }
    }
}

private int getPosition(char ch) {
    for(int i = 0; i < vertex.length; i++) {
        if(vertex[i] == ch) {
            return i;
        }
    }
    return -1;
   
}

// 获取图中的边
private EData[] getEdges() {
    int index = 0;
    EData[] edges = new EData[edgeNum];
    for(int i = 0; i < vertex.length; i++) {
        for (int j = i + 1; j < vertex.length; j++) {
            if(matrix[i][j] != INF) {
                edges[index++] = new EData(vertex[i], vertex[j], matrix[i][j]);
            }
        }
    }
    return edges;
}

private int getEnd(int[] ends, int i) {
    // 获取下标为i的顶点的终点，用于判断两个顶点的终点是否相同，是否成环
    // ends在过程中记录，记录各个顶点的终点
    while(ends[i] != 0) {
        i = ends[i];
    }
    return i;
    
}

psvm {
    KruskalCase k = new Kr..;
    EData[] a = k.getEdges();
    sortEdge(a);
    
}
```

### Dijkstra算法

从一个点到其他所有点的最短路径。

### Floyd算法

也是寻找加权图中顶点间最短路径的算法。

对比：

- Dij：通过选定的被访问节点，求出从出发访问顶点到其他顶点的最短路径
- Flo：每一个顶点都是发出访问点，所以需要将每个顶点看作被访问顶点，求出从每一个顶点到其他顶点的最短路径。

### 马踏棋盘算法

也叫骑士周游问题。

## 题目

### 字符串

#### KMP算法

KMP算法用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP算法把字符匹配的时间复杂度缩小到O（m+n），而空间复杂度也只有O（m）。因为“暴力搜索”的方法反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效位置。

##### 说明一

1. 首先字符串与搜索词的第一个字符比较，比匹配则后移。

![image-20200327140543064](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327140543064.png)

2. 仍然不匹配，继续后移。![image-20200327140635817](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327140635817.png)

3. 知道匹配到第一个字符![image-20200327140714938](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327140714938.png)

4. 接着比较第二个字符![image-20200327140730298](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327140730298.png)

5. 直到有一个不匹配![image-20200327140743546](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327140743546.png)

6. 基本做法是将搜索词整个后移一位，再从头逐个比较，但是效率很差，因为要把“搜索位置”移到已经比较过的位置，重比一遍。![image-20200327140851787](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327140851787.png)

7. 一个基本事实，当空格与D不匹配时，你其实知道前面六个字符是ABCDAB。KMP的想法是，设法利用这个已知信息，不要把“搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。

8. 如何做？针对搜索词，算出一张《部分匹配表》（
   Partial Match Table）。

   ![image-20200327141117781](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327141117781.png)

9. 已知空格与D不匹配时，前面六个字符“ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的“部分匹配值”为2，因此按照下面的共识算出向后移动的位数：![image-20200327141239636](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327141239636.png)

10. 因为空格与C不匹配，搜索词还要继续往后移。这时，已匹配的字符数位2（“AB”），对应的部分匹配值为0，所以移动2-0位。![image-20200327141310680](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327141310680.png)

11. 因为空格与A不匹配，继续后移：![image-20200327141514955](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327141514955.png)
12. 逐位比较，知道发现C与D不匹配。于是，移动位数= 6 - 2，继续将搜索词向后移动4位。![image-20200327141602112](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327141602112.png)
13. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索，移动7-0位。![image-20200327141649456](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327141649456.png)

##### 部分匹配表如何产生？

首先了解：“前缀”和“后缀”。“前缀”是指除了最后一个字符外，一个字符串的全部头部组合；“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。![image-20200327142204595](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327142204595.png)

“部分匹配值”就是“前缀”和“后缀”的最长的共有元素的长度，以”ABCDABD“为例。

- "A"的前缀和后缀都为空集，共有元素的长度为0；

- "AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；

- "ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；

- "ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；

- "ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；

- “ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；

- "ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。

"部分匹配"的实质是，有时候，字符串头部和尾部会有重复。比如，"ABCDAB"之中有两个"AB"，那么它的"部分匹配值"就是2（"AB"的长度）。搜索词移动的时候，第一个"AB"向后移动4位（字符串长度-部分匹配值），就可以来到第二个"AB"的位置。

##### 算法说明

下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）：

- 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置
  - 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；
  - 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。
    - 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。

```java
int KmpSearch(char* s, char* p)
{
	int i = 0;
	int j = 0;
	int sLen = strlen(s);
	int pLen = strlen(p);
	while (i < sLen && j < pLen)
	{
		//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
		if (j == -1 || s[i] == p[j])
		{
			i++;
			j++;
		}
		else
		{
			//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
			//next[j]即为j所对应的next值      
			j = next[j];
		}
	}
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

最后总结下这个算法：

1. 匹配失败时，总是能够让模式串回退到某个位置，使文本不用回退。
2. 在字符串比较时，模式串提供的信息越多，计算复杂度越低。（有兴趣的可以了解一下 Trie 树，这是文本提供的信息越多，计算复杂度越低的一个例子。）

#### 替换空格

> 剑指offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

提供两种方法：常规方法；API解决。

```java
//https://www.weiweiblog.cn/replacespace/
public class Solution {

  /**
   * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(" "
   * )遍历字符串并判断元素是否为空格。是则替换为"%20",否则不替换
   */
  public static String replaceSpace(StringBuffer str) {

    int length = str.length();
    // System.out.println("length=" + length);
    StringBuffer result = new StringBuffer();
    for (int i = 0; i < length; i++) {
      char b = str.charAt(i);
      if (String.valueOf(b).equals(" ")) {
        result.append("%20");
      } else {
        result.append(b);
      }
    }
    return result.toString();

  }

  /**
   * 第二种方法：利用API替换掉所用空格，一行代码解决问题
   */
  public static String replaceSpace2(StringBuffer str) {

    return str.toString().replaceAll("\\s", "%20");
  }
}
```

#### 最长公共前缀

> Leetcode: 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

示例 1:

```
输入: ["flower","flow","flight"]
输出: "fl"Copy to clipboardErrorCopied
```

示例 2:

```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。Copy to clipboardErrorCopied
```

思路很简单！先利用Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！（还可以遍历比较公共子串）

```java
public class Main {
    public static String replaceSpace(String[] strs) {

        // 如果检查值不合法及就返回空串
        if (!checkStrs(strs)) {
            return "";
        }
        // 数组长度
        int len = strs.length;
        // 用于保存结果
        StringBuilder res = new StringBuilder();
        // 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)
        Arrays.sort(strs);
        int m = strs[0].length();
        int n = strs[len - 1].length();
        int num = Math.min(m, n);
        for (int i = 0; i < num; i++) {
            if (strs[0].charAt(i) == strs[len - 1].charAt(i)) {
                res.append(strs[0].charAt(i));
            } else
                break;

        }
        return res.toString();

    }

    private static boolean chechStrs(String[] strs) {
        boolean flag = false;
        if (strs != null) {
            // 遍历strs检查元素值
            for (int i = 0; i < strs.length; i++) {
                if (strs[i] != null && strs[i].length() != 0) {
                    flag = true;
                } else {
                    flag = false;
                    break;
                }
            }
        }
        return flag;
    }

    // 测试
    public static void main(String[] args) {
        String[] strs = { "customer", "car", "cat" };
        // String[] strs = { "customer", "car", null };//空串
        // String[] strs = {};//空串
        // String[] strs = null;//空串
        System.out.println(Main.replaceSpace(strs));// c
    }
}
```

#### 回文串

##### 最长回文串

> LeetCode: 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如`"Aa"`不能当做一个回文字符串。注 意:假设字符串的长度不会超过 1010。

> 回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科 地址：[https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin](https://baike.baidu.com/item/回文串/1274921?fr=aladdin)

示例 1:

```
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在hashset中，如果不在就加进去，如果在就让count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。

```java
//https://leetcode-cn.com/problems/longest-palindrome/description/
class Solution {
  public  int longestPalindrome(String s) {
    if (s.length() == 0)
      return 0;
    // 用于存放字符
    HashSet<Character> hashset = new HashSet<Character>();
    char[] chars = s.toCharArray();
    int count = 0;
    for (int i = 0; i < chars.length; i++) {
      if (!hashset.contains(chars[i])) {// 如果hashset没有该字符就保存进去
        hashset.add(chars[i]);
      } else {// 如果有,就让count++（说明找到了一个成对的字符），然后把该字符移除
        hashset.remove(chars[i]);
        count++;
      }
    }
    return hashset.isEmpty() ? count * 2 : count * 2 + 1;
  }
}
```

##### 验证回文串

> LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

```
输入: "A man, a plan, a canal: Panama"
输出: trueCopy to clipboardErrorCopied
```

示例 2:

```
输入: "race a car"
输出: false
```

```java
//https://leetcode-cn.com/problems/valid-palindrome/description/
class Solution {
  public  boolean isPalindrome(String s) {
    if (s.length() == 0)
      return true;
    int l = 0, r = s.length() - 1;
    while (l < r) {
      // 从头和尾开始向中间遍历
      if (!Character.isLetterOrDigit(s.charAt(l))) {// 字符不是字母和数字的情况
        l++;
      } else if (!Character.isLetterOrDigit(s.charAt(r))) {// 字符不是字母和数字的情况
        r--;
      } else {
        // 判断二者是否相等
        if (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))
          return false;
        l++;
        r--;
      }
    }
    return true;
  }
}
```

##### 最长回文子串

> Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。

以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。

```java
//https://leetcode-cn.com/problems/longest-palindromic-substring/description/
class Solution {
  private int index, len;

  public String longestPalindrome(String s) {
    if (s.length() < 2)
      return s;
    for (int i = 0; i < s.length() - 1; i++) {
      PalindromeHelper(s, i, i);
      PalindromeHelper(s, i, i + 1);
    }
    return s.substring(index, index + len);
  }

  public void PalindromeHelper(String s, int l, int r) {
    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
      l--;
      r++;
    }
    if (len < r - l - 1) {
      index = l + 1;
      len = r - l - 1;
    }
  }
}
```

##### 最长回文子序列

> LeetCode: 最长回文子序列 给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。 **最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，"bbbb"可以是字符串"bbbab"的子序列但不是子串。**

给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

示例 1:

```
输入:
"bbbab"
输出:
4Copy to clipboardErrorCopied
```

一个可能的最长回文子序列为 "bbbb"。

示例 2:

```
输入:
"cbbd"
输出:
2Copy to clipboardErrorCopied
```

一个可能的最长回文子序列为 "bb"。

**动态规划：** dp\[i][j] = dp\[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp\[i][j] = Math.max(dp\[i+1][j], dp\[i][j-1])

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int [][] dp = new int[len][len];
        for(int i = len - 1; i>=0; i--){
            dp[i][i] = 1;
            for(int j = i+1; j < len; j++){
                if(s.charAt(i) == s.charAt(j))
                    dp[i][j] = dp[i+1][j-1] + 2;
                else
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
            }
        }
        return dp[0][len-1];
    }
}
```

#### 括号匹配深度

> 爱奇艺 2018 秋招 Java： 一个合法的括号匹配序列有以下定义:
>
> 1. 空串""是一个合法的括号匹配序列
> 2. 如果"X"和"Y"都是合法的括号匹配序列,"XY"也是一个合法的括号匹配序列
> 3. 如果"X"是一个合法的括号匹配序列,那么"(X)"也是一个合法的括号匹配序列
> 4. 每个合法的括号序列都可以由以上规则生成。

> 例如: "","()","()()","((()))"都是合法的括号序列 对于一个合法的括号序列我们又有以下定义它的深度:
>
> 1. 空串""的深度是0
> 2. 如果字符串"X"的深度是x,字符串"Y"的深度是y,那么字符串"XY"的深度为max(x,y)
> 3. 如果"X"的深度是x,那么字符串"(X)"的深度是x+1

> 例如: "()()()"的深度是1,"((()))"的深度是3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。

```
输入描述:
输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含'('和')'。

输出描述:
输出一个正整数,即这个序列的深度。
```

```java
import java.util.Scanner;

/**
 * https://www.nowcoder.com/test/8246651/summary
 * 
 * @author Snailclimb
 * @date 2018年9月6日
 * @Description: TODO 求给定合法括号序列的深度
 */
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    int cnt = 0, max = 0, i;
    for (i = 0; i < s.length(); ++i) {
      if (s.charAt(i) == '(')
        cnt++;
      else
        cnt--;
      max = Math.max(max, cnt);
    }
    sc.close();
    System.out.println(max);
  }
}
```

#### 把字符串转换成整数

> 剑指offer: 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。

```java
//https://www.weiweiblog.cn/strtoint/
public class Main {

  public static int StrToInt(String str) {
    if (str.length() == 0)
      return 0;
    char[] chars = str.toCharArray();
    // 判断是否存在符号位
    int flag = 0;
    if (chars[0] == '+')
      flag = 1;
    else if (chars[0] == '-')
      flag = 2;
    int start = flag > 0 ? 1 : 0;
    int res = 0;// 保存结果
    for (int i = start; i < chars.length; i++) {
      if (Character.isDigit(chars[i])) {// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False
        int temp = chars[i] - '0';
        res = res * 10 + temp;
      } else {
        return 0;
      }
    }
   return flag != 2 ? res : -res;

  }

  public static void main(String[] args) {
    // TODO Auto-generated method stub
    String s = "-12312312";
    System.out.println("使用库函数转换：" + Integer.valueOf(s));
    int res = Main.StrToInt(s);
    System.out.println("使用自己写的方法转换：" + res);

  }

}
```

### 链表

#### 两数相加

>  Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。

>  你可以假设除了数字 0 之外，这两个数字都不会以零开头。

示例：

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

> 要对头结点进行操作时，考虑创建哑节点dummy，使用dummy->next表示真正的头节点。这样可以避免处理头节点为空的边界问题。

我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐 位相加的过程。

![image-20200327163119846](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327163119846.png)

**我们首先从最低有效位也就是列表 l1和 l2 的表头开始相加。注意需要考虑到进位的情况！**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
 //https://leetcode-cn.com/problems/add-two-numbers/description/
class Solution {
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummyHead;
    //carry 表示进位数
    int carry = 0;
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        //进位数
        carry = sum / 10;
        //新节点的数值为sum % 10
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return dummyHead.next;
}
}
```

#### 翻转链表

> 剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。

```java
public class ListNode {
  int val;
  ListNode next = null;

  ListNode(int val) {
    this.val = val;
  }
}
```

```java
/**
 * 
 * @author Snailclimb
 * @date 2018年9月19日
 * @Description: TODO
 */
public class Solution {

  public ListNode ReverseList(ListNode head) {

    ListNode next = null;
    ListNode pre = null;

    while (head != null) {
      // 保存要反转到头的那个节点
      next = head.next;
      // 要反转的那个节点指向已经反转的上一个节点(备注:第一次反转的时候会指向null)
      head.next = pre;
      // 上一个已经反转到头部的节点
      pre = head;
      // 一直向链表尾走
      head = next;
    }
    return pre;
  }

}
```

#### 链表中倒数第k个节点

>  剑指offer: 输入一个链表，输出该链表中倒数第k个结点。

**链表中倒数第k个节点也就是正数第(L-K+1)个节点，知道了只一点，这一题基本就没问题！**

首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第k个节点也就是正数第(L-K+1)个节点。

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/

// 时间复杂度O(n),一次遍历即可
// https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking
public class Solution {
  public ListNode FindKthToTail(ListNode head, int k) {
    // 如果链表为空或者k小于等于0
    if (head == null || k <= 0) {
      return null;
    }
    // 声明两个指向头结点的节点
    ListNode node1 = head, node2 = head;
    // 记录节点的个数
    int count = 0;
    // 记录k值，后面要使用
    int index = k;
    // p指针先跑，并且记录节点数，当node1节点跑了k-1个节点后，node2节点开始跑，
    // 当node1节点跑到最后时，node2节点所指的节点就是倒数第k个节点
    while (node1 != null) {
      node1 = node1.next;
      count++;
      if (k < 1) {
        node2 = node2.next;
      }
      k--;
    }
    // 如果节点个数小于所求的倒数第k个节点，则返回空
    if (count < index)
      return null;
    return node2;

  }
}
```

#### 删除链表的倒数第N个节点

> Leetcode:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
Copy to clipboardErrorCopied
```

**说明：**

给定的 n 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

该题在 leetcode 上有详细解答，具体可参考 Leetcode.

##### 两次遍历法

首先我们将添加一个 **哑结点** 作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。**我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
// https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/
public class Solution {
  public ListNode removeNthFromEnd(ListNode head, int n) {
    // 哑结点，哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部
    ListNode dummy = new ListNode(0);
    // 哑结点指向头结点
    dummy.next = head;
    // 保存链表长度
    int length = 0;
    ListNode len = head;
    while (len != null) {
      length++;
      len = len.next;
    }
    length = length - n;
    ListNode target = dummy;
    // 找到 L-n 位置的节点
    while (length > 0) {
      target = target.next;
      length--;
    }
    // 把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点
    target.next = target.next.next;
    return dummy.next;
  }
}
```

##### 一次遍历法

其实这种方法就和我们上面第四题找“链表中倒数第k个节点”所用的思想是一样的。**基本思路就是：** 定义两个节点 node1、node2;node1 节点先跑，node1节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点（L代表总链表长度，也就是倒数第 n+1 个节点）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
  public ListNode removeNthFromEnd(ListNode head, int n) {

    ListNode dummy = new ListNode(0);
    dummy.next = head;
    // 声明两个指向头结点的节点
    ListNode node1 = dummy, node2 = dummy;

    // node1 节点先跑，node1节点 跑到第 n 个节点的时候,node2 节点开始跑
    // 当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点，也就是倒数第 n+1（L代表总链表长度）
    while (node1 != null) {
      node1 = node1.next;
      if (n < 1 && node1 != null) {
        node2 = node2.next;
      }
      n--;
    }

    node2.next = node2.next.next;

    return dummy.next;

  }
}
```

#### 合并两个排序的链表

剑指offer:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

我们可以这样分析:

1. 假设我们有两个链表 A,B；
2. A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点；
3. A2再和B1比较，假设B1小,则，A1指向B1；
4. A2再和B2比较 就这样循环往复就行了，应该还算好理解。

考虑通过递归的方式实现！

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
//https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking
public class Solution {
public ListNode Merge(ListNode list1,ListNode list2) {
       if(list1 == null){
           return list2;
       }
       if(list2 == null){
           return list1;
       }
       if(list1.val <= list2.val){
           list1.next = Merge(list1.next, list2);
           return list1;
       }else{
           list2.next = Merge(list1, list2.next);
           return list2;
       }       
   }
}
```

### 回溯

#### N皇后

> n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

![image-20200327170328997](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200327170328997.png)

上图为 8 皇后问题的一种解法。

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

约束条件为每个棋子所在的行、列、对角线都不能有另一个棋子。

使用一维数组表示一种解法，下标（index）表示行，值（value）表示该行的Q（皇后）在哪一列。
每行只存储一个元素，然后递归到下一行，这样就不用判断行了，只需要判断列和对角线。

### [Solution1](https://snailclimb.gitee.io/javaguide/#/docs/dataStructures-algorithms/Backtracking-NQueens?id=solution1)

当result[row] = column时，即row行的棋子在column列。

对于[0, row-1]的任意一行（i 行），若 row 行的棋子和 i 行的棋子在同一列，则有result[i] == column;
若 row 行的棋子和 i 行的棋子在同一对角线，等腰直角三角形两直角边相等，即 row - i == Math.abs(result[i] - column)

布尔类型变量 isValid 的作用是剪枝，减少不必要的递归。

```java
public List<List<String>> solveNQueens(int n) {
    // 下标代表行，值代表列。如result[0] = 3 表示第1行的Q在第3列
    int[] result = new int[n];
    List<List<String>> resultList = new LinkedList<>();
    dfs(resultList, result, 0, n);
    return resultList;
}

void dfs(List<List<String>> resultList, int[] result, int row, int n) {
    // 递归终止条件
    if (row == n) {
        List<String> list = new LinkedList<>();
        for (int x = 0; x < n; ++x) {
            StringBuilder sb = new StringBuilder();
            for (int y = 0; y < n; ++y)
                sb.append(result[x] == y ? "Q" : ".");
            list.add(sb.toString());
        }
        resultList.add(list);
        return;
    }
    for (int column = 0; column < n; ++column) {
        boolean isValid = true;
        result[row] = column;
        /*
         * 逐行往下考察每一行。同列，result[i] == column
         * 同对角线，row - i == Math.abs(result[i] - column)
         */
        for (int i = row - 1; i >= 0; --i) {
            if (result[i] == column || row - i == Math.abs(result[i] - column)) {
                isValid = false;
                break;
            }
        }
        if (isValid) dfs(resultList, result, row + 1, n);
    }
}Copy to clipboardErrorCopied
```

### [Solution2](https://snailclimb.gitee.io/javaguide/#/docs/dataStructures-algorithms/Backtracking-NQueens?id=solution2)

使用LinkedList表示一种解法，下标（index）表示行，值（value）表示该行的Q（皇后）在哪一列。

解法二和解法一的不同在于，相同列以及相同对角线的校验。 将对角线抽象成【一次函数】这个简单的数学模型，根据一次函数的截距是常量这一特性进行校验。

这里，我将右上-左下对角线，简称为“\”对角线；左上-右下对角线简称为“/”对角线。

“/”对角线斜率为1，对应方程为y = x + b，其中b为截距。
对于线上任意一点，均有y - x = b，即row - i = b;
定义一个布尔类型数组anti_diag，将b作为下标，当anti_diag[b] = true时，表示相应对角线上已经放置棋子。
但row - i有可能为负数，负数不能作为数组下标，row - i 的最小值为-n（当row = 0，i = n时），可以加上n作为数组下标，即将row -i + n 作为数组下标。
row - i + n 的最大值为 2n（当row = n，i = 0时），故anti_diag的容量设置为 2n 即可。

![ANXG79.png](https://s2.ax1x.com/2019/03/26/ANXG79.png)

“\”对角线斜率为-1，对应方程为y = -x + b，其中b为截距。
对于线上任意一点，均有y + x = b，即row + i = b;
同理，定义数组main_diag，将b作为下标，当main_diag[row + i] = true时，表示相应对角线上已经放置棋子。

有了两个校验对角线的数组，再来定义一个用于校验列的数组cols，这个太简单啦，不解释。

**解法二时间复杂度为O(n!)，在校验相同列和相同对角线时，引入三个布尔类型数组进行判断。相比解法一，少了一层循环，用空间换时间。**

```java
List<List<String>> resultList = new LinkedList<>();

public List<List<String>> solveNQueens(int n) {
    boolean[] cols = new boolean[n];
    boolean[] main_diag = new boolean[2 * n];
    boolean[] anti_diag = new boolean[2 * n];
    LinkedList<Integer> result = new LinkedList<>();
    dfs(result, 0, cols, main_diag, anti_diag, n);
    return resultList;
}

void dfs(LinkedList<Integer> result, int row, boolean[] cols, boolean[] main_diag, boolean[] anti_diag, int n) {
    if (row == n) {
        List<String> list = new LinkedList<>();
        for (int x = 0; x < n; ++x) {
            StringBuilder sb = new StringBuilder();
            for (int y = 0; y < n; ++y)
                sb.append(result.get(x) == y ? "Q" : ".");
            list.add(sb.toString());
        }
        resultList.add(list);
        return;
    }
    for (int i = 0; i < n; ++i) {
        if (cols[i] || main_diag[row + i] || anti_diag[row - i + n])
            continue;
        result.add(i);
        cols[i] = true;
        main_diag[row + i] = true;
        anti_diag[row - i + n] = true;
        dfs(result, row + 1, cols, main_diag, anti_diag, n);
        result.removeLast();
        cols[i] = false;
        main_diag[row + i] = false;
        anti_diag[row - i + n] = false;
    }
}
```

### 图

判断有向无环图：

```java
题目描述，课程数numCourse，[1,0]表示上1号课的前修课程为0,输入一个二维数组，相当于多条有向边

//广度优先
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegrees = new int[numCourses];
        List<List<Integer>> adjacency = new ArrayList<>();
        Queue<Integer> queue = new LinkedList<>();
        for(int i = 0; i < numCourses; i++)
            adjacency.add(new ArrayList<>());
        // Get the indegree and adjacency of every course.
        for(int[] cp : prerequisites) {
            indegrees[cp[0]]++;
            adjacency.get(cp[1]).add(cp[0]);
        }
        // Get all the courses with the indegree of 0.
        for(int i = 0; i < numCourses; i++)
            if(indegrees[i] == 0) queue.add(i);
        // BFS TopSort.
        while(!queue.isEmpty()) {
            int pre = queue.poll();
            numCourses--;
            for(int cur : adjacency.get(pre))
                if(--indegrees[cur] == 0) queue.add(cur);
        }
        return numCourses == 0;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
// 深度优先
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> adjacency = new ArrayList<>();
        for(int i = 0; i < numCourses; i++)
            adjacency.add(new ArrayList<>());
        int[] flags = new int[numCourses];
        for(int[] cp : prerequisites)
            adjacency.get(cp[1]).add(cp[0]);
        for(int i = 0; i < numCourses; i++)
            if(!dfs(adjacency, flags, i)) return false;
        return true;
    }
    private boolean dfs(List<List<Integer>> adjacency, int[] flags, int i) {
        if(flags[i] == 1) return false;
        if(flags[i] == -1) return true;
        flags[i] = 1;
        for(Integer j : adjacency.get(i))
            if(!dfs(adjacency, flags, j)) return false;
        flags[i] = -1;
        return true;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 算法2

根据一定的条件，对一些数据进行计算，得到需要的结果。

#### 时间复杂度分析

**事后分析**
运行前后分别打印当前时间，或最后打印时间差。受硬件条件影响。
**事前分析法**
取决于： 

- 算法采用的策略和方案
- 编译产生的代码质量（无法干预）
- 问题的输入规模
- 机器执行指令的速度（无法干预）

抛开与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。

分析：

- 随着输入规模的增大，算法的常数操作可以忽略不计；
- 随着输入规模的增大，最高次项的常数可以忽略不计；
- 最高次项的指数大的，随着N的增长，结果也会变得增长特别快；
- 算法中函数中N的最高次幂越小，算法效率越高；
  综上：

1. 算法函数中的常数可以忽略；
2. 算法的函数中最高次幂的常数因子可以忽略；
3. 算法函数中最高次幂越小，算法效率越高。

#### 大O记法

程序次数=执行时间。
用大写O体现算法时间复杂度的记法：

- 用常数1取代运行时间中的所有加法常数；
- 在修改后的运行次数中，只保留最高阶项；
- 如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数。

#### 常见的大O阶

1. 线性阶O(n)
2. 平方阶O(n^2)
3. 立方阶O(n^3)
4. 对数阶O(logn)，底数省略，对于不同的底数，区别也不大
5. 常数阶O(1)
6. 线性对数O(nlogn)

#### 最坏情况

一种基本的保障，即使在最坏情况下，也能正常提供服务。

#### 空间复杂度分析

##### Java中常见内存占用

**基本数据类型内存占用**

| 数据类型 | 内存占用 |
| -------- | -------- |
| byte     | 1B       |
| short    | 2B       |
| int      | 4B       |
| long     | 8B       |
| float    | 4B       |
| double   | 8B       |
| boolean  | 1B       |
| char     | 2B       |

**计算机访问内存的方式都是一次一个字节；**

**一个引用（机器地址）需要8个字节（64位机器，4/32）表示**

**创建一个对象，除对象内部数据，还有对象头需要16个字节（8字节的Mark Word，8字节的Klazz Word，64位机器，8/32位），保存增强对象的一些信息。**

**一般内存的使用如果不够8字节，会自动填充为8字节。**如只含int的对象，4字节，对象头16字节，需要填充到3*8=24字节，即填充4字节。

**Java数组在对象头保存数组长度，4字节加上填充，需要16+4+4=24字节**

#### 简单排序算法

##### 冒泡排序

冒泡排序（Bubble Sort）,稳定，O(n^2)
原理：

- 比较相邻的元素，如果前一个比后一个大，就交换
- 对每一对相邻的元素做同样的工作，从开始第一对元素到结尾的最后一对元素，最终最后位置的元素就是最大值。

##### 选择排序

不稳定，O(n^2)

- 每次遍历过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引的值为最小值，最后可以找到最小值所在的索引
- 交换第一个索引处和最小值所在的索引处的值

##### 插入排序

稳定，O(n^2)

#### 高级排序算法

##### 希尔排序

插入排序的一种，“缩小增量排序”。O(nlogn)

```java
h = xxx; //增量 可以直接取N/2
while (h >= 1) {
	for (inti = h; i < arr.length; i++) {
		for (int j = i; j >= h; j-= h) {
			if(a[j-h] > a[j]) {
				swap;
			} else {
				break;
			}
		}
	}
	h = h / 2;
}
```

##### 归并排序

**递归**，在方法内部调用方法本身，称为递归。把大的复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程中所需要的多次重复计算，大大地减少了程序的代码量。

**注意**：不能无限制地调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存中开辟新的内存空间，递归层次过深，很容易造成栈内存溢出。6

归并是采用分治法的典型。
分：尽量均分，直到不能分
归并：进行排序

```java

public static void sort(int[] nums, int lo, int hi) {
	
}

public static void merge(int[] nums, int lo, int mid, int hi) {

}
```


### 寿司代码

#### 生产者消费者问题

生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小**缓冲区**的两个线程——生产者、消费者，在实际运行时会发生的问题。

生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。

与此同时，消费者也在缓冲区消费这些数据。

**问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会再缓冲区空的时候消费数据。**主要是数据在多线程间的共享，此外通过缓冲区可以环节生产者和消费者的性能差。

##### 实现方式

- 生产者持续生产，直到缓冲区满，满时阻塞；缓冲区不满时，继续生产；
- 消费者持续消费，直到缓冲区空，空时阻塞；缓冲区不空后，继续消费；
- 生产者和消费者可以有多个。

在Java语言中，能达到上述要求的：

- wait()/notify()方式
- await()/singal()方式
- BlockingQueue阻塞队列方式
- PipedInputStream/PipeOutPutStream方式

##### wait()/notify()方式实现

**生产者**

```
public class Producer implements Runnable {
    private volatile boolean isRunning = true;
    private final Vector sharedQueue; // 内存缓冲区
    private final int SIZE; // 缓冲区大小
    private static AtomicInteger count = new AtomicInteger(); // 总数 院子操作
    private static final int SLEEPTIME = 1000;

    public Producer(Vector sharedQueue, int SIZE) {
        this.sharedQueue = sharedQueue;
        this.SIZE = SIZE;
    }

    @Override
    public void run() {
        int data;
        Random r = new Random();
        System.out.println("start producer id = " + Thread.currentThread().getId());
        try {
            while (isRunning) {
                // 模拟随机延迟
                Thread.sleep(r.nextInt(SLEEPTIME));

                // 队列满时阻塞等待
                while (sharedQueue.size() == SIZE) {
                    synchronized (sharedQueue) {
                        System.out.println("Queue is full, producer " + Thread.currentThread().getId()
                                + "is waiting, size:" + sharedQueue.size());
                        sharedQueue.wait();
                    }
                }

                synchronized (sharedQueue) {
                    data = count.incrementAndGet();
                    sharedQueue.add(data);
                    System.out.println("producer create data:" + data + ", size:" + sharedQueue.size());
                    sharedQueue.notifyAll();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }

    public void stop() {
        isRunning = false;
    }
}
```

重点：

- 创造数据：采用atomicInteger类来创造数据，保证原子操作，使用incrementAndGet()保证线程安全，及计数效果。注意要保证该类在内存中只有一份，用static修饰。
- 内存缓冲区：简单使用Vector类，线程安全的，使用final保证内存缓冲区唯一，用SIZE手动判断缓冲区是否满；缓冲区和SIZE构造传入；
- 模拟延迟：模拟网络延迟，定义1000ms的延迟范围，使用Random随机选值；
- 停止方法：isRunning标志位，使用volatile修饰，保证该标志位的可见性；
- 错误处理：捕获到错误时，应该使用Thread类中的interrupt()方法来种植当前的进程；
- 消息提示：控制台输出～

**消费者**

```
package producerandConsumer.waitnotify;

import java.util.Random;
import java.util.Vector;

/**
 * @program Interview
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/04/18 23:27
 */
public class Consumer implements Runnable {
    private final Vector sharedQueue;
    private final int SIZE;
    private static final int SLEEPTIME = 1000;

    public Consumer(Vector sharedQueue, int SIZE) {
        this.sharedQueue = sharedQueue;
        this.SIZE = SIZE;
    }

    @Override
    public void run() {
        Random random = new Random();
        System.out.println("start consumer id = " + Thread.currentThread().getId());
        try {
            while (true) {
                Thread.sleep(random.nextInt(SLEEPTIME));

                while (sharedQueue.isEmpty()) {
                    synchronized (sharedQueue) {
                        System.out.println("Queue is empty, consumer " + Thread.currentThread().getId()
                                + "is waiting, size: " + sharedQueue.size());
                        sharedQueue.wait();
                    }
                }

                synchronized (sharedQueue) {
                    System.out.println("consumer consume data:" + sharedQueue.remove(0)
                            + ", curr size = " + sharedQueue.size());
                    sharedQueue.notifyAll();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }
}

```

**主线程**

```
package producerandConsumer.waitnotify;

import java.util.Vector;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @program Interview
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/04/18 23:32
 */
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Vector sharedQueue = new Vector();
        int size = 4;

        ExecutorService service = Executors.newCachedThreadPool();
        Producer producer1 = new Producer(sharedQueue, size);
        Producer producer2 = new Producer(sharedQueue, size);
        Producer producer3 = new Producer(sharedQueue, size);
        Consumer consumer1 = new Consumer(sharedQueue, size);
        Consumer consumer2 = new Consumer(sharedQueue, size);
        Consumer consumer3 = new Consumer(sharedQueue, size);
        service.execute(consumer1);
        service.execute(consumer2);
        service.execute(consumer3);
        service.execute(producer1);
        service.execute(producer2);
        service.execute(producer3);

        Thread.sleep(2 * 1000);
        producer1.stop();
        producer2.stop();
        producer3.stop();

        Thread.sleep(7000);
        service.shutdown();
    }
}

```

##### BlockingQueue阻塞队列实现

简单一些，不需要手动通知其他线程了，生产者直接往队列中放数据直到队列满，消费者直接从对垒中获取数据直到队列空，BlockingQueue会自动完成阻塞操作。

**生产者**

```
package producerandConsumer.blockingqueue;

import java.beans.Transient;
import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @program Interview
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/04/18 23:41
 */
public class Producer implements Runnable {
    private volatile boolean isRunning = true;
    private BlockingQueue<Integer> queue;
    private static AtomicInteger count = new AtomicInteger();
    private static final int SLEEPTIME = 1000;

    public Producer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        int data;
        Random r = new Random();

        System.out.println("start producer id = " + Thread.currentThread().getId());
        try {
            while (isRunning) {
                Thread.sleep(r.nextInt(SLEEPTIME));

                data = count.incrementAndGet();
                System.out.println("producer " + Thread.currentThread().getId() + " create data: "
                        + data + ", currsize=" + queue.size());
                if (!queue.offer(data, 2, TimeUnit.SECONDS)) {
                    System.err.println("failed to put data");
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }

    public void stop() {
        isRunning = false;
    }
}
```

**消费者**

```
package producerandConsumer.blockingqueue;

import java.util.Random;
import java.util.concurrent.BlockingQueue;

/**
 * @program Interview
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/04/18 23:46
 */
public class Consumer implements Runnable {
    private BlockingQueue queue;
    private static final int SLEEPTIME = 1000;

    public Consumer(BlockingQueue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        int data;
        Random r = new Random();

        System.out.println("start consumer id = " + Thread.currentThread().getId());
        try {
            while (true) {
                Thread.sleep(r.nextInt(SLEEPTIME));

                if (!queue.isEmpty()) {
                    data = (int)queue.take();
                    System.out.println("consumer " + Thread.currentThread().getId()
                            + " consume " + data + ", size = " + queue.size());
                } else {
                    System.out.println("Queue is empty, consumer " + Thread.currentThread().getId()
                            + "is waiting, size = " + queue.size());
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }
}

```

**主线程**

```
package producerandConsumer.blockingqueue;

import javax.swing.table.TableRowSorter;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * @program Interview
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/04/18 23:53
 */
public class Main {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        ExecutorService executorService = Executors.newCachedThreadPool();
        Producer producer1 = new Producer(queue);
        Producer producer2 = new Producer(queue);
        Producer producer3 = new Producer(queue);
        Consumer consumer1 = new Consumer(queue);
        Consumer consumer2 = new Consumer(queue);
        Consumer consumer3 = new Consumer(queue);
        executorService.execute(producer1);
        executorService.execute(producer2);
        executorService.execute(producer3);
        executorService.execute(consumer1);
        executorService.execute(consumer2);
        executorService.execute(consumer3);

        Thread.sleep(10 * 1000);
        producer1.stop();
        producer2.stop();
        producer3.stop();

        Thread.sleep(3000);
        executorService.shutdown();

    }
}
```

#### 排序算法

##### 冒泡排序

从第一个数开始，直到数组倒数第二个数，每一轮都去比较数组中剩下的数，如果后面的数据更小，则两束交换。

**基础版本**

```
package sort;

/**
 * @program Interview
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/04/19 00:00
 */
public class Bubble {
    public static void bubbleSort(int[] nums) {
        if (null == nums || nums.length <= 1) {
            return; 
        }

        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = 0; j < nums.length - i - 1; j++) {
                if (nums[j] > nums[j + 1]) {
                    int tmp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = tmp;
                }
            }
        }
    }
}

```

**优化**
加入判断，如果某一趟没有交换，则有序。

```
public static void bubbleSortUpdate(int[] nums) {
        if (null == nums || nums.length <= 1) {
            return;
        }

        for (int i = 0; i < nums.length - 1; i++) {
            boolean flag = false;
            for (int j = 0; j < nums.length - i - 1; j++) {
                if (nums[j] > nums[j + 1]) {
                    flag = true;
                    int tmp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = tmp;
                }
            }
            if (!flag) {
                break;
            }
        }
    }
    
```

**进一步优化**
记录最后发生交换的元素的位置，也就是排序的尾边界了。

```
public static void bubbleSortUpdate2(int[] nums) {
        if (null == nums || nums.length <= 1) {
            return;
        }

        int edge = nums.length - 1;
        int maxedge = -1;
        for (int i = 0; i < nums.length - 1; i++) {
            boolean flag = false;
            for (int j = 0; j < edge; j++) {
                if (nums[j] > nums[j + 1]) {
                    flag = true;
                    maxedge = j;
                    int tmp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = tmp;
                }
            }
            if (edge > maxedge) {
                edge = maxedge;
            }
            if (!flag) {
                break;
            }
        }
    }
    
```

最优的冒泡。

##### 快速排序

**基本快排**

```java
package sort;

import javax.swing.*;
import java.util.HashMap;

/**
 * @program Interview
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/04/19 00:22
 */
public class Quick {
    public static void main(String[] args) {
        int[] nums = new int[]{5, 8, 7, 10, 1, -3, 99};
        quickSort(nums);
        for (int i : nums) {
            System.out.println(i);
        }
    }

    public static void quickSort(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int left, int right) {
        if (left < right) {
            int pivot = partition(nums, left, right);
            quickSort(nums, left, pivot - 1);
            quickSort(nums, pivot + 1, right);
        }
    }

    private static int partition(int[] nums, int left, int right) {
        int pivot = nums[left];
        while (left < right) {
            while (left < right && nums[right] >= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left < right && nums[left] <= pivot) {
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        return left;
    }
}

```

**算法优化**

当输入数组基本有序时，退化为冒泡排序。O(n^2)

可以取枢纽值时，在nums[left]\nums[right]\nums[(left+right)/2]中间选一个中值作为枢值记录，可以大大提高快速排序在最坏情况下的性能。

另外，如果划分数组长度失衡，需要的栈深度由log(n)上升到O(n)，因此我们可以在每次划分后比较两端的长度，并先对短的序列进行排序（目的是先结束这些栈以释放空间）

具体优化思路：

- 三数取中作为枢轴记录
- 当待排序序列的长度分割到一定大小时，采用插入排序
- 在一次分割结束后，可以把pivot相等的元素聚在一起，继续下次分割时，不用再对与pivot相等的元素分割，三路快排？
- 优化递归操作，优化空间复杂度。

#### 二叉树相关算法

##### 前序遍历递归

```
class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        public TreeNode(int val) {
            this.val = val;
        }
    }

    public static void preOrderTraverse(TreeNode root) {
        if (root != null) {
            System.out.println(root.val);
            preOrderTraverse(root.left);
            preOrderTraverse(root.right);
        }
    }
```


##### 中序遍历递归

```
public static void inOrderTraverse(TreeNode root) {
        if (root != null) {
            inOrderTraverse(root.left);
            System.out.println(root.val);
            inOrderTraverse(root.right);
        }
    }
```


##### 后序遍历递归

```
public static void postOrderTraverse(TreeNode root) {
        if (root != null) {
            postOrderTraverse(root.left);
            preOrderTraverse(root.right);
            System.out.println(root.val);
        }
    }

```

##### 层序遍历

增加一个队列即可。

```
public static void levelTraverse(TreeNode root) {
        if (root == null) {
            return;
        }

        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.println(node.val);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
```

##### 前序遍历非递归

```
public static void preOrderTraverse2(TreeNode root) {
        if (root == null) {
            return;
        }
        LinkedList<TreeNode> stack = new LinkedList<>();
        TreeNode pNode = root;
        while (pNode != null || !stack.isEmpty()) {
            if (pNode != null) {
                System.out.println(pNode.val);
                stack.push(pNode);
                pNode = pNode.left;
            } else {
                pNode = stack.pop();
                pNode = pNode.right;
            }
        }
    }

```

##### 中序遍历非递归

```
public static List<Integer> inOrderTarverse2(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        LinkedList<TreeNode> stack = new LinkedList<>();

        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.addFirst(root);
                root = root.left;
            }
            root = stack.removeFirst();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
```

##### 后序遍历非递归

```
public static List<Integer> postOrderTraverse2(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        LinkedList<TreeNode> stack = new LinkedList<>();
        TreeNode pre = null;
        while (!stack.isEmpty() || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.peek();

            // 判断如果右子树不空且不为，不为pre是为了让已经出战的右节点，不再被遍历
            if (root.right != null && root.right != pre) {
                root = root.right;
            } else {
                root = stack.pop();
                res.add(root.val);
                pre = root;
                root = null;
            }
        }
        return res;
    }
```

#### 重要算法

##### 反转链表

**使用一个Node不断链接**

```
public ListNode reverseList(ListNode head) {
        if (null == head || null == head.next) {
            return head;
        }
        ListNode pre = null;
        while (null != head) {
            ListNode tmp = head;
            head = head.next;
            tmp.next = pre;
            pre = tmp;
        }
        return pre;
    }
```

**反转元素值，然后重新复制给Node

```
public ListNode reverseList1(ListNode head) {
        if (null == head || null == head.next) {
            return head;
        }
        List<Integer> list = new LinkedList<>();
        ListNode tmp = head;
        while (null != tmp) {
            list.add(tmp.val);
            tmp = tmp.next;
        }

        Collections.reverse(list);
        tmp = head;
        while (null != tmp) {
            tmp.val = list.remove(0);
            tmp = tmp.next;
        }
        return head;
    }
```

##### 合并两个有序链表


```
public class MergeList {
    public ReverseList.ListNode mergeTwoLists(ReverseList.ListNode l1, ReverseList.ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        ReverseList.ListNode head = null;
        if (l1.val < l2.val) {
            head = l1;
            head.next = mergeTwoLists(l1.next, l2);
        } else {
            head = l2;
            head.next = mergeTwoLists(l1, l2.next);
        }
        return head;
    }
}
```

##### 两个链表的第一个公共节点

注意：正确性判断、判断链表是否自己成环、注释、自己写测试用例

```
public class FindFirstCommonNode {

    public ReverseList.ListNode find(ReverseList.ListNode pHead1, ReverseList.ListNode pHead2) {
        if (null == pHead1 || null == pHead2) {
            return null;
        }
        Set<ReverseList.ListNode> set = new HashSet<>();
        while (pHead1 != null) {
            set.add(pHead1);
            pHead1 = pHead1.next;
            if (set.contains(pHead1)) {
                break;
            }
        }

        Set<ReverseList.ListNode> set2 = new HashSet<>();
        while (pHead2 != null) {
            if (set.contains(pHead2)) {
                return pHead2;
            }

            set2.add(pHead2);
            pHead2 = pHead2.next;
            if (set2.contains(pHead2)) {
                break;
            }
        }
        return null;
    }
}
```

##### 二分

**普通实现**

```
public class BinarySearch {
    public static int binarySearch(int[] arr, int target) {
        int mid;
        int start = 0;
        int end = arr.length - 1;
        while (start <= end) {
            mid = start + (end - start) / 2;
            if (target < arr[mid]) {
                end = mid - 1;
            } else if (target > arr[mid]) {
                start = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}
```

**递归实现**

```
public static int binSearch(int srcArray[], int start, int end, int key) {
	int mid = (end - start) / 2 + start;
	if (srcArray[mid] == key) {
		return mid;
	}
	if (start >= end) {
		return -1;
	} else if (key > srcArray[mid]) {
		return binSearch(srcArray, mid + 1, end, key);
	} else if (key < srcArray[mid]) {
		return binSearch(srcArray, start, mid - 1, key);
	}
	return -1;
}
```

##### 斐波那契数列

```
public int Fibonacci(int n) {
	// 正确性判断
	if (0 == n || 1 == n) {
		return n;
	}

	int nums1 = 0, nums2 = 1;
	int res = 0;
	for (int i = 2; i <= n; i++) {
		res = nums1 + nums2;
		nums1 = nums2;
		nums2 = res;
	}

	return res;
}

```

