# 操作系统

## 知识点梳理

### 操作系统概览

操作系统的演进：![image-20200515003148512](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200515003148512.png)

多道程序设计：

- 早期批处理系统只能一次处理一个任务
- **多道程序设计**使得批处理系统一次可以处理多个任务
- 即：在计算机内存中同时存放多个程序，在管理程序之下相互穿插执行

操作系统五大功能：

- 进程管理
- 存储管理
- 文件管理
- 设备管理
- 作业管理

#### What

- 操作系统是管理计算机硬件和软件资源的计算机程序
- 管理配置内存、决定资源供需顺序、控制输入输出设备等
- 提供了让用户和系统交互的操作界面

#### Why

- 我们不能直接操作计算机软件
- 设备种类繁多复杂，需要统一界面
- 操作系统的简易性使得更多人能够使用计算机

#### 操作系统的基本功能

1. 操作系统统一管理计算机资源：

- 处理器资源
- 存储器资源
- I/O设备资源
- 文件资源

2. 用户无需面向硬件接口编程，实现了对计算机资源的抽象
   1. 例如，IO设备管理软件，提供读写接口
   2. 例如，文件管理软件，提供操作文件的接口

![image-20200515135704389](/Users/zhaojiangdong/Documents/Postgraduate/认知自组网/image-20200515135704389.png)

3. 提供了用户与计算机的接口

   1. 图形窗口形式
   2. 命令形式
   3. 系统调用形式

   ![image-20200515140125698](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200515140125698.png)

#### 操作系统相关概念

- 并发性：前提
  - 并行：两个或多个事件在同一个时刻发生
  - 并发：两个或多个事件在同一个事件间隔发生（宏观上同时运行）
- 共享性
  - 表现为操作系统中的资源可供多个并发的程序共同使用，称之为资源共享
  - 互斥共享：当资源被程序A占用时，其他想使用的话只能等待，只有A使用完后，其他进程才可以使用该资源
  - 同时访问：某种资源在一段时间内并发地被多个程序使用，“宏观”的同时
- 虚拟性
  - 表现为把一个物理实体转变为若干个逻辑实体
  - 时分复用技术和空分复用技术
  - 时分：时间上复用，不同程序并发使用，例如多道程序分时使用计算机的硬件资源，提高资源的利用率
    - 虚拟处理器技术：借助多道程序设计，为每个程序建立进程，多个程序分时复用处理器
    - 虚拟设备技术：物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问
  - 空分：主要用来实现虚拟磁盘、虚拟内存，提高资源利用率，提升编程效率
    - 虚拟磁盘：物理磁盘虚拟为多个逻辑磁盘，例如C、D、E逻辑盘，使用起来安全方便
    - 虚拟内存：在逻辑上扩大程序的存储容量，使用比时机内存更大的容量，提升编程效率
- 异步性：在多道环境下，允许多个进程并发执行，进程在使用资源时可能需要等待或放弃，进程的执行也是走走停停地推进的，以不可预知的速度向前推进

### 进程管理

#### 进程实体

##### 为什么需要进程

没有OS之前，全部资源属于当前运行的程序。

配置OS之后，引入多道程序设计的概念，合理的隔离资源、运行环境，提高资源利用率

- 进程时系统进行资源分配和调度的基本单位
- 进程作为程序独立运行的载体保障程序正常运行
- 进程似的操作系统资源利用率大幅提升

##### 进程实体

主存中的进程形态：进程控制块

![image-20200518231103786](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200518231103786.png)

- 标识符：唯一标记一个进程，区别于其他进程
- 状态：标记进程的进程状态：运行态、阻塞态。。
- 优先级：
- 程序计数器：进程即将执行的下一条指令的地址
- 内存指针：程序代码、进程数据相关的指针
- 上下文数据：进程执行时，处理器存储的数据
- IO状态信息：被进程IO操作所占用的文件列表
- 记账信息：存储进程使用处理器时间、时钟数总和等

![image-20200518231416231](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200518231416231.png)

进程控制块（PCB）：

- 用于描述和控制进程运行的通用数据结构
- 记录进程当前状态和控制进程运行的全部信息
- PCB使得进程是能够独立运行的基本单位
- PCB是操作系统进程调度经常会被读取的信息
- PCB是常驻内存的，存放在系统专门开辟的PCB区域内

##### 进程与线程

- 进程（Process）：
- 线程（Thread）：一个进程可以又多个线程
- 进程是一个资源的管理者，线程是任务的执行者。

- 进程是资源分配的最小单位，线程是程序执行的最小单位。
- 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
- 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
- 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

线程：

- 操作系统进程进行运行调度的最小单位
- 包含在进程之中，是进程中实际运行工作的单位
- 一个进程可以并发多个线程，每个线程执行不同的任务
- 线程共享进程的资源
  - 进程代码块
  - 进程的公有数据
  - 进程打开的文件描述符
  - 检查的当前目录
  - 信号处理器/信号处理函数
  - 进程Id与进程组Id
- 线程独占的资源：
  - 线程ID
  - 一组寄存器
  - 线程自身的栈
  - 错误返回码
  - 信号掩码、信号屏蔽字

![image-20200518231830874](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200518231830874.png)

#### 五状态模型-进程

- 就绪状态：当进程被分配到除了CPU之外所有必要的资源后，只要获得CPU使用权，就可以立即运行，只差CPU资源的状态
  - 在一个系统中多个处于就绪状态的进程通常排成一个就绪队列
- 执行状态：进程获得CPU，其程序正在执行，称为执行状态
  - 在单处理机中，在某个时刻只能有一个进程处于执行状态
- 阻塞状态：进程因为某种原因，放弃CPU的状态，例如其他设备未就绪而无法继续执行

- 创建状态：创建进程时拥有PCB，但其他资源尚未就绪的状态称为创建状态
  - 分配PCB
  - 插入就绪队列
- 终止状态：进程结束由系统清理或归还CPU时的状态
  - 系统清理
  - 归还PCB

![image-20200518232806060](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200518232806060.png)

#### Java线程状态

\1. **新建(NEW)**：新创建了一个线程对象。

\2. **可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

\3. **运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。
\4. **阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

> (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

\5. **死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

![image-20200626005020164](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200626005020164.png)

#### 进程同步

##### 为什么需要进程同步

生产者消费者问题。

哲学家就餐问题。

![image-20200518233839939](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200518233839939.png)

![image-20200518233933312](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200518233933312.png)

对竞争资源在多进程之间进行使用次序的协调。

##### 进程间同步原则

临界资源：共享资源，但又无法同时被多个进程共同访问的共享资源，当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。

- 空闲让进：资源无占用，允许使用
- 忙则等待：资源有占用，请求进程等待
- 有限等待：保证有限等待时间能够使用资源
- 让权等待：等待时，进程需要让出CPU

##### 进程同步

- 消息队列
- 共享内存
- 信号量

##### 线程同步

- 互斥量
- 读写锁（多读少写)
- 自旋锁
- 条件变量

#### Linux的进程管理

##### 进程的类型

- 前台进程：具有终端，可以与用户交互的进程

- 后台进程：相对的，没有占用终端的就是后台进程，基本上不与用户交互，优先级比前台进程低，以“&”结尾，可以放入后台执行

- 守护进程，特殊的后台进程：daemo，大都在系统引导时启动，一直运行到系统关闭，
  - 进程名字以d结尾的一般都是守护进程

##### 进程的标记

- 进程ID：唯一标识，非负整数，最大值由操作系统限定
  - ID为0的进程为idle进程，是系统创建的第一个进程
  - ID为1的进程为init进程，是0号进程的子进程，完成系统初始化
  - init进程是所有用户进程的祖先进程
- 进程的状态标记
  - ![image-20200518235614951](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200518235614951.png)

![image-20200518235403675](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200518235403675.png)

父子进程关系。通过pstree命令查看父子关系。

##### 相关命令

- ps命令：查看进程，-aux详细进程信息，-u root查看root用户进程，-aux | grep 'xx'查看xx相关的进程，ps -ef --foreast查看进程树。
- top命令：
- kill命令：kill -9 pid，9信号可以无条件终止进程

### 作业管理

#### 进程调度

##### 概述

进程调度指计算机通过决策决定哪个就绪进程可以获得CPU使用权。

- 保留旧进程的运行信息，请出旧进程（收拾包袱）
- 选择新进程，准备运行环境并分配CPU（新进驻）

三个机制：

- 就绪队列的排队机制：将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程
- 选择运行进程的委派机制：从就绪队列以一定的策略选择就绪进程
- 新老进程的上下文切换机制：保存当前进程的上下文信息，装入被委派执行进程的运行上下文

抢占与非抢占：

- 非抢占：处理器一旦分配给某个进程，就让该进程一直使用下去，调度程序不以任何原因抢占正在被使用的处理器，直到进程完成工作或因为IO阻塞才会让出处理器
- 抢占式调度：允许调度程序以一定的策略暂停当前运行的进程，需要保存好旧进程的上下文信息

![image-20200519001133021](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200519001133021.png)

##### 算法

- 先来先服务算法：先来先服务，队列
- 短进程优先调度算法：优先选择就绪队列中估计运行时间最短的进程，不利于长作业的执行
- 高优先权优先调度算法：进程附带优先权，调度程序优先选择权重高的进程，使得紧迫的任务可以优先处理（前台进程优先级高于后台进程优先级）
- 时间片轮转调度算法：先来先服务的顺序排列，每次从队列头去除待执行进程，分配一个时间片执行，相对公平，但不保证及时响应用户

#### 死锁

两个或两个以上进程，在执行过程中由于竞争资源或彼此通信而造成一种阻塞状态，若无外力作用，它们都将无法推进下去。系统产生了死锁，系统处于死锁状态，这些永远相互等待的进程称为死锁进程。

##### 死锁的产生原因

- 竞争资源：共享资源不足
- 进程调度顺序不当

##### 死锁产生的四个必要条件

- 互斥条件：进程对资源的使用是排他性的使用，其他进程只能等待释放
- 请求保持条件：进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞的进程又不释放自已保持的资源
- 不可剥夺条件：进程获得的资源在未使用完成前不能被剥夺，只能自己去释放
- 环路等待条件：进程-资源环形等待链条

##### 预防死锁的方法

- 破坏四个必要条件之一
  - 破坏请求保持条件：规定进程运行之前，一次性申请所有需要的资源
  - 破坏不可剥夺条件：一个进程请求新的资源得不到满足时，必须释放已占有资源，可剥夺
  - 破坏环路等待条件：可用资源线性排序，申请必须按照序号递增申请，不再形成环路
  - 破坏互斥条件：受限于资源类型

##### 避免死锁的方法

银行家算法

- 客户申请的贷款是有限的，每次申请需要声明最大资金量
- 银行家在能够满足贷款时，都应该给用户贷款
- 客户在使用贷款后，能够及时归还贷款
- ![image-20200519002725118](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200519002725118.png)

##### 其他问题

活锁：进程无法获得需要的下一个锁时，释放当前已经获得的锁，然后等待一段时间再次尝试。如果另一个进程在相同的时刻做了相同的操作，那么两个人就像哈在一条路上相遇并同时给对方让路一下，相同的步调导致双方都无法前进。

```java
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program untitled
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/05/31 12:58
 */

class ShareData implements Runnable {
    private Lock lockA;
    private Lock lockB;

    public ShareData(Lock lockA, Lock lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        while (true) {
            lockA.lock();
            System.out.println(Thread.currentThread().getName() + " get lock " + lockA);
            try {
                Thread.sleep(100);
                boolean b = lockB.tryLock();
                if (b) {
                    System.out.println("work finish");
                }
                System.out.println(Thread.currentThread().getName() + " get lock failed " + lockB + ", retry");
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lockA.unlock();
            }
        }
    }
}

public class AliveLockDemo {
    public static void main(String[] args) {
        Lock lockA = new ReentrantLock();
        Lock lockB = new ReentrantLock();
        new Thread(new ShareData(lockA, lockB)).start();
        new Thread(new ShareData(lockB, lockA)).start();
    }
}

```



### 存储管理

- 确保计算机有足够的内存处理数据
- 确保程序可以从可用内存中获取一部分内存使用
- 确保程序可以归还使用后的内存以供其他程序使用

#### 内存分配与回收

##### 内存分配过程

- 单一连续分配：最简单，只能在单用户、单进程的操作系统使用。过时
- 固定分区分配方法：支持多道程序的最简单存储分配方式
  - 内存空间被划分为若干个固定大小的区域
  - 每个分区只提供给某一个程序使用，互不干扰
- 动态分区分配：根据进程实际需要，动态分配内存空间，现在常用

##### 动态分区分配

动态分区空闲表数据结构：

![image-20200519003434799](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200519003434799.png)

动态分区空闲链数据结构：

![image-20200519003544556](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200519003544556.png)

动态分区分配算法：

- 首次适应算法（FF算法）--》改进（循环适应算法）
  - 分配内存时从开始顺序查找适合内存区（主要使用空闲链）
  - 若没有合适的空闲区，则该次分配失败，只要第一次找到满足的就分配，导致头部地址空间不断被划分
- 最佳适应算法（BF算法）
  - 要求空闲区链表按照容量大小排序，找到最佳最适合的空闲区
  - 避免大材小用
- 快速适应算法（QF算法）
  - 要求有多个空闲区链表
  - 每个空闲区链表存储一种容量的空闲区![image-20200519004020990](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200519004020990.png)

##### 内存回收过程

四种情况：

![image-20200519004111558](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200519004111558.png)

1. 不需要新建空闲链表节点，只需要把空闲区1的容量增加回收区的大小
2. 将回收区和空闲区合并，新的空闲区使用回收区的地址作为新的节点的地址
3. 将空闲区1、空闲区2、回收区合并，新的空闲区使用空闲区1的地址
4. 为回收区创建新的空闲节点，插入相应的空闲区链表中

#### 段页式存储管理

##### 页式存储

页面：逻辑空间的定义。大小应该适中，过大难以分配，过小内存碎片过多，大小通常是524B～8K

- 将进程的逻辑空间分成若干大小的页面
- 相应的把物理内存空间分成与页面大小一致的物理快
- 以页面为单位吧进程空间装进物理内存中分散的物理块

页表：记录进程逻辑空间与物理空间的映射

页地址：页号、页内偏移

##### 段式存储

- 将进程逻辑空间分成若干段（不等分）
- 段的长度有连续逻辑的长度决定
- 数据段，程序段等

段表：

段地址：段号、段内偏移

相同点：

- 都离散地管理了进程的逻辑空间

不同点：

- 页是物理单位，段是逻辑单位
- 分页是为了合理利用空间，分段是为了满足用户需求
- 页大小由硬件固定，段长度可以动态变化
- 页表信息是一维的，段表信息是二维的

##### 段页式

- 分页可以提高内存利用率
- 分段可以更好满足用户需求
- 先将逻辑空间按段式管理分成若干段
- 再把段内空间按页式管理分成若干页

段页地址：段号、段内页号、页内地址

#### 虚拟内存

##### 概述

- 有些进程实际需要的内存很大，超过物理内存容量
- 多道程序设计，使得每个进程可用的物理内存更加稀缺
- 也不可能无限增加物理内存
- 虚拟内存时操作系统内存管理的关键技术，使得多道程序以及大程序的运行成为现实
- 把程序使用内存划分，将暂时不使用的内存放到辅存

##### 程序局部性原理

CPU在访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。

- 程序运行时，无需全部装入内存，装载部分即可。
- 如果访问页不在内存，则发出缺页中断，发起页面置换
- 从用户层面看，程序拥有很大的空间，即是虚拟内存
- 虚拟内存实际是对物理内存的补充，速度接近于内存成本接近于辅存

##### 虚拟内存置换算法

- 先进先出算法FIFO
- 最不经常使用算法LFU
- 最近最少使用算法LRU

注：

- 替换策略发生在Cache-主存、主存-辅存层次
- Cache-主存的替换策略主要是为了解决速度问题
- 主存-辅存的替换主要是为了解决容量问题

#### Linux的存储管理

##### Buddy内存管理算法

- 经典的内存管理算法
- 算法基于计算机处理二进制的优势具有极高的效率
- 算法主要是为了解决内存外碎片的问题

努力让内存分配与响铃内存合并能快速进行，分配原则：

- 内存向上取整为2的幂次方大小70k->128k，129k->256k
- 创建一系列空闲块列表，每一种都是2的幂
- 为100k分配，->128k，查有没有128k的，再查256k的，再查512的。。。，如果查到有1M的，拆下512k放在512k的空闲列表，其余的分配出去，继续拆，拆到最小满足128

回收内存：

- 判断刚才分配的内存伙伴在空闲链表上吗
- 在，移除伙伴，合并为256空闲内存，在吗
- 在，移除伙伴，合并为512
- 在，移除伙伴，合并为1M
- 插入1M空闲链表，回收完成

页内碎片：已经被分配的内存空间，大于请求所需内存空间，不能利用的部分就是内碎片

页外碎片：指还没有被分配出去，但是由于大小而无法分配给申请内存空间的新进程的内存空闲块。

##### Linux交换空间

实际上是磁盘的一个分区。

Linux物理内存满时，会把一些内存交换至Swap空间，Swap空间是初始化系统时配置的。

与虚拟内存的区别：

- Swap空间是操作系统概念，虚拟内存是进程概念
- Swap空间解决系统物理内存不足问题，虚拟内存解决进程物理内存不足问题

### 操作系统的文件管理

#### 文件的逻辑结构

##### 逻辑结构的文件类型

- 有结构文件：文本、文档、媒体文件
  - 由定长记录和可变长记录组成
  - 定长记录存储文件格式、编码等结构化数据，例如文件标记和文件结束标记
  - 可变长记录存储文件的具体内容，例如PNG数据块
  - ![image-20200523130643270](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523130643270.png)
- 无结构文件：二进制文件，链接库
  - 流式文件
  - 文件内容长度以字节为单位，如exe、dll、so

##### 顺序文件

- 按照顺序存放在存储介质中的文件
- 例如磁带，只能存储顺序文件
- 顺序文件是所有逻辑文件当中存储效率最高的
- 增删改效率低

##### 索引文件

- 可变长文件不适合使用顺序文件格式存储
- 索引文件就是为了解决可变长文件存储而发明的一种文件格式
- 需要索引表来配合完成存储的操作
- 索引表：![image-20200523131040792](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523131040792.png)

#### 辅存的存储空间分配

##### 辅存的分配方式

- 连续分配：![image-20200523131151274](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523131151274.png)
  - 顺序读取文件非常容易，很快
  - 对存储要求高，要求满足容量的连续存储空间
- 链接分配：存储在离散的盘块，需要额外的空间存储文件的盘块链接顺序
  - 隐式：隐式的链接存储在当前的盘块内![image-20200523131325153](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523131325153.png)
    - 非常适合顺序访问，但随机访问效率很低
    - 可靠性差，一个块出问题，影响整个文件
  - 显式：盘块中不指定下一个盘块，而是一个表记录![image-20200523131449140](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523131449140.png)
    - FAT表，File Allocation Table
    - 不支持高效存储（FAT记录项多）
    - 检索FAT占用较大的存储空间（需要将整个FAT加载到内存）
- 索引分配：把文件的所有盘块集中存储（索引）
  - 读取某个文件时，将文件的索引读入内存即可
  - ![image-20200523131645430](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523131645430.png)
  - 12是索引，12中指向具体的盘块
  - 每个文件都拥有一个索引块，记录所有盘块信息
  - 索引分配支持直接访问盘块
  - 文件较大时，索引分配方式具有明显优势

#### 辅存的存储空间管理

##### 空间表

存储第一个空闲盘块号，空闲盘块数

![image-20200523131839179](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523131839179.png)

- 空闲盘区的分配与内存分配类似
- 首次适应算法、循环适应算法
- 回收过程也类似

##### 空闲链表

把所有空闲盘区组成一个空闲链表，每个链表节点存储空闲盘块和空闲的数量

##### 位示图

用0、1表示盘块是否使用，维护成本很低，可以容易找到空闲盘块，占用空间也很小

![image-20200523131941104](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523131941104.png)

#### 目录管理

##### 目录树

![image-20200523132047515](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523132047515.png)

- 任何文件和目录都只有唯一路径

#### Linux文件的基本操作

##### Linux目录

![image-20200523132535448](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523132535448.png)

![image-20200523132552812](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523132552812.png)

- 相对路径
- 绝对路径

##### 常用操作

![image-20200523133036996](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523133036996.png)

##### Linux的文件系统

- FAT：File Allocation Table，早期微软的文件系统，使用一张表来保存整个盘块信息
- NTFS：New Technology File System，WindowsNT环境的文件系统，Linux支持
- EXT2/3/4：扩展文件系统，Liunx下的文件系统，Windows不支持

##### EXT文件系统

![image-20200523133339863](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523133339863.png)

Block Group：

![image-20200523133359140](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523133359140.png)

- BootSector：启动扇区。安装开机管理程序
- Inode table：存储Inode的地方，每个文件（目录）都有一个Inode，是索引节点
- Inode：存放文件信息，文件类型、文件权限、文件物理地址、文件长度、文件链接技数、文件存取时间、文件状态、访问技数、链接指针……
  - 文件名不是存放在Inode节点上的，而是存放在目录的Inode节点上
  - 列出目录文件的时候无需加载文件的Inode
- Inode bitmap：记录已分配的Inode和未分配的Inode，初始时Inode的数量就确定了的
- Data Block：存放文件内容的地方，每个Block都有唯一的编号，文件的block记录在文件的Inode上
- Block bitmap：记录DataBlock的使用情况
- Super Block：记录文件系统相关信息的地方，Block和Inode使用情况、时间信息、控制信息等

### 操作系统的设备管理

#### 广义IO设备

- 对CPU而言，对CPU进行数据输入的都是输入设备；
- 对CPU而言，CPU进行数据输出的都是输出设备；

按使用特性分类：

- 存储设备：U盘、内存、磁盘
- 交互IO设备：键盘、鼠标、显示器

按信息交换的单位：

- 块设备(b)：磁盘、SD卡
- 字符设备(c)：打印机、Shell终端

按设备的共享属性：

- 独占设备
- 共享设备
- 虚拟设备

按传输速率：

- 低速
- 中速
- 高速

#### IO设备的缓冲区

（也是为了解决CPU与IO设备的速率不匹配）

- 较少CPU处理IO请求的频率
- 提高CPU与IO设备的并行性

![image-20200523134635698](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523134635698.png)

操作系统划分出缓冲池。

![image-20200523134709978](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523134709978.png)

使用完归还。

#### SPOOLing技术

- 关于慢速字符设备如何与计算机主机交换信息的一种技术
- 利用高速共享设备将低俗独享设备模拟为高速的独享设备
- 逻辑上，系统为每一个用户都分配了一台独立的高速独享设备

![image-20200523134921185](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523134921185.png)

把同步调用变为异步调用。

- 在输入输出之间增加了排队转储环节（输入井、输出井）
- SPOOLing负责输入（出）井与低俗设备之间的调度
- 逻辑上，进程直接与高速设备交互，减少了进程的等待时间

![image-20200523135416056](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523135416056.png)

### 进阶

![image-20200523135554721](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523135554721.png)

![image-20200523135621647](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523135621647.png)

![image-20200523135730822](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523135730822.png)



#### 线程同步

##### 互斥量

保证先后执行。即保证原子性，一系列操作不可被中断的特性，一系列操作要么全部执行，要么全部不执行。

- 线程同步最简单的方法
- 互斥量（互斥锁），处于两态之一：解锁、加锁
- 保证资源访问的串行
- 操作系统提供了互斥量的API

##### 自旋锁

原理与互斥量同，也是一种多线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用，不会让出CPU，而是一种忙等待，死循环等待锁释放，

- 自旋锁避免了进程或线程上下文切换的开销
- 操作系统很多地方使用的是自旋锁
- 自旋锁不适合在单核CPU使用！

##### 读写锁

改进：考虑多读少写的场景，例如存储历史订单信息的数据库、表。读取的时候并不会改变临界资源的值。

- 特殊的自旋锁
- 允许多个读者同时访问资源以提高读性能
- 对于写操作是互斥的

##### 条件变量-配合互斥量使用

- 相对复杂的线程同步方法
- 条件变量允许线程睡眠，直到满足某种条件
- 当满足条件时，可以向该线程发信号，通知唤醒



#### 进程同步

创建子进程：![image-20200523200932025](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523200932025.png)

子进程与父进程的状态一致。![image-20200523201130774](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200523201130774.png)

##### 共享内存

- 某种程度上，多进程是共同使用物理内存的
- 由于操作系统的进程管理，进程间的内存空间是独立的，保证安全性
- 共享内存打破这个限制，多个进程通过页表映射到同一块物理内存、
- 允许不相关的进程访问同一片物理内存
- 是最快的IPC方式，两个进程之间共享和传递数据最快的方式
- 未提供同步机制，需要借助其他机制管理访问

步骤：

- 申请共享内存
- 共享内存连接到进程空间
- 使用共享内存
- 脱离进程空间&删除

##### Unix域套接字

- 高级进程间通信方法
- 套接字原是网络通信中的术语
- Unix系统提供的域套接字提供了网络套接字类似的功能
- 文件系统中创建一个文件（套接字文件），套接字与指定文件绑定
- 提供了单机简单可靠的进程通信同步服务，只能单机使用

例如：

服务端：

- 创建套接字
- 绑定套接字
- 监听套接字
- 接收处理信息

客户端：

- 创建套接字
- 连接套接字
- 发送信息

## 问题集锦

### 什么是操作系统

- 操作系统是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石
- 操作系统向用户提供一个与系统交互的操作界面
- 实质上是运行在计算机上的一套软件程序

### 系统调用

1. 用户态：应用程序运行在用户态，用户要运行的进程可以直接读取用户程序的数据
2. 内核态：内核态运行的程序几乎可以访问计算机的任何资源，不受限制

系统调用是内核提供的一组通用访问接口，为了使应用程序访问到内核管理的资源例如CPU、内存、I/O等。

应用程序运行在用户态，如果需要使用内核态级别的功能，就绪要系统调用。也就是说，凡是与内核态级别资源有关的操作（文件管理、进程控制、内存管理）都必须通过系统调用的方式，向操作系统提出服务请求，并又操作系统代为完成。可以分为：

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

### 用户态切换到内核态

1. 系统调用，这个上面已经讲解过了，在我公众号之前的文章也有讲解过。其实系统调用本身就是中断，但是软件中断，跟硬中断不同。

2. 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。

3. 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。

### 进程和线程及区别

- 主要指责是要管理好它的资源；进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，~~实现了操作系统的并发~~；
- 主要是利用CPU资源去运行代码；线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的**实时性**，~~实现进程内部的并发~~；
- 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；
- 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（进程共享数据需要进程通信的方法，线程共享数据可以采用类似共享内存的方式，快/简单//进程切换更耗费资源，线程切换开销小，更轻量）
- 进程之间比较独立，一个进程奔溃不会影响到其他进程；而一个线程奔溃可能影响其他线程。

### 进程间的通信方式

- 管道及命名管道：管道用于具有亲缘关系的父子进程间通信，有名管道在管道的基础上还允许无亲缘关系的进程间通信；
- 信号（signal）：通知接收进程某个事件已发生；
- 消息队列：消息的链接表，克服了信号承载信息量少、管道只能承载物格式字符流以及缓冲区大小受限的缺点，具有写权限的进程可以按照一定的规则向消息队列中添加新信息，具有读权限的进程可以从消息队列中读取信息；
- 共享内存：最快的IPC方式，使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。依赖于某种同步操作，如互斥锁和信号量等；
- 信号量：主要作为进程之间及同一种进程的不同线程之间的同步和互斥手段；
- 套接字：用于网络中不同机器之间的进程间通信。接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

### 线程同步的方式

- 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问；
- 信号量Semphare：允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
- 事件（信号）Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作；

### 死锁

在两个或者多个并发进程中，如果每个进程都持有某种资源而又等待其他线程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗，就是两个或者多个线程无限期阻塞、相互等待的一种状态。

**四个必要条件**

互斥：至少又一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他线程申请使用该资源，那么申请线程必须等到该资源被释放

占有并等待：一个进程占有一定的资源，并等待另一个资源，而该资源又被其他线程所占有

不可剥夺：线程资源不能被抢占，只能自己释放

循环等待：死锁进程之间形成一种头尾相接的环形等待资源的关系。

**基本解决方法**

- 死锁预防：确保四个必要条件中至少有一个不成立。
  - 打破互斥，不现实
  - 打破占有并等待：实施资源预分配策略，线程在运行前一次性向系统申请他所需要的全部资源，若所需资源得不到满足，则不分配任何资源，此线程暂不运行。不可预知的
  - 打破非抢占：运行线程强行从占有者那里夺取某些资源（即一个线程占有一部分资源，申请不到新的资源，主动释放已有资源，相当于被动抢占）
  - 打破循环等待条件：实行资源有序分配策略，对所有资源排序编号，所有对资源的请求必须严格按照资源序号递增的顺序提出，只有占有了小号资源才能去申请大号资源，这样就不会产生环路
- 死锁避免：动态地检测资源分配状态，以确保循环等待条件不成立。
  - 资源分配图算法
  - 银行家算法
- 死锁解除：
  - 进程终止：简单地终止一个或多个进程以打破循环等待，终止所有死锁进程或者一次终止一个进程知道取消死锁循环位置
  - 资源抢占：从一个或多个死锁进程那里抢占一个或多个资源
- 死锁检测
- 鸵鸟策略

### 进程的状态

- 就绪状态：进程已获得除处理机外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源，处于此状态的线程数小于等于CPU数
- 阻塞状态：进程等待某种条件，在条件满足前无法执行，如等待某资源/等待IO操作完成

![image-20200509225037722](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200509225037722.png)

### 线程的状态

在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：

- 创建(new)
- 就绪(runnable/start)
- 运行(running)
- 阻塞(blocked)
- 等待(waiting)
- 时间等待(time waiting) 
- 消亡(dead/terminated)

在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：

![image-20200509225119852](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200509225119852.png)

### 分段和分页

段式存储是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段，如代码段、数据段、堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。优点：没有碎片（因为段大小可变，改变段大小来消除碎片）。但段换入换出时，会产生外碎片（4k的段换5k的段，会产生1k外碎片）

页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页，而无力内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。优点：没有外碎片，会有内碎片（一个页可能填充不满）

相同点：

- 都是为了提高内存利用率，减少内存碎片
- 页和页之间、段和段之间的内存都是离散的，页内、段内的内存是连续的

**不同点：**

- 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能够更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
- 大小不同：页的大小固定且由系统决定；而段的长度不固定，由其所完成的功能决定；
- 地址空间不同：段想用户提供二维地址空间；页向用户提供一维地址空间
- 信息共享：段式信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
- 内存碎片：页式存储管理的优点是没有外碎片（页大小固定），但会产生内碎片（一个也可能填充不满）；段式存储管理的优点是没有内碎片（段大小可变，改变段大小可以消除内碎片），但段换入换出时，会产生外碎片

### 操作系统进程调度策略

- FCFS，先来先服务，队列实现，非抢占：先请求CPU的进程先分配到CPU
- SJF，最短作业优先：平均等待时间最短
- 优先级调度算法（可以是抢占的，也可以是非抢占的）：优先级越高越先分配到CPU，相同优先级先来先服务，存在低优先级饥饿，解决方法：老化；
- 时间片轮转调度算法（可抢占的）：按时间片分配，时间片大小设置比较重要
- 多级队列调度算法：将就绪队列分称多个独立的队列，每个队列有自己的调度算法，队列之间采用固定优先级抢占调度，进程根据自身属性被分配到一个队列中
- 多级反馈队列算法：允许进程在队列之间移动；若进程使用过多的CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，防止饥饿发生。

### 进程同步的机制

- 原子操作
- 信号量机制
- 自旋锁管程
- 会合
- 分布式系统

### 操作系统的内存管理主要是做什么？

操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。

### 操作系统的内存管理机制了解吗？内存管理有哪几种方式?

简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理**。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理** 和 **段式管理**。

**块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。

**页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。

**段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。

**面试官**： 回答的还不错！不过漏掉了一个很重要的 **段页式管理机制** 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 **段页式管理机制** 中段与段之间以及段的内部的都是离散的。

### **快表和多级页表**

在分页内存管理中，很重要的两点是：

虚拟地址到物理地址的转换要快。

解决虚拟地址空间大，页表也会很大的问题。

**快表**

为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案**基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把块表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：

根据虚拟地址中的页号查快表；如果该页在快表中，直接从快表中读取相应的物理地址；如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。

**多级页表**

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。

**总结**

为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。

### 虚拟内存

https://zhuanlan.zhihu.com/p/96098896

虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续可用的内存，一个连续完整的地址空间，而实际上，它通常是被分割成多个物理内存碎片，还有部分暂时存在磁盘，在需要时交换。

每个进程被加载的时候，会被分配连续的虚拟地址空间，虚拟的意思就是这个地址空间是不存在的，仅仅是每个进程认为自己拥有这些内存，实际上，它用多少，操作系统就在磁盘上划出多少空间给他，等到进程真正运行时，需要某些数据并且不在物理内存中，才出发缺页以异常，装入页面

基本思想：每个进程有自己独立的地址空间（逻辑地址/虚拟地址），这个空间被分为大小相等的多个块，即页，每个页都是一段连续的地址。这些页被映射到物理内存。但并不是所有的页都在物理内存中，在物理内存中的，立刻映射；不在物理内存中的，由操作系统负责将缺失的页面装入物理内存并重新执行失败的指令。这样**对进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块，还有一些没加载在内存中的对应在硬盘上。**

虚拟内存实际上可以比物理内存大，当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址，如果虚拟内存的页不在物理内存中，产生缺页中断，从磁盘取得缺的页放入内存，如果内存满了，根据页面置换算法置换页。

页表：（存储虚拟页信息）

![image-20200509232902013](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200509232902013.png)

每个PTE由一个有效位和一个地址组成，有效位表示是否存在于物理内存中，如果是1，就会存储物理内存中相遇的物理页的起始地址；如果是0，如果PTE里有地址，那么这个地址指向该虚拟页在磁盘上的起始位置，如果PTE没地址，为null，表示这个虚拟页还未被分配。

**虚拟内存的应用和优点**

- 在内存中可以保留多个进程，系统并发度高
- 接触了用户与内存之间的紧密约束，进程可以比内存的全部空间还大

**为什么要有虚拟地址空间**

直接把物理地址暴露出来的话可能带来严重的问题，而通过虚拟地址访问内存：

- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区
- 程序可以使用虚拟地址来访问大于可用物理内存的内存缓冲区
- 不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法使用另一个进程使用的物理内存

### 页面置换算法

- FIFO：先进先出算法
- LRU：最近最少使用算法
- LFU：最少使用次数算法
- OPT：最优置换算法，保证置换出去的页就是不被再使用的页，或者是在实际内存中最晚使用的。难实现

### 颠簸

频繁的页调度行为，具体来讲，进程发生缺页中断，这是必须置换一页，然后其他所有页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，被称为颠簸/抖动。

解决策略：

- 如果是因为页面替换策略失误，可以修改置换算法解决
- 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量
- 增加物理内存容量
- 终止该进程

### 局部性原理

- 时间上的局部性：最近被访问的页在不久的将来还会被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
- 空间上的局部性：内存中被访问的页的周围的页也很可能被访问。这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

https://baijiahao.baidu.com/s?id=1662933680603182461&wfr=spider&for=pc

https://zhuanlan.zhihu.com/p/86629244



### 什么是僵尸进程？

一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。

危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。

以下情况不会产生僵尸进程：

- 该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。
- 父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入`WNOHANG`(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；
- 子进程结束时，系统会产生`SIGCHLD`(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；
- 也可以用`signal(SIGCLD, SIG_IGN)`(signal-ignore)通知内核，表示忽略`SIGCHLD`信号，那么子进程结束后，内核会进行回收。

### 孤儿进程

一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。

### 协程

协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。

协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。

一个进程可以包含多个线程，一个线程也可以包含多个协程。简单来说，一个线程内可以由多个这样的特殊函数在运行，但是有一点必须明确的是，一个线程的多个协程的运行是串行的。如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。当一个协程运行时，其它协程必须挂起。



作者：JunChow520
链接：https://www.jianshu.com/p/6dde7f92951e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

进程、线程、协程的对比

- 协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。
- 一个进程可以包含多个线程，一个线程可以包含多个协程。
- 一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。
- 协程与进程一样，切换是存在上下文切换问题的。

上下文切换

- 进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。
- 线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。
- 协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。



作者：JunChow520
链接：https://www.jianshu.com/p/6dde7f92951e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





### 什么是IO多路复用？怎么实现？

IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。

实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。

<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">select/poll/epoll三者的区别？</summary><ul style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px;"><li style="box-sizing: border-box;"><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 6px;">select</code>：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，<strong style="box-sizing: border-box; font-weight: 600;">开销大</strong>），由内核根据就绪状态修改该集合的内容。（缺点2）<strong style="box-sizing: border-box; font-weight: 600;">集合大小有限制</strong>，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：<strong style="box-sizing: border-box; font-weight: 600;">轮询的方式效率较低</strong>），当文件描述符的数量增加时，效率会线性下降；</li><li style="box-sizing: border-box; margin-top: 0.25em;"><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 6px;">poll</code>：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；</li><li style="box-sizing: border-box; margin-top: 0.25em;"><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 6px;">epoll</code>：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。</li></ul><p style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">总结，区别主要在于：</p><ul style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px;"><li style="box-sizing: border-box;">一个线程/进程所能打开的最大连接数</li><li style="box-sizing: border-box; margin-top: 0.25em;">文件描述符传递方式（是否复制）</li><li style="box-sizing: border-box; margin-top: 0.25em;">水平触发 or 边缘触发</li><li style="box-sizing: border-box; margin-top: 0.25em;">查询就绪的描述符时的效率（是否轮询）</li></ul></details>

<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">什么时候使用select/poll，什么时候使用epoll？</summary><p style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。</p></details>

<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">什么是文件描述符？</summary><p style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><p style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">内核通过文件描述符来访问文件。文件描述符指向一个文件。</p></details>

##### 什么是水平触发？什么是边缘触发？

<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">展开</summary><ul style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px;"><li style="box-sizing: border-box;">水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；</li><li style="box-sizing: border-box; margin-top: 0.25em;">边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。</li><li style="box-sizing: border-box; margin-top: 0.25em;">区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</li><li style="box-sizing: border-box; margin-top: 0.25em;">为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。</li></ul></details>

##### 有哪些常见的IO模型？

<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">展开</summary><ul style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px;"><li style="box-sizing: border-box;">同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；</li><li style="box-sizing: border-box; margin-top: 0.25em;">同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；</li><li style="box-sizing: border-box; margin-top: 0.25em;">IO多路复用</li><li style="box-sizing: border-box; margin-top: 0.25em;">异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。</li></ul></details>

### 什么是用户态和内核态？

为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。

- 用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；
- 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。

所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用**陷阱指令**，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。

##### 为什么要分用户态和内核态？

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">展开</summary></details>

##### 如何从用户态切换到内核态？

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">展开</summary></details>

### 什么是死锁？

在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。

### 死锁产生的必要条件？

- **互斥**：一个资源一次只能被一个进程使用；
- **占有并等待**：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；
- **非抢占**：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；
- **循环等待**：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。

### 死锁有哪些处理方法？

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">鸵鸟策略</summary></details>

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">死锁预防</summary></details>

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">死锁避免</summary></details>

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">死锁解除</summary></details>

### 分页和分段有什么区别？

- 页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；
- 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；
- 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。

区别：

- 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；
- 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；
- 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；
- 分段便于信息的保护和共享；分页的共享收到限制；
- 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）

### 什么是虚拟内存？

每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。

虚拟内存的优点是让程序可以获得更多的可用内存。

##### 如何进行地址空间到物理内存的映射？

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">展开</summary></details>

### 有哪些页面置换算法？

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

- **最佳页面置换算法**OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；
- **先进先出**FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；
- **第二次机会算法**SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
- **时钟算法** Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；
- **最近未使用算法**NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；
- **最近最少使用算法**LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
- **最不经常使用算法**NFU：置换出访问次数最少的页面

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">局部性原理</summary></details>

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">什么是颠簸现象</summary></details>

### 磁盘调度

过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：

- 先来先服务
- 最短寻道时间优先
- 电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

### 参考

- [进程间通信IPC -- 简书](https://www.jianshu.com/p/c1015f5ffa74)
- [面试/笔试第二弹 —— 操作系统面试问题集锦 - CSDN博客](https://blog.csdn.net/justloveyou_/article/details/78304294)
- [线程同步与并发 - - SegmentFault](https://segmentfault.com/a/1190000018970361)
- [彻底搞懂epoll高效运行的原理](http://baijiahao.baidu.com/s?id=1641172494287388070&wfr=spider&for=pc)
- [用户态与内核态的切换](https://www.cnblogs.com/lirong21/p/4213028.html)

### 待完成

-  IPC
-  进程同步问题：生产者-消费者问题...
-  银行家算法
-  文件与文件系统、文件管理？

[![img](https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191202162008435_14938.png)](https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191202162008435_14938.png)

<details class="details-reset details-overlay details-overlay-dark" id="jumpto-line-details-dialog" style="box-sizing: border-box; display: block;"><summary data-hotkey="l" aria-label="Jump to line" role="button" style="box-sizing: border-box; display: list-item; cursor: pointer; list-style: none;"></summary></details>

- © 2020 GitHub, Inc.
- [Terms](https://github.com/site/terms)
- [Privacy](https://github.com/site/privacy)
- [Security](https://github.com/security)
- [Status](https://githubstatus.com/)
- [Help](https://help.github.com/)



- [Contact GitHub](https://github.com/contact)
- [Pricing](https://github.com/pricing)
- [API](https://developer.github.com/)
- [Training](https://training.github.com/)
- [Blog](https://github.blog/)
- [About](https://github.com/about)

 Octotree

FEATURE UPDATES V5.0!



Login to unlock more features

13.250.177.223