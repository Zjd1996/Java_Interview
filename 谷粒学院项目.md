# 谷粒学院项目

## 商业模式

### B2C模式

Business To Customer会员模式。

商家到用户，自己制作大量自有版权的视频，放在自有平台。简单专心路由大量视频即可快速发展，由于中国版权保护意识不强，教育内容易于复制，难以得到像样的现金流。

### C2C模式

用户到用户，本质是将自己的流量或者用户转卖给视频或者直播的内容提供者，通过出售内容分成获利，避开沉重的内容和服务，扩张迅速。

### B2B2C模式

平台连接**第三方教育机构**（也可以是个人用户）和**用户**，平台一般不直接提供课程内容，而是更多承担教育的互联网载体决赛，为教学过程各个环节提供全方位支持和服务。

B2B2C是C2C的更全面、更完整的表现形式

### 1对1

讲师一对一辅导，按时间收费。

### 直播、互动

### 垂直领域

糅合录播、直播、1对1、帮助服务等多种手段，对学生学习某一项内容负责。

猿辅导。

### O2O模式

线上到线下

### freemium

免费增值，以免费吸引用户，然后通过增值服务，将部分免费用户转化为收费用户。二八定律

## 行业分类

### 母婴

### 学前

### 少儿外语

### 中小学

### 高校

### 留学

### 职业考试

### 职业技能

### 成人外语

### 个人兴趣

## 项目简介

谷粒学院，B2C，商家提供，IT职业技能在线教育系统，分为前台用户系统和后台运营平台。

![image-20200611151831641](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611151831641.png)

![image-20200611151845919](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611151845919.png)

## 技术架构

![image-20200611152439857](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611152439857.png)

![image-20200611152734170](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611152734170.png)

![image-20200611153508591](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611153508591.png)

## Mybatis-Plus

### 简介

为简化开发而生。

- 润物无声：只做增强，不做改变
- 效率至上：只需简单配置，即可快速进行CRUD
- 丰富功能：热加载、代码生成、分页、性能分析等功能一应俱全

### 创建并初始化数据库

1. 创建数据库：mybatis_plus

2. 创建user表：

   ```sql
   CREATE TABLE user
   (
   	id BIGINT(20) NOT NULL COMMENT '主键ID',
   	name VARCHAR(30) NULL DEFAULT NULL COMMNET '姓名',
   	age INT(11) NULL EFAULT NULL COMMENT '年龄',
   	email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',
   	PRIMARY KEY (id)
   )
   ```

3. 创建测试数据

   ```sql
   INSERT INTO user(id, name, age, email) VALUES
   (1, 'Jone', 18, 'test1@baomidou.com'),
   (2, 'Jack', 38, 'test2@baomidou.com'),
   (3, 'Jammy', 48, 'test3@baomidou.com'),
   (4, 'Tom', 48, 'test4@baomidou.com'),
   (5, 'Cat', 38, 'test5@baomidou.com'),
   (6, 'Bill', 19, 'test6@baomidou.com');
   ```

### 确认IDEA配置

- 编译器
- 编码
- Maven

### 创建项目

sprintboot项目。Spring Initializer。

### 引入依赖

```xml
 <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.3.1</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
```

### 编码

1. 配置

   1. 在application.properties中添加MySQL数据库相关配置
   2. springboot2.0，内置jdbc5驱动![image-20200611162653034](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611162653034.png)
   3. springboot2.1以上，内置jdbc8驱动![image-20200611162757062](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611162757062.png)

2. @MapperScan("包名")，扫描mapper位置

3. entity类，添加@Data生成getset方法

4. mapper包添加接口：继承BaseMapper，直接拥有增删改查方法

   ```java
   @Repository
   public interface UserMapper extends BaseMapper<User> {
       
   }
   ```

5. mybatis日志

```
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
```

### CRUD-主键策略

#### 插入操作

```java
	@Test
    public void testInsert() {
        User user = new User();
        user.setName("zjd");
        user.setEmail("775316284.qq.com");
        user.setAge(24);
        
        // 影响的行数
        int result = userMapper.insert(user);
        System.out.println("row :" + result);
        System.out.println("user id:" + user.getId());
        
    }
```

userId生成全局唯一ID。就是分布式ID，默认使用了雪花算法。

全局逐渐生成策略：

```
mybatis-plus.global-config.db-config.id-type=assign_id
```



#### 数据库分库分表策略

1. 业务分库：按照业务模块将数据分散到不同的数据库服务器。![image-20200611165056023](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611165056023.png)

存在的问题：

- join操作问题：业务分库后，表分散，无法使用SQL的join查询。
- 事务问题：表分散，无法通过事务统一修改。
- 成本问题：成本提高。

#### 主从复制和读写分离

![image-20200611165405538](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611165405538.png)、

基本实现：

- 主从集群，一主一从，一主多从
- 主机负责写，从机负责读
- 数据库主机通过复制，将数据复制到从机
- 业务服务器将写请求发到主，将读请求发送到从

主从（主从都干活），主备（主机干活，备机只提供备份功能）。

#### 数据库分表

将不同业务数据存储到不同的数据库服务器。

单表拆分两种方式：

- 垂直分表
- 水平分表

![image-20200611165805197](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611165805197.png)

引入复杂性：

- 垂直分表：适合用于表中某些不常用但占用了大量空间的列拆出去

- 水平分表：数据量太多时(跨表查询，可以使用UNION)

  - 主键自增：1-999999一个段，1000000-1999999一个段，分段大小的选取比较复杂，建议100w到2000w，不是很均匀，扩充很容易

  - hash策略：比如分10个表，userid%10得到库的编号，初始表数量的选取比较复杂，比较均匀，扩充新表复杂

  - 雪花算法：分布式ID生成器，Twitter的分布式主键生成算法，保证不同表的主键的不重复性，以及相同表的主键的有序性。整体按照时间自增，不重复。

    - 长度64bit（long）
    - 首先是一个符号位1bit，一般为0表示正数
    - 41bit时间戳位，存储的是时间戳的差值（当前时间戳-开始时间戳），约等于70年
    - 10bit机器ID（5bit位数据中心，5bit的机器ID，可以部署在1024个节点）
    - 12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生4096个ID）

    ![image-20200611171140689](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611171140689.png)

### CRUD-自动填充和乐观锁

#### 自动填充

比如创建时间、更新时间字段，可以让Mp自动填充。

1. 数据库修改，user表中添加datetime类型的create_time\update_time

2. 实体类修改，添加自动填充注解

   ```
   @TableField(fill = FieldFill.INSERT)
   
   @TableField(fill = FieldFill.INSERT_UPDATE)
   ```

3. 实现元对象处理器接口

   ```java
   package com.zjd.mybatis_plus.handler;
   
   import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
   import org.apache.ibatis.reflection.MetaObject;
   import org.springframework.stereotype.Component;
   
   import java.util.Date;
   
   /**
    * @program mybatis_plus
    * @description:
    * @author: zhaojiangdong
    * @create: 2020/06/11 17:26
    */
   
   @Component
   public class MyMetaObjectHandler implements MetaObjectHandler {
       @Override
       public void insertFill(MetaObject metaObject) {
           this.setFieldValByName("createTime", new Date(), metaObject);
           this.setFieldValByName("updateTime", new Date(), metaObject);
       }
   
       @Override
       public void updateFill(MetaObject metaObject) {
           this.setFieldValByName("updateTime", new Date(), metaObject);
       }
   }
   
   ```

#### 乐观锁

模拟：

1. 增加商品表

   ![image-20200611173251605](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611173251605.png)

2. 添加记录
3. 每次update要检查版本号是否变化，更新时也要给版本号+1

MP怎么做的？——使用MP

- @Version注解

- 乐观锁插件：写在配置文件config包

  ```javaj a
  package com.zjd.mybatis_plus.config;
  
  import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  /**
   * @program mybatis_plus
   * @description:
   * @author: zhaojiangdong
   * @create: 2020/06/11 19:09
   */
  @Configuration
  public class MyBatisPlusConfig {
      @Bean
      public OptimisticLockerInterceptor optimisticLockerInterceptor() {
          return new OptimisticLockerInterceptor();
      }
  }
  
  
  
  也可以把主类的mapperScan也放在config包里
  包括其他注解
  
  ```

### CRUD-查询和分页

#### 通过多个id查

```
    @Test
    public void testSelectBatchIds() {
        List<User> users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));
        users.forEach(System.out::println);
    }
```

#### 通过map查多个条件

```java
@Test
    public void tsetselectByMap() {
        HashMap<String, Object> map = new HashMap<>();
        map.put("name", "zjd");
        map.put("age", 24);
        List<User> users = userMapper.selectByMap(map);
        users.forEach(System.out::println);

    }
```

#### 分页插件

```java
√=    @Bean
    public PaginationInterceptor paginationInterceptor() {
        return new PaginationInterceptor();
    }
```

### CRUD-删除和逻辑删除

物理删除：真是删除

逻辑删除：假删除，将数据中代表是否被删除的字段修改为被删除状态，场景：可以进行数据恢复，有关联数据不便删除

逻辑删除实现：

- 增加deleted字段，默认false
- @TableLogic注解即可
- 可以在配置文件中配置delete值，删除与否的代表值，默认0没删和1删了

### 条件构造器和常用接口

![image-20200611194922702](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200611194922702.png)

一个例子：

```java
QueryWrapper<user> queryWrapper = new QueryWrapper<User>();
queryWrapper.eq("age", 24);
			.isNotNull("email")
                .gt("xx", xx);
int result = userMapper.delete(queryWrapper);

```

## 项目环境搭建

### 一：什么是微服务？为什么要用微服务？

什么是微服务？（熟悉的同学可以直接跳过）

简单举例：看军事新闻的同学应该都知道，一艘航空母舰作战能力虽然很强，但是弱点太明显，就是防御能力太差，单艘的航空母舰很少单独行动，通常航空母舰战斗群才是主要军事力量，你可以把单艘航母理解为的单体应用（防御差，机动性不好），把航母战斗群（调度复杂，维护费用高）理解为微服务。

大部分的开发者经历和开发过单体应用，无论是传统的 Servlet + JSP，还是 SSM，还是现在的 SpringBoot，它们都是单体应用，那么长期陪伴我们的单体应用有什么弊端？我们是面临了什么问题，导致我们要抛弃单体应用转向微服务架构？个人总结主要问题如下：

- 部署成本高（无论是修改1行代码，还是10行代码，都要全量替换）
- 改动影响大，风险高（不论代码改动多小，成本都相同）
- 因为成本高，风险高，所以导致部署频率低（无法快速交付客户需求）

当然还有例如无法满足快速扩容，弹性伸缩，无法适应云环境特性等问题，但我们不一一详谈了，以上的问题，都是微服务架构要解决的问题，至于具体是怎么解决的，我们先放到后面再聊

### 二：微服务解决什么问题，又引入了什么问题？

我们先看看微服务能带给我们什么？微服务架构的特点：

- 针对特定服务发布，影响小，风险小，成本低
- 频繁发布版本，快速交付需求
- 低成本扩容，弹性伸缩，适应云环境

 

我们知道一个朴素的理念，没有任何事物是完美的，任何东西都有两面性，有得必有失，那么在选择微服务在解决了快速响应和弹性伸缩的问题同时，它又给我们带来了什么问题？个人总结如下：

- 分布式系统的复杂性
- 部署，测试和监控的成本问题
- 分布式事务和CAP的相关问题

 三：使用微服务应该遵循哪些原则？

古人云：兵马未动，粮草先行。建设微服务是需要建立长远规划，不是像写CMS那样建好数据库表，然后就开始干活，这样十有八九是会失败的。我们要进行微服务改造前，架构师要提前做好规划，我们把这里分为三步，前期阶段，设计阶段，技术阶段

前期阶段，大致要做好如下事情：

- 和多方充分沟通，确保能符合客户和组织的需求，并且得到认同
- 和团队沟通，让队友（开发/测试/运维）理解，并且积极投入
- 和业务部门沟通，指定版本计划和上线时间

 

设计阶段，参考 Sam Newman 的著作[《微服务设计》](https://book.douban.com/subject/26772677/)，单微服务必须要满足以下的条件，才符合微服务的基本要求：

- 标准的 REST 风格接口（基于 HTTP 和 JSON 格式）
- 独立部署，避免共享数据库（避免因为数据库而影响整个分布式系统）
- 业务上的高内聚，减少依赖（从设计上要避免服务过大或者太小）

 

庞大的分布式系统，需要强大基础设施来支撑，微服务涉及哪些基础设施？

- CI/CD和自动化（分布式系统几乎不可能通过人工手动发布）
- 虚拟化技术（要保证微服务运行环境隔离，目前行业主流的是使用 Docker 容器）
- 日志聚合，全链路监控（高度可观察和分析诊断问题）

 

说了那么多，那什么样的情况下，你的团队不适合建设微服务？（请勿对号入座）

1. 开发团队不具备自主性，所在组织对开发团队限制非常多（具体请参考 [康威定律](https://zh.wikipedia.org/wiki/康威定律)）
2. 团队不熟悉业务，无法识别出服务的边界，进行合理的拆分（请参考 DDD [领域驱动设计](https://en.wikipedia.org/wiki/Domain-driven_design)）

 

 

### 工程结构

- Gulf_parent：根目录（父工程），管理四个子模块：
  - canal_client：canal数据库表同步模块（统计同步数据）
  - common：公共模块父节点
    - Common_util
    - Service_base
    - Spring_security
  - infrastructure：基础服务父节点
    - api_gateway：api网关服务
  - service：api接口服务父节点
    - service_acl：用户权限管理api接口服务（用户管理、角色管理和权限管理）
    - Service_cms
    - service_edu
    - Service_sms
    - service_order
    - Service_oss
    - Service_statistics
    - Service_ucenter
    - service_vod

### 创建父工程guli_parent

- Spring initializer

- 配置springboot版本

- 配置pom依赖版本号：父项目统一管理依赖<properties>

  ```
  <properties>
          <java.version>1.8</java.version>
          <guli.version>0.0.1-SNAPSHOT</guli.version>
          <mybatis-plus.version>3.0.5</mybatis-plus.version>
          <velocity.version>2.0</velocity.version>
          <swagger.version>2.7.0</swagger.version>
          <aliyun.oss.version>2.8.3</aliyun.oss.version>
          <jodatime.version>2.10.1</jodatime.version>
          <poi.version>3.17</poi.version>
          <commons-fileupload.version>1.3.3</commons-fileupload.version>
          <commons-io.version>2.6</commons-io.version>
          <httpclient.version>4.5.1</httpclient.version>
          <jwt.version>0.7.0</jwt.version>
          <aliyun-java-sdk-core.version>4.3.3</aliyun-java-sdk-core.version>
          <aliyun-sdk-oss.version>3.1.0</aliyun-sdk-oss.version>
          <aliyun-java-sdk-vod.version>2.15.2</aliyun-java-sdk-vod.version>
          <aliyun-java-vod-upload.version>1.4.11</aliyun-java-vod-upload.version>
          <aliyun-sdk-vod-upload.version>1.4.11</aliyun-sdk-vod-upload.version>
          <fastjson.version>1.2.28</fastjson.version>
          <gson.version>2.8.2</gson.version>
          <json.version>20170516</json.version>
          <commons-dbutils.version>1.7</commons-dbutils.version>
          <canal.client.version>1.1.0</canal.client.version>
          <docker.image.prefix>zx</docker.image.prefix>
          <cloud-alibaba.version>0.2.2.RELEASE</cloud-alibaba.version>
          <swagger-version>2.0.1</swagger-version>
          <project-version>0.0.1-SNAPSHOT</project-version>
      </properties>
  ```

  

- 配置pom依赖:：<dependencyManagement>

  ```
  <dependencyManagement>
          <dependencies>
              <!--Spring Cloud-->
              <dependency>
                  <groupId>org.springframework.cloud</groupId>
                  <artifactId>spring-cloud-dependencies</artifactId>
                  <version>Hoxton.RELEASE</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
  
              <dependency>
                  <groupId>org.springframework.cloud</groupId>
                  <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                  <version>${cloud-alibaba.version}</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
              <!--mybatis-plus 持久层-->
              <dependency>
                  <groupId>com.baomidou</groupId>
                  <artifactId>mybatis-plus-boot-starter</artifactId>
                  <version>${mybatis-plus.version}</version>
              </dependency>
  
              <!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 -->
              <dependency>
                  <groupId>org.apache.velocity</groupId>
                  <artifactId>velocity-engine-core</artifactId>
                  <version>${velocity.version}</version>
              </dependency>
  
              <!--swagger-->
              <dependency>
                  <groupId>io.springfox</groupId>
                  <artifactId>springfox-swagger2</artifactId>
                  <version>${swagger.version}</version>
              </dependency>
              <!--swagger ui-->
              <dependency>
                  <groupId>io.springfox</groupId>
                  <artifactId>springfox-swagger-ui</artifactId>
                  <version>${swagger.version}</version>
              </dependency>
  
              <!--aliyunOSS-->
              <dependency>
                  <groupId>com.aliyun.oss</groupId>
                  <artifactId>aliyun-sdk-oss</artifactId>
                  <version>${aliyun.oss.version}</version>
              </dependency>
  
              <!--日期时间工具-->
              <dependency>
                  <groupId>joda-time</groupId>
                  <artifactId>joda-time</artifactId>
                  <version>${jodatime.version}</version>
              </dependency>
  
              <!--xls-->
              <dependency>
                  <groupId>org.apache.poi</groupId>
                  <artifactId>poi</artifactId>
                  <version>${poi.version}</version>
              </dependency>
              <!--xlsx-->
              <dependency>
                  <groupId>org.apache.poi</groupId>
                  <artifactId>poi-ooxml</artifactId>
                  <version>${poi.version}</version>
              </dependency>
  
              <!--文件上传-->
              <dependency>
                  <groupId>commons-fileupload</groupId>
                  <artifactId>commons-fileupload</artifactId>
                  <version>${commons-fileupload.version}</version>
              </dependency>
  
              <!--commons-io-->
              <dependency>
                  <groupId>commons-io</groupId>
                  <artifactId>commons-io</artifactId>
                  <version>${commons-io.version}</version>
              </dependency>
  
              <!--httpclient-->
              <dependency>
                  <groupId>org.apache.httpcomponents</groupId>
                  <artifactId>httpclient</artifactId>
                  <version>${httpclient.version}</version>
              </dependency>
  
              <dependency>
                  <groupId>com.google.code.gson</groupId>
                  <artifactId>gson</artifactId>
                  <version>${gson.version}</version>
              </dependency>
  
              <!-- JWT -->
              <dependency>
                  <groupId>io.jsonwebtoken</groupId>
                  <artifactId>jjwt</artifactId>
                  <version>${jwt.version}</version>
              </dependency>
  
              <!--aliyun-->
              <dependency>
                  <groupId>com.aliyun</groupId>
                  <artifactId>aliyun-java-sdk-core</artifactId>
                  <version>${aliyun-java-sdk-core.version}</version>
              </dependency>
              <dependency>
                  <groupId>com.aliyun.oss</groupId>
                  <artifactId>aliyun-sdk-oss</artifactId>
                  <version>${aliyun-sdk-oss.version}</version>
              </dependency>
              <dependency>
                  <groupId>com.aliyun</groupId>
                  <artifactId>aliyun-java-sdk-vod</artifactId>
                  <version>${aliyun-java-sdk-vod.version}</version>
              </dependency>
              <dependency>
                  <groupId>com.aliyun</groupId>
                  <artifactId>aliyun-java-vod-upload</artifactId>
                  <version>${aliyun-java-vod-upload.version}</version>
              </dependency>
              <dependency>
                  <groupId>com.aliyun</groupId>
                  <artifactId>aliyun-sdk-vod-upload</artifactId>
                  <version>${aliyun-sdk-vod-upload.version}</version>
              </dependency>
              <dependency>
                  <groupId>com.alibaba</groupId>
                  <artifactId>fastjson</artifactId>
                  <version>${fastjson.version}</version>
              </dependency>
              <dependency>
                  <groupId>org.json</groupId>
                  <artifactId>json</artifactId>
                  <version>${json.version}</version>
              </dependency>
  
              <dependency>
                  <groupId>commons-dbutils</groupId>
                  <artifactId>commons-dbutils</artifactId>
                  <version>${commons-dbutils.version}</version>
              </dependency>
  
              <dependency>
                  <groupId>com.alibaba.otter</groupId>
                  <artifactId>canal.client</artifactId>
                  <version>${canal.client.version}</version>
              </dependency>
  
              <dependency>
                  <groupId>com.github.xiaoymin</groupId>
                  <artifactId>knife4j-spring-boot-starter</artifactId>
                  <version>${swagger-version}</version>
              </dependency>
  
              <dependency>
                  <groupId>com.liuscoding</groupId>
                  <artifactId>service_base</artifactId>
                  <version>${project-version}</version>
              </dependency>
  
  
              <dependency>
                  <groupId>com.liuscoding</groupId>
                  <artifactId>common_utils</artifactId>
                  <version>${project-version}</version>
              </dependency>
          </dependencies>
      </dependencyManagement>
  ```

  

### 创建common

#### 创建common_utils

在common下面

#### 创建service_base

### 创建service

### 创建数据库

创建：guli_edu

导入：guli_edu.sql

## 课程中心微服务

### 添加代码生成器

### 配置Swagger2

#### 添加依赖

```
        <!--swagger-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
        </dependency>
```

#### 创建Swagger2配置文件

##### 基本配置

```java
package com.zjd.guli.service.base.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import javax.print.Doc;

/**
 * @program guli_parent
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/06/16 20:02
 */

@Configuration
@EnableSwagger2
public class Swagger2Config {

    @Bean
    public Docket webApiConfig() {
        return new Docket(DocumentationType.SWAGGER_2);
    }
}

```

##### 接口分组

```java
package com.zjd.guli.service.base.config;

import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import javax.print.Doc;

/**
 * @program guli_parent
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/06/16 20:02
 */

@Configuration
@EnableSwagger2
public class Swagger2Config {

    @Bean
    public Docket webApiConfig() {
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .select()
                .paths(Predicates.and(PathSelectors.regex("/api/.*")))
                .build();
    }

    @Bean
    public Docket adminApiConfig() {
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("adminApi")
                .select()
                .paths(Predicates.and(PathSelectors.regex("/admin/.*")))
                .build();
    }
}

```

##### 添加info

```java
package com.zjd.guli.service.base.config;

import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import javax.print.Doc;

/**
 * @program guli_parent
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/06/16 20:02
 */

@Configuration
@EnableSwagger2
public class Swagger2Config {

    @Bean
    public Docket webApiConfig() {
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .apiInfo(webApiInfo())
                .select()
                .paths(Predicates.and(PathSelectors.regex("/api/.*")))
                .build();
    }

    @Bean
    public Docket adminApiConfig() {
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("adminApi")
                .apiInfo(adminApiInfo())
                .select()
                .paths(Predicates.and(PathSelectors.regex("/admin/.*")))
                .build();
    }

    private ApiInfo webApiInfo() {
        return new ApiInfoBuilder().title("网站的API文档")
                .description("本文档描述了谷粒学院网站的API接口定义")
                .version("1.0")
                .contact(new Contact("name", "http://github.com/Zjd1996", "775316284@qq.com"))
                .build();
    }

    private ApiInfo adminApiInfo() {
        return new ApiInfoBuilder().title("网站后台管理系统的API文档")
                .description("本文档描述了谷粒学院网站的后台管理系统API接口定义")
                .version("1.0")
                .contact(new Contact("name", "http://github.com/Zjd1996", "775316284@qq.com"))
                .build();
    }
}

```

#### 常见注解

代码生成器已经生成好。

Entity:

- @ApiModel

- @ApiModelProperty(value = "描述", example = "ddd")

Controller：

- @ApiOperation("这个功能")
- @ApiOperation(value = "", note = "")
- 参数：@ApiParam("xxx")
- 类：@Api(description = "xxx")

### 非业务功能统一返回

#### 统一返回结果

- 列表
- 分页
- 成功
- 失败

定义：

```
{
	"success": 布尔,
	"code": 数字,
	"message": 字符串,
	"data": HashMap 返回数据
}
```

#### 分页和条件查询

Page<>\IPage<>

Wrapper ..

#### 新增和修改

##### 新增

- 自动填充

```java
package com.zjd.guli.service.base.handler;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.util.Date;

/**
 * @program guli_parent
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/06/16 21:08
 */
@Component
public class CommonMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        this.setFieldValByName("gmtCreate", new Date(), metaObject);
        this.setFieldValByName("gmtModified", new Date(), metaObject);
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("gmtModified", new Date(), metaObject);
    }
}

```

#### 统一异常

##### 普通异常

```
package com.zjd.guli.service.base.handler;

import com.zjd.guli.common.base.result.R;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * @program guli_parent
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/06/16 21:18
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    @ResponseBody
    public R error(Exception e) {
        e.printStackTrace();
        return R.error();
    }
}

```

##### 特殊异常

```
package com.zjd.guli.service.base.handler;

import com.zjd.guli.common.base.result.R;
import com.zjd.guli.common.base.result.ResultCodeEnum;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.jdbc.BadSqlGrammarException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * @program guli_parent
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/06/16 21:18
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    @ResponseBody
    public R error(Exception e) {
        e.printStackTrace();
        return R.error();
    }


    @ExceptionHandler(BadSqlGrammarException.class)
    @ResponseBody
    public R error(BadSqlGrammarException e) {
        e.printStackTrace();
        return R.setResult(ResultCodeEnum.BAD_SQL_GRAMMAR);
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    @ResponseBody
    public R error(HttpMessageNotReadableException e) {
        e.printStackTrace();
        return R.setResult(ResultCodeEnum.JSON_PARSE_ERROR);
    }


}

```

##### 自定义异常

。。。

#### 统一日志处理

日志级别：FATAL、ERROR、WARN、INFO、DEBUG

默认logback，比log4j效率高

```
logging:
	level:
		root: ERROR
```

彩色插件：grep Console

##### logback配置

创建日志配置文件：logback-spring.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration  scan="true" scanPeriod="10 seconds">

    <contextName>logback</contextName>

    <property name="log.path" value="${user.home}/log/guli_log/edu" />

    <!--控制台日志格式：彩色日志-->
    <!-- magenta:洋红 -->
    <!-- boldMagenta:粗红-->
    <!-- cyan:青色 -->
    <!-- white:白色 -->
    <!-- magenta:洋红 -->
    <property name="CONSOLE_LOG_PATTERN"
              value="%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)"/>

    <!--文件日志格式-->
    <property name="FILE_LOG_PATTERN"
              value="%date{yyyy-MM-dd HH:mm:ss} |%-5level |%thread |%file:%line |%logger |%msg%n" />

    <!--编码-->
    <property name="ENCODING"
              value="UTF-8" />

    <!--输出到控制台-->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <!--日志级别-->
            <level>DEBUG</level>
        </filter>
        <encoder>
            <!--日志格式-->
            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>
            <!--日志字符集-->
            <charset>${ENCODING}</charset>
        </encoder>
    </appender>

    <!--输出到文件-->
    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--日志过滤器：此日志文件只记录INFO级别的-->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_info.log</file>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${ENCODING}</charset>
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 每天日志归档路径以及格式 -->
            <fileNamePattern>${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>500MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
    </appender>

    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 日志过滤器：此日志文件只记录WARN级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>WARN</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_warn.log</file>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${ENCODING}</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
    </appender>

    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 日志过滤器：此日志文件只记录ERROR级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_error.log</file>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${ENCODING}</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
    </appender>

    <!--开发环境-->
    <springProfile name="dev">
        <!--可以灵活设置此处，从而控制日志的输出-->
        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="INFO_FILE" />
            <appender-ref ref="WARN_FILE" />
            <appender-ref ref="ERROR_FILE" />
        </root>
    </springProfile>

    <!--生产环境-->
    <springProfile name="pro">
        <root level="ERROR">
            <appender-ref ref="ERROR_FILE" />
        </root>
    </springProfile>

</configuration>
```

注意：在统一普通异常处理时，error被捕获，如需打印需调整

```java
...
```

#### 自动完成功能

## 前端

### 基本

#### JS

JavaScript解析引擎：Chrome浏览器内置V8引擎

Node.js是基于V8引擎的JavaScript的运行环境，即Node.js内置了V8，可以在Node.js环境中直接运行JavaScrip程序。

区别：Node.js没有浏览器API，没有document、window等；增加了Node.js的专属API，例如文件系统，进程，http等。

有什么用：开发类似JavaWeb的简单的后端程序；部署高性能服务，通常作为一个BFF层，即Backend For Frontend（服务于前段的后端），即专门用于为前段业务提供数据的后端程序。

BFF：多个后端的数据聚合；一个后端的一种数据的分类分发适配（多端，手机、pad、PC）。（用户体验适配器）

![image-20200616233621820](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200616233621820.png)

ECMAScript 6：JavaScript下一代版本，ECMAScript是规格，JavaScript是一种实现。（另外还有Jscript、ActionScript，新特性：

- let与var
- const
- 解剖赋值
- 模版字符串

```
let name = 'zjd'
let info = `wojiao ${name}`
```

- 声明对象简写：

  ```javascript
  let age = 18
  let name = 'aa'
  let person = {
  	age: age
  	name: name
  }
  
  ---------------
  
  let person = {
  	age,
  	name
  }
  ```

- 定义方法简写：

  ```javascript
  let person = {
  	name: 'zz'
  	sayHi: function(){
  		console.log('hi')
  	} 
  }
  
  ------
  
  let person = {
  	name: 'zz'
  	sayHi(){
  		console.log('hi')
  	} 
  }
  ```

- 对象扩展运算符

  ```javascript
  let person = {
  	......
  }
  
  let someone = person // 指向同一内存
  
  let someone = {...person} // 拷贝复制
  ```

- 函数的默认参数

  ```javascript
  function showInfo(name, age = 25){ //没传时用默认值
  	....
  }
  
  
  /// 不存在方法重载，后定义的覆盖先定义的
  // 函数在js中也是一种数据类型
  ```

- 箭头函数（Lambda）

  ```javascript
  let arr = ['10','5','7']
  arr.sort()
  console.log(arr)
  
  
  arr.sort(function(a,b) {
      return a - b   // 字符串减，先转成数值，再计算
  })
  console.log(arr)
  
  ------ 箭头函数
  arr.sort((a,b) => {
      return a - b   // 字符串减，先转成数值，再计算
  })
  
  arr.sort((a,b) => {
      return a - b   // 字符串减，先转成数值，再计算
  })
  
  ```

  

#### Vue.js

JavaScript的前端框架，目的是简化Web开发。关注MVC模式中的视图层，能方便地获取数据更新，实现视图与模型的交互。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app">
        <!-- 插值表达式，声明式渲染，绑定data中的数据 -->
        {{message}}
    </div>
    <script src="vue.min.js"></script>
    <script>
        new Vue({
            el: '#app',

            // 数据模型定义
            data: {
                message: 'hello Vue'
            }
        })
    </script>
</body>
</html>
```



#### axios

ajax类似。独立于vue的项目，用于浏览器和node.js中发送ajax请求。

```java
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app">
        <!-- 显示讲师列表 -->
        <button @click="getTeacherList">获取讲师列表</button>
        <table>
            <tr v-for="item in teacherList">
                <td>{{item.name}}</td>
                <td>{{item.level}}</td>
            </tr>
        </table>

    </div>
    <script src="vue.min.js"></script>
    <script src="axios.min.js"></script>
    <script>
        new Vue({
            el: '#app',
            data() {
                return {
                    teacherList: []
                }
            },
            created(){
                this.getTeacherList()
            },
            methods: {
                getTeacherList() {
                    console.log("获取讲师列表")
                    axios.get('http://localhost:8080/admin/edu/teacher/list').then(response => {
                        console.log(response)
                        this.teacherList = response.data.data.items
                    })
                }
            }
        })
    </script>
</body>
</html>
```

##### 分层开发

// 基础配置



// api调用



// 数据渲染

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app">
        <!-- 显示讲师列表 -->
        <button @click="getTeacherList">获取讲师列表</button>
        <table>
            <tr v-for="item in teacherList">
                <td>{{item.name}}</td>
                <td>{{item.level}}</td>
            </tr>
        </table>

    </div>
    <script src="vue.min.js"></script>
    <script src="axios.min.js"></script>
    <script>
        new Vue({
            el: '#app',
            data() {
                return {
                    teacherList: []
                }
            },
            created(){
                this.getTeacherList()
            },
            methods: {
                getTeacherList() {
                    console.log("获取讲师列表")
                    axios.get('http://localhost:8080/admin/edu/teacher/list').then(response => {
                        console.log(response)
                        this.teacherList = response.data.data.items
                    })
                },

                // 基础配置
                initRequest(){
                    return axios.create({
                        baseURL: 'http://localhost:8080',
                        timeout: 5000
                    })
                },

                // api调用
                teacherListApi() {
                    let request = this.initRequest()
                    return request({
                        url: '/admin/edu/teacher/list',
                        method: 'get'
                    })
                },

                // 数据渲染
                getTeacherList2() {
                    this.teacherListApi().then(response => {
                        console.log(response)
                        this.teacherList = response.data.data.items
                    })
                }
            }
        })
    </script>
</body>
</html>
```

#### element-ui



#### NPM

前端项目的依赖管理工具，相当于前端的maven。

装了Node.js自带了NPM。

换源。

```
npm config set registry https://registry.npm.taobao.org
npm config list
```

下载依赖

```
当前项目：目录
npm install jquery
npm install jquery@2.1.x


开发依赖
npm install --save-dev eslint


全局：全局用户目录
npm isntall --global webpack
```

#### 模块化

#### WebPack

js打包

css打包

```
安装loader
npm install -D style-loader css-loader

配置webpack.config.js
```

#### Vue-element-admin

基于element-ui和vue的一套后台管理系统集成方案。

#### Eslint

vdcode插件，代码检查，高亮

#### 路由

''#''  锚点

![image-20200617165318257](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200617165318257.png)

#### 组件

form.vue...



### 讲师前端开发

单页应用

- 创建路由
- 创建api
- 创建页面组件
  - 页面模版
  - 页面脚本

![image-20200617214039390](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200617214039390.png)

## OSS服务

- 确认一些常量

  - EndPoint
  - bucketName
  - AccessId
  - AccessKeySecret

  

## 云存储微服务

- 配置常量
- 读入常量
- 前端整合头像上传
- 自定义异常

## 注册中心

![image-20200618200026998](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618200026998.png)

### 版本选择

- springboot：2.2.2

### Nacos注册中心

Eureka：是Spring Cloud Netflix中的重要组件，主要做服务注册和发现

Consul：基于Go，面向分布式、服务化的系统提供服务注册、服务发现和配置管理功能

Zookeeper：zookeeper是一个分布式服务框架，是Apache Hadoop的一个子项目

Nacos：（Spring Cloud Alibaba）

- Alibaba针对Spring Cloud体系的注册中心
- 相对于Spring Cloud Eureka来说，Nacos更强大
- Nacos=Spring Cloud Eureka + Spring Cloud Config + Spring Cloud Bus

名字：

- Naming Configuration Service。 Na Co s

- 注册中心+配置中心的组合

```
 Nacos 1.1.4
  6 ,`--.'`|  ' :                       ,---.               Running in stand alone mode, All function modules
  7 |   :  :  | |                      '   ,'\   .--.--.    Port: 8848
  8 :   |   \ | :  ,--.--.     ,---.  /   /   | /  /    '   Pid: 16241
  9 |   : '  '; | /       \   /     \.   ; ,. :|  :  /`./   Console: http://192.168.1.101:8848/nacos/index.html
 10 '   ' ;.    ;.--.  .-. | /    / ''   | |: :|  :  ;_
 11 |   | | \   | \__\/: . ..    ' / '   | .; : \  \    `.      https://nacos.io
```

### 服务注册

- service模块中配置Nacos客户端的pom

  ```
  <!--        服务注册-->
          <dependency>
              <groupId>com.alibaba.cloud</groupId>
              <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
          </dependency>
  ```

- 添加服务配置信息，配置app.yml

  ```
  spring:
  	cloud:
      	nacos:
        		discovery:
          		server-addr: localhost:8848
  ```

- 添加客户端注解，启动类

- 启动

### OpenFeign

Spring Cloud提供的一个声明式的伪Http客户端，它使得调用远程服务可以像本地服务一样，只需要创建一个接口并添加一个注解。

Nacos兼容了OpenFeign，OpenFeign默认继承了Ribbon（实现负载均衡效果）

- 引入依赖(服务消费者，这里是edu消费oss)

  ```
          <!--服务调用-->
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-starter-openfeign</artifactId>
          </dependency>
  ```

- 启动类@EnableFeignClients

测试：

```
// 生产者
@ApiOperation(value = "服务调用测试")
    @GetMapping("test")
    public R test() {
        log.info("oss test called");
        return R.ok();
    }
    

// 消费者调用 通过service名字 + 路径即可调用
    package com.zjd.guli.service.edu.feign;

import com.zjd.guli.common.base.result.R;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@Service
@FeignClient("service-oss")
public interface OssFileService {

    @GetMapping("/admin/oss/file/test")
    R test();
}

service注入到teacherController


```

### 负载均衡

配置多实例：![image-20200618211717583](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618211717583.png)

默认：轮训访问策略

Ribbon负载均衡策略：

![image-20200618211924561](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618211924561.png)

![image-20200618212240034](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618212240034.png)

### OpenFeign的超时控制

默认1s。

模拟长流程业务。

```
ribbon:
  maxAutoRetries: 0  # 同一实例最大重复调用，默认0
  maxAutoRetriesNextServer: 1 # 重试其他实例的的最大重试次数，不包括首次所选的server，默认1
  ConnectTimeout: 5000 # 连接建立的超时 默认1s
  ReadTimeout: 5000 # 处理请求的超时 默认1s
```

### Sentinel服务容错

#### 服务雪崩



调整tomcat并发：

```
server:
	tomcat:
		max-thread: 10 // 默认200
```

并发访问工具：jmeter

#### 容错方案

防止雪崩的扩散，就要做好服务的容错：保护不被影响。

常见：隔离、超时、限流、熔断、降级

##### 隔离

将系统按照一定的原则划分为若干个服务模块，相对独立，无强依赖。当故障时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其他模块，不影响整体的系统服务。

常见的：线程池隔离和信号量隔离。

![image-20200618231455770](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618231455770.png)

不同线程池，每个线程池处理一个方法。

##### 超时

上游服务调用下游服务，设置一个最大响应时间，如果超时，就断开请求，释放线程。

![image-20200618231604397](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618231604397.png)

##### 限流

限制系统的输入和输出流量。一旦达到阈值，就采取相应措施完成限制流量的目的。

![image-20200618231649169](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618231649169.png)

##### 熔断

下流服务因为访问压力过大而相应失败或变慢，上游服务为了保护系统整体可用性，可以暂时切断对下游服务的调用。**牺牲局部，保全整体。**

![image-20200618231746344](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618231746344.png)

##### 降级

一旦服务无法正常调用，托底方案。

![image-20200618231812553](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618231812553.png)

#### 容错组件

- Hystrix：停更
- Resilience4J：官方提供
- Sentinel：阿里巴巴开源的一款断路器实现

#### Sentinel介绍

Sentinel（分布式系统的流量防卫兵），阿里开源的用于服务容错的综合解决方案。以流量为切入点，以流量控制、熔断降级、系统负载保护等多个维度来保护服务的稳定性。

- 丰富的应用场景：双十一、秒杀
- 完备的实时监控：提供实时监控，通过控制台可以看到介入应用的单台机器秒级数据，甚至500台以下规模的集群的汇总运行情况。
- 广泛的开源生态：开箱即用，与其他的整合
- 完善的扩展点

组成：

- 核心库（Java客户端）：不依赖任何框架/库
- 控制台（DashBoard）：基于Springboot，打包直接运行

##### Sentinel控制台

- 运行jar

- 引入依赖

  ```
          <!--服务容错-->
          <dependency>
              <groupId>com.alibaba.cloud</groupId>
              <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
          </dependency>
  ```

- 微服务连接控制台

  ```
  spring:
    cloud:
      sentinel:
        transport:
          port: 8081 # 控制台交流的端口，随意
          dashboard: localhost:8080 # 控制台地址
  ```

  ![image-20200618233843778](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618233843778.png)

- 例子：实现流控![image-20200618234412634](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618234412634.png)![image-20200618234420222](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618234420222.png)

##### 基本概念

1. 资源：就是Sentinel要保护的东西，可以时任何内容，服务、方法、代码
2. 规则：定义如何进行保护资源，通过簇点链路设置

##### 重要功能

![image-20200618234559792](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200618234559792.png)

1. 流量控制：保证自己不被上游服务压垮（流控，调整为合适的形状）
2. 熔断降级：保证自己不被下油服务拖垮（下游链路不稳定，快速失效）
3. 系统负载保护：保证外界环境良好（CPU、内存）

#### OpenFeign整合Sentinel

- 引入Sentinel依赖

- 开启Sentinel支持（yml）

  ```
  feign:
    sentinel:
      enabled: true
  ```

- 创建熔断类
- 指定熔断类

## Alibaba EasyExcel

Excel应用：

- 数据导入
- 数据导出
- 数据传输（异构系统之间数据传输）

poi：apache，数据类型处理麻烦，效率低

Easy Excel：阿里开源，速度快，使用简单、节省内存，没有一次性将文件数据全部加载，而是逐行解析。解析结果以观察者模式通知处理。

创建maven项目

## 课程分类管理

包括Excel导入和导出。

打包时包含xml。

```
<build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
    </build>
    
    
# yml    
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 日志
  mapper-locations: classpath:com/zjd/guli/service/edu/mapper/xml/*.xml
```

## 课程管理

富文本：tinymce



## 章节管理



## 课时管理

阿里云视频点播，VOD![image-20200620005131727](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200620005131727.png)

### 视频上传

视频播放器。

### 视频删除（课时、章节、课程删除时同时删除视频）

## SEO-搜索引擎优化

![image-20200621142318156](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200621142318156.png)

### 服务器端渲染与客户端渲染

服务器端渲染SSR：在服务端完成页面渲染（jsp、thymeleaf），对搜索引擎友好，对爬虫友好



![image-20200621143201835](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200621143201835.png)



客户端浏览器渲染：使用ajax向服务器端发起http请求，

![image-20200621143650443](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200621143650443.png)

客户端渲染：不利于SEO，大量使用js，不利于搜索引擎抓取网页；优点，客户端负责渲染，用户体验好，服务端只提供数据不关心用户界面的恶内容，有利于提高服务端的开发效率。适用电商后台、用户管理等

服务端渲染：有利于SEO，服务端完成一部分客户端的工作，通常完成一个需求要修改客户端和服务端代码，开发效率低，不利于系统的稳定性，难以前后端分离），适用门户首页，商品详情页

### Nuxt.js

![image-20200621210649762](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200621210649762.png)

前端服务器渲染。（前后端分离，返回html，优化SEO）

Nuxt.js是基于Vue的轻量级应用框架，可以用来创建服务器端（前端服务器）渲染（SSR）应用，也可以充当静态站点引擎，生成静态站点应用，具有优雅的代码结构分层和热加载等特性

### 前端页面

## CMS模块

内容管理系统

## 集成Redis

首页数据变化不频繁，首页访问量相对较大，有必要把首页数据缓存到redis中，减少数据库压力和提高访问速度。

### RedisTemplate

是Spring Data Redis中对Jedis api（lu）的高度封装。

josn序列化。(避免jdk的序列化)

引入：

```
<!-- spring boot redis缓存引入 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- lecttuce 缓存连接池-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
```

添加连接配置，cms和edu配置config

```java
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory connectionFactory){

        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(connectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer()); //key的序列化
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); //value序列化
        return redisTemplate;
    }

    
    // 查，不存在，读数据库，存redis
    // 之后，查 读缓存
    @Bean
    public CacheManager cacheManager(LettuceConnectionFactory connectionFactory) {

        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                //过期时间600秒
                .entryTtl(Duration.ofSeconds(600))
                // 配置序列化
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()))
                .disableCachingNullValues();

        RedisCacheManager cacheManager = RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }
}

```

### 使用缓存注解

@EnableCaching在Redis配置类上。

## 短信微服务

阿里云短信服务

## 用户中心微服务

### 用户身份认证模式

#### 单一服务器模式

![image-20200622153206496](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622153206496.png)

![image-20200622153043670](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622153043670.png)

缺点：

- 单点性能压力，无法扩展
- 分布式集群、微服务的场景下需要session共享（session共享也是一个瓶颈）

#### 单点登录模式

![image-20200622153730874](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622153730874.png)

- 外部的缓存代替tomcat内缓存
- 统一的认证中心

#### Token模式（SSO的变种）

![image-20200622154714487](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622154714487.png)

携带token，不需要在redi存了，也不需要麻烦认证中心了。

![image-20200622154851306](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622154851306.png)

![image-20200622155240423](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622155240423.png)

优点：

- token无状态，session有状态
- 基于标准化，API可以采用标准化的JSON Web Token（JWT）

缺点：

- 每次携带占用带宽（还好）
- 无法在服务器端销毁

#### 访问令牌类型

By reference token：随机生成的字符串标识符，无法简单猜测授权服务器如何颁发和存储；资源服务器必须通过后端渠道发送回OAuth2授权服务器的令牌检查端点，才能校验令牌是否有效，并获取claims/scopes等额外信息。

By value token：授权服务器办法的令牌，包含关于用户或者客户的元数据和声明（claims）。通过检查签名，期望的颁发者（issuer），期望的接收人aud（audience），或者scope，资源服务器可以在本地校验令牌，通常实现为签名的JOSN Web Tokens（JWT）

#### JWT令牌

自包含令牌。

使用场景：

- 一种情况是webapi，类似阿里云播放凭证
- 另一种情况是多web服务器下实现无状态分布式身份验证，官网的过程：![image-20200622160214956](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622160214956.png)

JWT最重要的作用就是对token信息的防伪。

原理：

- 一个JWT由三个部分组成：JWT头部，有效载荷、签名哈希
- 最后由这三者组合进行base64编码得到jwt。

![image-20200622162431761](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622162431761.png)

![image-20200622162541377](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622162541377.png)

![image-20200622162606559](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622162606559.png)

![image-20200622162853224](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622162853224.png)

![image-20200622162925358](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622162925358.png)

![image-20200622163327569](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622163327569.png)

#### JWT的用法

客户端接收服务器返回的JWT，存储在Cookie或者localStorage中。

伺候客户端将在服务器交互中都会带JWT，如果将它存储在Cookie中，就可以自动发送，但是不会夸鱼，因此一般是将它放入http请求的Header Authorization字段中。

当跨域时，也可以将JWT被放置于POST请求的数据主体中，

#### JWT的问题和趋势

1. JWT默认不加密，但是可以加密，生成原始令牌后，可以使用该令牌再次对其进行加密
2. 当JWT未加密时，一些私密数据无法通过JWT传输
3. JWT不仅可以用于认证，还可以用于信息交换。善用JWT有助于减少服务器请求数据库的次数
4. 最大的缺点时服务器不回保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效
5. JWT本身包含认证信息，因此一旦泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长，对于某些重要操作时，用户在使用时应该每次都进行身份验证
6. 为了建好盗用和窃取，建议使用加密的HTTPS协议进行传输。

#### 引入

```
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
            <version>0.7.0</version>
        </dependency>
```

```java
public class JwtUtils {
	public String static genJwt(String id, String nickName, String avatar) {
        JwtBuilder builder = new JwtBuilder();
        
        builder.setHeaderParam("alg", "HS256"); // 这两是默认的，可以不写
        builder.setHeaderParam("typ", "JWT"); // 
		
        // 默认字段
        builder.setId("aa"); // 唯一身份表示，避免重放攻击
        builder.setSubject("guli-user");
        builder.setIssueDate(new Date()); 
        builder.setExpiration(new Date( curr + ex));
        
        builder.claim("id", id);
        builder.claim("nickName", nickName);
        builder.claim("avatar", avatar);
        
        // 签名哈希
        builder.signWith(SignaturaAlgorithm.HS256, sercet);
        
        // 连接起来
        String token = builder.compact();
        return token;

    }
    
    
    public static Claims checkJwt(String token) {
        JwtParser parser = Jwts.parser();
        Jws<Cliams> clamsJws.= parser.setSigningKey(secret).parseClaimsJws(token);
        Claims body = claimsJws.getBody();
        
        return Claims;
    }
}
```

### 微信登录-OAuth2

照片拥有者想在云冲印服务上打印照片，云冲印服务需要访问云存储服务上的资源。

![image-20200622190957110](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622190957110.png)

- 受保护的资源：照片
- 客户应用：云冲印
- 资源拥有者：照片拥有者

云存储的权限开放给云冲印～

OAuth2之前：

- 办法一：密码用户名复制![image-20200622191229235](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622191229235.png)![image-20200622191530567](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622191530567.png)
- 办法二：万能钥匙-通用开发者key![image-20200622191616620](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622191616620.png)
- 办法三：特殊令牌![image-20200622191738400](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622191738400.png) 

- OAuth2:令牌，定义标准，定义令牌生成的形式![image-20200622191941851](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622191941851.png)

  ![image-20200622192035573](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622192035573.png)

![image-20200622192650097](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622192650097.png)

RFC 6749，OAuth2.0授权框架。

#### 准备工作

微信开放平台

## 订单与支付

创建service_trade模块。

定义dto对象，Data Transfer Object， trade要远程调用edu，返回Course课程信息

例如：CourseDto





## Api网关

现在访问各个微服务，都硬编码了地址，现在使用网关替我们发起。

![image-20200622223601464](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200622223601464.png)

### Spring Cloud Gateway

![image-20200623154626633](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623154626633.png)

![image-20200623154702574](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623154702574.png)

![image-20200623154825679](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623154825679.png)

![image-20200623155213552](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623155213552.png)





![image-20200623155230400](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623155230400.png)

### 创建父模块infrastructure

### 创建api_gateway子模块

pom：

```
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
    </dependencies>
```



### 配置路由和断言

yml

```
spring:
 cloud:
    gateway:
      routes:
      - id: service-edu
        uri: http://localhost:8380
        predicates:
        - Path=/user/** # 路径断言
```

 



服务注册

```
<!--服务注册-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>

@EnableDiscoeryClient



spring:
  profiles:
    active: dev
  application:
    name: infrastructure-gateway
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
    gateway:
      discovery:
        locator:
          enabled: true # gateway可以发现nacos中的微服务
      routes:
      - id: service-edu # 随便起
        uri: lb://service-edu # 指定    lb表示使用负载均衡
        predicates:
        - Path=/user/** # 路径断言
```

前端api可以改成网关端口。

- 不仅有路径断言，还-有时间断言After/Before![image-20200623173407626](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623173407626.png)

- 基于远程地址断言：- RemoteAddr=192.111.11.11
- 基于Cookie断言：- Cookie=chocolate, ch
- 基于Header断言：- Header=X-Request-Id, \d+
- 基于Host断言：- Host=**.testhost.org
- 基于method断言：- Method=GET
- 基于Path路径
- 基于Query请求：- baz, ba.
- 基于路由权重：可以做限流、负载均衡![image-20200623173808532](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623173808532.png)
- 了解一下

### 跨域

config：可以删掉croso注解

```
package com.zjd.guli.infrastucture.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import org.springframework.web.util.pattern.PathPatternParser;

/**
 * @program guli_parent
 * @description:
 * @author: zhaojiangdong
 * @create: 2020/06/23 17:04
 */
@Configuration
public class CorsConfig {

    @Bean
    public CorsWebFilter corsFilter() {

        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedMethod("*");
        config.addAllowedOrigin("*");
        config.addAllowedHeader("*");

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration("/**", config);

        return new CorsWebFilter(source);
    }
}

```



### 过滤器

在请求传递过程中，对请求和响应做一些修改

生命周期：![image-20200623174012432](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623174012432.png)

![image-20200623174135079](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623174135079.png)

内置的局部过滤器：直接yml可以配置![image-20200623174147912](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623174147912.png)

全局过滤器：例如lb://xxx。使用负载均衡策略

![image-20200623174429267](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623174429267.png)

#### 自定义全局过滤器

定一个Filter实现GlobalFilter接口和Orderd

实现网关鉴权。

依赖：

```
<dependency>
            <groupId>com.zjd</groupId>
            <artifactId>common_util</artifactId>
            <version>0.0.1-SNAPSHOT</version>
            <!--排除spring-boot-starter-web，否则和gateway中的webflux冲突-->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-web</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!--将随着spring-boot-starter-web排除的servlet-api添加回来 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
            <scope>provided</scope>
        </dependency>

        <!--gson-->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
        </dependency>
    </dependencies>
```

创建过滤器



### 数据统计

### 定时任务

![image-20200623190548808](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623190548808.png)

Spring task

```
@EnableScheduling
```

## ECharts



百度的产品。





## Nacos配置中心

![image-20200623193727018](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623193727018.png)

![image-20200623193750584](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623193750584.png)

![image-20200623193925779](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200623193925779.png)

配置bootstrap。yml

nacos添加配置

配置动态刷新：

- controller类上 添加注解，@RefreshScope

多环境配置：

- 添加active属性
- nacos添加service-sms-dev.yml





学生表和成绩表，查每个学生的最高成绩：

select st.name, (select max(sc.score) from score sc where sc.id=st.id) as score from student st;

select st.name, res.score from student st left join (select id, max(score) as score from score group by id) as res on st.id = res.id; // 子查询



---

select st.name, max(sc.score) from student st left join score sc on st.id = sc.id group by st.id, st.name; //现在版本你可用

select st.name, max(sc.score) from student st left join score sc on st.id = sc.id group by st.id; //之前版本可用

报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'sqltest.st.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

