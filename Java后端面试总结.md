# Java后端面试

[TOC]



## 操作系统

### 概述

- 操作系统用来协调软件与底层硬件，相当于彼此的接口。
- 操作系统有进管理、内存管理、文件管理、输入输出管理。

#### 基本特征

##### 并发

并发指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

操作系统引入进程和线程，是的程序能够并发执行

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

##### 共享

共享指系统中的资源可以被多个并发进程共同使用，两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

##### 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

##### 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

#### 基本功能

##### 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等

##### 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等

##### 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等

##### 设备管理

完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虚拟设备等

#### 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用而陷入内核，由操作系统代为完成。

![tGPV0](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png)

Linux的系统调用主要有：

| Task     | Commands                   |
| -------- | -------------------------- |
| 进程控制 | fork();exit();wait();      |
| 进程通信 | pipe();shmget();mmap();    |
| 文件操作 | open();read();write();     |
| 设备操作 | ioctl();read();write();    |
| 信息维护 | getpid();lalarm();sleep(); |
| 安全     | chmod();umask();chown();   |

##### fork（）系统调用的过程

linux下创建新进程的系统调用是fork()：

```c++
#include <unistd.h>
pid_t fork(void);
```

函数每次调用都返回两次，父进程返回的是子进程的PID，子进程返回0。该返回值是后续代码判断当前进程是父进程还是子进程的依据。fork失败时返回-1，并设置errno。

fork函数复制当前进程，在内核进程表中创建一个新的表项。

子进程代码和父进程代码完全相同，同时它还会复制父进程的数据（堆数据、栈数据和静态数据）。数据的复制采用的是**写时复制**，即只有在任一进程（父进程或者子进程）对数据执行了写操作时，复制才会发生。

此外创建子进程后，父进程打开的文件描述符（在fork之前打开的文件）在子进程中也是打开的，并且共享文件读写偏移量，且文件描述符的引用计数加1。

**问题**

1. 如果在fork之前进行了char *p=malloc(1024);操作，则子进程也继承这部分内存空间，因为两个进程有各自的虚拟空间，所有两个进程p的地址一样，但是进行读写操作时会对应到不同的物理地址。如果在fork之前执行了char *p=malloc(1024)操作，并且执行了strcpy(p,"hello");，如果这两个进程读这部分物理内存数据时，此时物理内存只有一份数据，而如果一个进程有写操作时，会复制一份到当前进程的物理内存（写时复制）。
2. 子进程的执行位置就是fork()之后的位置，这是因为子进程继承了父进程的PC程序计数器。
3. 在fork之前执行fp = fopen("a.dat","w")；则父进程共享文件描述符和文件偏移量。如果子进程写入数据，父进程要读取的话需要调用lseek函数。而如果实在fork之后打开文件，则此时父子进程不共享文件描述符。
4. 一个fork之后，变为两个进程，这两个进程再执行自己的fork，就会有4个进程



#### 大内核和微内核

##### 大内核

大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于模块共享信息，因此有很高的性能。

##### 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和和心态之间进行切换，所以有一定的性能损失。

![2_14_microkernelArchitecture](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg)

#### 用户态和内核态的区别

在计算机系统中，运行着两类程序：系统程序和应用程序。**为保证系统程序不被应用程序有意或无意地破坏**，为计算机设置了两种状态：

- 系统态（管态、核心态、内核态），操作系统在系统态运行——运行操作系统程序。处于内核态的进程，能访问所有的内存空间和对象，且所占用的处理机是不允许被抢占的
- 用户态（目态），应用程序只能在用户态运行—运行用户应用程序。处于用户态的进程，能访问的内存空间和对象受限制，其所占有的处理机是可被抢占的

用户态与内核态的切换：

- 用户态切换到内核态的途径——中断（IO）/异常（缺页等）/陷入（系统调用，陷入指令（访管指令））
- 内核态切换到用户态的途径——设置程序状态字

相应地，现代操作系统将CPU指令集分为特权指令和非特权指令：

- 特权指令：在内核态时运行的指令（对于那些危险的指令，只允许操作系统及其相关模块使用）
  - 对内存空间的访问范围基本不受限制，不仅能访问用户存储空间，也能访问系统存储空间
  - 特权指令只允许操作系统使用，不允许应用程序使用，否则会引起系统混乱
- 非特权指令：在用户态时运行的指令
  - 一般应用程序所使用的都是非特权指令，它只能完成一般性的操作和任务，不能对系统中的硬件和软件直接进行访问，其对内存的访问范围也局限于用户空间。

#### 为什么要分用户态和内核态

由于需要**限制不同的程序之间的访问能力**, **防止他们获取别的程序的内存数据**, 或者**获取外围设备的数据, 并发送到网络**，或者**操作一些比较危险的指令**，CPU划分出两个权限等级 – 用户态和内核态。

当我们在写程序是，凡是涉及到IO读写、内存分配等硬件资源的操作时，往往不能直接操作，而是通过一种叫**系统调用**的过程，让程序陷入到内核态运行，然后内核态的CPU执行有关硬件资源操作指令，得到相关的硬件资源后在返回到用户态继续执行，之间还要进行一系列的数据传输。如此麻烦，让用户程序直接访问硬件资源不是更好吗？

​    假设没有这种内核态和用户态之分，程序随随便便就能访问硬件资源，比如说分配内存，程序能随意的读写所有的内存空间，如果程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。用户程序是不可信的，不管程序员是有意的还是无意的，都很容易将系统干到崩溃。

Intel就发明了ring0-ring3这些访问控制级别来保护硬件资源，ring0的就是我们所说的内核级别,要想使用硬件资源就必须获取相应的权限（设置PSW寄存器，这个操作只能由操作系统设置）。操作系统对内核级别的指令进行封装，统一管理硬件资源，然后向用户程序提供系统服务，用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。**内核态能有效保护硬件资源的安全。**

#### 中断分类（三种用户态转到内核态的最主要方式）

##### 外中断

由CPU执行指令以外的事件引起，如I/O完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断。

##### 异常（如缺页异常等）

由CPU执行指令的内部事件引起，如非法操作码、地址越界、算数溢出等。触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态。

##### 陷入（系统调用，用户进程主动发起）

在用户程序中使用系统调用。

### 进程管理

#### 进程与线程

##### 进程

进程是资源分配的基本单位。进程控制块（Process Control Block，PCB）描述进程的基本信息和运行状态，所谓创建进程和撤销进程，都是指对PCB的操作。

##### 线程

线程是独立调度的基本单位。

一个进程可以有多个线程，它们共享进程资源。

##### 进程与线程的区别

- **拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
- **调度差异**：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- **系统开销**：由于**创建或撤销进程**时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的**开销远大于创建或撤销线程的开销**。类似地，在进行**进程切换**时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而**线程切换**时只需要保存和设置少量寄存器内存，**开销很小**。
- **通信方面**：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。

- 进程是系统进行资源分配和调度的一个独立单位，最小的资源管理单位。
- 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，最小的CPU执行单元。线程拥有的资源：程序计数器、寄存器、栈、状态字。

#### 进程状态的切换

![ProcessState](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png)

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

注意：

- 只有就绪态和运行态可以相互转换，其他的都是单向转换。就绪状态的进程通过调度算法从而获得CPU事件，转为运行状态；而运行状态的进行，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行状态转为就绪态

#### 进程调度算法（操作系统CPU调度算法）

由于要执行的进程的数目多于处理器的数目，所以需要处理器决定下一次运行哪个进程（作业）。不同环境的调度算法目标不同，因此需要针对不同环境来讨论

##### 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）

- 先来先服务调度算法（first-come first-serverd,FCFS）：非抢占式，按照作业进入系统的自然次序（请求顺序）来调度作业。优点是实现简单、公平，利于长作业。缺点是没有考虑系统中各种资源的综合使用情况，不利于短作业，因为短作业等待处理的时间可能比实际运行时间长得多。
- 短作业优先调度算法（shortest job first,SJF）：非抢占，按估计运行时间最短的顺序进行调度，优先调度并处理短作业，短作业指运行时间短的作业。而作业未投入运行时，并不能知道它的实际运行时间，因此需要在用户提交作业的同时提交作业运行时间的估计值。长作业可能会饿死，处于一直等待短作业执行完毕的状态。
- 最短剩余时间优先算法（shortest remaining time next,SRTN）：短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果心的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。

- 最高响应比优先算法（HRN）：FCFS可能造成短作业用户不满，SJF可能使得长作业用户不满，HRN选择响应比最高的作业运行，响应比=1+作业等待时间/作业处理时间。

##### 交互式系统

交互式系统由大量的用户交互操作，在该系统中调度算法的目标是快速地响应。

- 优先级调度（HPF）：每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入并调入内存处理时，优先选择优先数最高的作业。为了防止低优先级的进程永远等不到调度，可以随着时间推移增加等待进程的优先级。

- 时间片轮转：适用于分时系统。系统将所有就绪进程按照到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务原则，但仅能运行一个时间片，在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。时间片轮转算法的效率和时间片的大小有很大关系：

  - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
  - 如果时间片过长，那么实时性就不能等到保证。

- 多级反馈队列：一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次。多级队列为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1，2，4，8。进程在第一个队列没执行完，就会被移到下一个对了，这种方式下100个时间片的进程只需要交换7次。组上面的队列优先级最高。是时间片轮转调度和优先级调度算法的结合。

  ![042cf928-3c8e-4815-ae9c-f2780202c68f](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png)

##### 实时系统

要求一个请求在一个确定的时间内得到响应。

分硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

#### 进程同步（PV信号量）

##### 临界区

对临界资源进程访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要进行检查。

##### 同步与互斥

同步：多个进程因为合作产生的直接制约关系，使得进程由一定的先后执行关系。

互斥：多个进程在同一时刻只有一个进程能进入临界区。

##### 信号量

信号量（Semaphore）是一个整型变量，可以对其执行down和up操作，即常见的P和V操作。

**什么是信号量**：信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。当S>0时，表示当前可用资源的数量；S<0时，其绝对值表示等待使用该资源的进程个数。注，信号量的值仅能由PV操作来改变。

PV操作由P操作原语和V操作原语组成（原语是不可中断的过程，屏蔽中断），对信号量进行操作，具体定义：

- P（S）：分配一个单位资源
  - 将信号量S值减1，即S = S - 1；
  - 如果S>=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。
- V（S）：释放一个单位资源
  - 将信号量S值加1；
  - 如果S>0，则该线程继续执行；否则释放队列中第一个等待信号量的进程。

**PV操作的意义**：我们用信号量及PV操作来实现进程的同步和互斥。属于进程的低级通信。

如果信号量的取值只能为0或者1，那么就成了互斥量（Mutex），0表示临界区已经加锁，1表示临界区解锁。

##### **使用信号量实现生产者-消费者问题**

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

##### 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也是的客户端代码调用更容易。

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其他进程永远不能使用管程。

管程引入了条件变量以及相关的操作：wait()和signal()来实现同步操作。对条件变量执行wait()操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal()操作用于唤醒被阻塞的进程。

**使用管程实现生产者-消费者问题**

```pascal
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

#### 经典同步问题

##### 生产者和消费者问题

##### 哲学家进餐问题





![a9077f06-7584-4f2b-8c20-3a8e46928820](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg)

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

错误的解法：如果每个哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其他哲学家吃完冰释放自己手中的筷子，导致死锁。

```c
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；

- 只有在两个邻居都没有进餐的情况下才允许进餐。

- ```c
  #define N 5
  #define LEFT (i + N - 1) % N // 左邻居
  #define RIGHT (i + 1) % N    // 右邻居
  #define THINKING 0
  #define HUNGRY   1
  #define EATING   2
  typedef int semaphore;
  int state[N];                // 跟踪每个哲学家的状态
  semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
  semaphore s[N];              // 每个哲学家一个信号量
  
  void philosopher(int i) {
      while(TRUE) {
          think(i);
          take_two(i);
          eat(i);
          put_two(i);
      }
  }
  
  void take_two(int i) {
      down(&mutex);
      state[i] = HUNGRY;
      check(i);
      up(&mutex);
      down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
  }
  
  void put_two(i) {
      down(&mutex);
      state[i] = THINKING;
      check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
      check(RIGHT);
      up(&mutex);
  }
  
  void eat(int i) {
      down(&mutex);
      state[i] = EATING;
      up(&mutex);
  }
  
  // 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
  void check(i) {         
      if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
          state[i] = EATING;
          up(&s[i]);
      }
  }
  ```

##### 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整型变量count记录在对数据进行读操作的进程数量，一个互斥量count_mutex用于对count加锁，一个互斥量data_mutex用于对读写的数据加锁。

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```

#### 进程通信*IPC*（Inter-Process Communication)

进程同步与进程通信的区别：

- 进程同步：控制多个线程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够到达进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

##### 管道（pipe）

半双工，数据单向流动，只能在有亲缘关系（通常指父子进程关系）的进程间使用。

![53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png)

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

数据的读出和写入：一个进程向管道中写的内容被管道另一段的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。（像队列）

该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义，因此，一个进程在由pipe()创建管道后，一般再fork一个进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在亲缘关系，这里的亲缘关系是指有共同的祖先，都可以采用管道方式来进行通信）。

向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。

注：只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的SIFPIPE信号，应用程序可以处理该信号，也可以忽略。（默认动作则是应用程序终止）

##### 有名管道（named pipe）/FIFO

同管道，它允许无亲缘关系的进程间通信。

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务进程之间传递数据。

![2ac50b81-d92a-4401-b9ec-f2113ecc3076](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png)

不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对他们那的写则把数据添加到末尾。他们不支持诸如lseek()等文件定位操作。



##### 消息队列（message queue）

相比于FIFO，消息队列有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难
- 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法
- 读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收

消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓存区大小受限等缺点。

##### 信号量（semophone）

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，它主要作为进程间以及同一进程内不同线程之间的同步手段。

##### 信号（signal）

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

##### 共享内存（shared memory）

共享内存就是映射一段能被其他进程所访问的内存（同一块物理内存被映射到进程A、B各自的进程地址空间），这段共享内存由一个进程创建，但多个进程都可以访问。

共享内存是最快的IPC方式，因为数据不需要在进程之间复制，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量或信号量，配合使用，来实现进程间的同步和通信。

##### 套接字（socket）

可用于不同机器之间的进程通信。

#### 僵尸进程

- 什么是僵尸进程：当子进程（由父进程调用开启的进程，认为是子进程）比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
- 怎样清除僵尸进程：
  - 改写父进程，在子进程死后为其收尸。即接管SIGCHLD信号，子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子进程收尸
  - 杀掉父进程，父进程死后，僵尸进程成为“孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程。



### 死锁

#### **产生死锁的必要条件**

- 互斥：某种资源一次只允许一个进程访问,即该资源一旦分配给某个进程，其他进程就不能再访问,直到该进程访问结束。 
- 占有且等待：一个进程本身占有资源(一种或多种),同时还有资源未得到满足，正在等待其他进程释放该资源。 
- 不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。 
- 循环等待：存在一个进程等待序列，使得每个进程都占有下一个进程所需的至少一种资源。

#### 处理方法

##### 鸵鸟策略

把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

##### 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

- 每种类型一个资源的死锁检测：

  ![b1fa0453-a4b0-4eae-a352-48acca8fff74](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png)

  上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

  图a可以抽取出环，图b满足了环路等待条件，因此会发生死锁。

  每种类型一个资源的死锁检测算法时通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

- 每种类型多个资源的死锁检测

**![e1eda3d5-5ec8-4708-8e25-1a04c5e11f48](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png)**

上图中，有三个进程四个资源，诶个数据代表的含义如下：

- E向量：资源总量
- A向量：资源剩余量
- C矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R矩阵：每个进程请求的资源数量

进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

- 死锁恢复
  - 利用抢占恢复
  - 利用回滚恢复
  - 通过杀死进程恢复

##### 死锁的预防

- 打破互斥条件：即允许进程同时访问某些资源。例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。
- 打破不可抢占条件：即允许进程强行从占有者那里夺取资源。即，当一个进程占有了某些资源，它又申请新的资源而不能被立即满足时，它必须释放所有占有的资源，以后再重新申请。（相当于该进程的资源被隐蔽地强占了）该方法实现困难，会降低系统性能。
- 打破占有且等待条件：可以实行资源预分配策略，即在进程运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不执行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。缺点：
  - 在许多情况下，一个进程在执行之前不可能知道它所需要的全部资源。这是由于进程在执行时是动态的，不可预测；
  - 资源利用率低。无论所分资源在何时才用到，一个进程只有在占有所需的全部资源后才能执行。即使有些资源最后才被进程用到一次，但该进程在生存期间却一直占有，造成长期占着不用的状况，这是一种极大的资源浪费；
  - 降低了进程的并发性。因为资源有限，加上存在浪费，能分配到全部资源的进程个数必然减少。
- 打破循环等待条件：实行资源有序分配策略。即把资源事先分类编号，按号分配，使进程在申请、占用资源时不会形成环路，所有进程对资源的请求必须严格按资源递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁，与前面的策略相比，资源的利用率和系统的吞吐量都有很大提高，缺点：
  - 限制了进程对资源的请求，同时给系统中所有资源合理编号也比较困难。
  - 为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间。

**死锁避免**

- 银行家算法
  - 我们把操作系统看作银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。
  - 为保证资金的安全，银行家规定：
    - 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；
    - 顾客可以分期贷款，但贷款的总数不能超过最大需求量；
    - 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可以推迟支付，但总能使顾客在有限的时间里得到贷款；
    - 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金。
  - 操作系统按照银行家执行的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。

- 安全序列
  - 指对当前申请资源的进程排列出一个序列，保证按照这个序列分配资源完成进程，不会发生“酱油和醋“的尴尬问题。
  - 假设有进程P1～Pn，则安全序列要求满足：Pi需要资源<=剩余资源+分配给Pj的资源（1<=j<i<=n)

**如何理解分布式锁**

分布式锁，是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或者是同一系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，需要使用分布式锁。

### 同步、异步、阻塞、非阻塞

- 线程同步与阻塞没有一点关系，两者可以全排列组合
- 同步和异步关注的消息通信机制
  - 所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回。但是一旦调用返回，就得到返回值了。换句话，就是由**调用者**主动等待这个**调用**的结果。
  - 而异步则是相反，**调用**在发出之后，这个调用就直接返回了，所以没有返回结果。换句话，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在**调用**发出后，**被调用者**通过状态、通知来通知调用者，或者通过回调函数来处理这个调用。
- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态
  - 阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回
  - 非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程
- 例子：
  - 老王煮水，站着等，隔段时间看看水开没，等水开。——同步阻塞
  - 老王煮水，跑去上网，同时隔段时间看看水开没，没开继续上网。——同步非阻塞
  - 老王煮水，使用电水壶，站着等灯灭。——异步阻塞
  - 老王煮水，使用电水壶，跑去上网，直到电水壶提示煮熟了。——异步非阻塞
  - 同步和异步：同步就是烧水需要自己去轮询（隔段时间看看水开没），异步就是水开了，水壶会通知你。相对于会不会等待结果返回。
  - 阻塞和非阻塞：阻塞就是说在煮水过程中，不能干其他的事；非阻塞就是你可以干其他的事。相对于线程是否被阻塞。
- 本质区别
  - 阻塞和非阻塞：进程访问的数据如果尚未就绪，进程是不是要阻塞等待
  - 同步和异步：指消息通信机制，同步指主动请求并等待I/O操作完毕的方式，当数据在就绪后在读写时必须阻塞；异步则指主动请求数据后可以继续处理其他任务，随后等待I/O操作完毕的通知，者可以使进程在数据读写时也不阻塞。

- 

### 内存管理方式

#### 页存储

为便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。页表作业就是实现从页号到物理块号的地址映射，这种是页存储管理方式。

![image-20200207114125762](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200207114125762.png)

#### 段存储

将用户程序地址空间分成若干大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配，这种是段存储的管理方式。

![image-20200207125649776](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200207125649776.png)

#### 段页存储

作业的地址空间首先被分成若干逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位，这种是段页式存储管理方式。

![image-20200207130305410](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200207130305410.png)

#### 虚拟内存、物理内存、共享内存

虚拟内存：不同于物理内存，虚拟内存是操作系统内核为对进程地址空间进行管理而设计的一个逻辑意义上的内存空间概念。我们程序中的指针其实都是这个虚拟内存空间的地址。比如，编译时，编译器采用的地址其实就是虚拟内存空间的地址，因为此时程序还没有运行。因此需要有一套机制可以让虚拟内存空间映射到物理内存空间中。这就是操作系统中页映射表的功能。内核会为系统中每一个进程维护一份独立的页映射表，页映射表的基本原理是将程序运行过程中需要访问的一段虚内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问到物理内存上的某个对应地址。

在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到**内存管理单元**（Memory Management Unit，MMU），MMU把虚拟地址映射为物理内存地址。

驻留内存：指那些被映射到进程虚拟内存空间的物理内存。因此我们讲进程占用了多少内存，一般说占用了多少驻留内存。

top命令中：

- 虚拟内存VIRT：进程虚拟内存空间的大小
- 物理内存RES：指进程虚拟内存空间中已经映射到物理内存空间的那部分大小
- 共享内存SHR：共享的，比如说库文件程序占用的内存。计算进程独占内存的大小之需要用物理内存减去共享内存。

### 页面置换算法

#### 概念

缺页中断：要访问的页不在主存，需要操作系统将其吊入主存后再进行访问。

页面置换算法：在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。

#### OPT最优页面置换算法

寻找在将来的时间段内，最晚被访问到的页面，然后将其置换掉。（无法预知未来，不现实）

#### 先进先出置换算法（FIFO）

最简单的页面置换算法，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。

#### 最近最久未使用算法（LRU）

置换时，选择在最近一段时间里最久没有使用过的页面予以置换。

LRU是经常采用的也是较好的页面置换算法，但存在实现问题。LRU算法需要实际硬件的支持，需要确定最后使用时间的顺序，有两种可行办法：

1. 计数器：最简单的情况是使每个页表项对应一个使用时间字段，并给CPU增加一个逻辑时钟或者计数器。每次存储访问，该时钟都加1。每当访问一个页面时，时钟寄存器的内容就被复制到相应表项的使用时间字段中，即保留每个页面的最后访问的时间。缺点：要查页表，并且当页表改变时（因CPU调度）要维护这个页表的时间，还要考虑时钟值溢出的问题。
2. 栈：用一个栈保留页号，每当访问一个页面时，就把它从栈中取出放在栈顶。栈顶总是存放目前使用最多的页，而栈底放着目前最少使用的页。由于要从栈的中间移走一项，所以要用具有头尾指针的双向链连起来。

#### 时钟置换算法（CLOCK）

简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1；当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看作是一个循环缓冲区，并且有一个指针与之挂念。某一页被替换时，该指针被设置成指向缓冲区的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位置重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1，则指针在缓冲区完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，称为CLOCK算法，又称为最近未用算法（NRU）。

CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法，使得每一帧处于一下四种情况之一：

1. 最近未访问，也未修改（u=0,m=0)
2. 最近被访问，未修改
3. 最近未访问，被修改
4. 最近被访问，被修改

算法执行步骤：

1. 从指针的当前位置开始，扫描缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧（u=0，m=0）用于替换；
2. 如果第1步失败，则重新扫描，查找（u=0，m=1）的帧。选择遇到的第一个此帧用于替换，对于跳过的每个帧，将其使用位设置成0；
3. 如果第2步失败，则指针回到最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样就可以找到供替换的帧。

### IO种类及原理

1. IO种类

   **按使用特性：**

   1. 人机交互类外部设备：用于同计算机用户之间交互的设备，如打印机、显示器、键盘和鼠标等。数据交换速度相对较慢，通常以字节为单位进行数据交换。
   2. 存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘。交换速度较快，通常多以字节组成的块为单位进行数据交换
   3. 网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器。其速度介于前2者之间。网路通信设备在使用和管理上与前2者也有很大不同。

   **按传输速率：**

   1. 低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘鼠标等
   2. 中速设备：数千字节至数万字节，如行式打印机、激光打印机
   3. 高速设备：数百个千字节至千兆字节的一类设备，如磁带机、磁盘级、光盘机

   **按信息交换的单位：**

   1. 块设备：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它数据有结构设备，如磁盘，磁盘设备的基本特征就是传输速率较高，以及可寻址，即对它可随机地读/写任一块。
   2. 字符设备：用于数据输入/输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如果交换式终端机、打印机等。特点是传输速率低，不可寻址，并且在输入/输出时常采用中断驱动方式。

2. 设备I/O输入输出控制方式

   - 程序直接控制方式：计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中。
   - 中断驱动方式：循序I/O设备主动打算CPU的运行并请求服务，从而解放CPU，使得其向I/O控制器发送读命令后可以继续做其他工作
   - DMA方式：在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限，而DMA（直接存储器存取）方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底解放CPU
   - 通道控制方式：I/O通道是指专门负责输入/输出的处理机，I/O通道方式是DMA方式的发展，它可以进一步减少CPU的干预，即把一个数据块的读（写）为单位的干预，减少为对一组数据块的读（写）及有关的控制和管理为单位的干预。**区别**：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息都是由通道控制的。另外每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。

#### 小知识点：进程打开同一个文件

两个进程打开同一个文件，那么这两个文件得到的文件描述符（fd）相同。？

整个系统表包含进程相关信息，如文件在磁盘的位置、访问日期和大小。**一个进程打开一个文件，系统打开文件表就会为打开的文件增加相应的条目。当另一个进程执行open时，只不过是在其进程打开表中增加一个条目，并指向整个系统表的相应条目。**通常，系统打开文件表的每个文件时，还用一个文件打开计数器，以记录多少进程打开了该文件。每个关闭操作close则使count递减，当打开计算器为0时，表示该文件不再被使用。系统将回收分配给该文件的内存空间等资源，如文件被修改过，则将文件写会外存，并将系统打开表中相相应条目删除，最后释放文件的文件控制块（FIle Control Block， FCB）。

//////

内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述符表中每一项都是一个指针，指向一个用于描述打开的文件的数据块——file对象，file对象中描述了文件的打开模式，读写位置等等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某一个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享则个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，引用计数为0时，内核销毁file对象。

**文件描述符每个进程都有独立的一个，指向同一个file对象（v节点）。**所以文件描述符（文件描述符中包含文件状态标志、当前文件偏移量，v节点指针）不同，但指向的内从相同。

#### IO复用

～～～～～～

#### 物理地址、虚拟地址、逻辑地址

**物理地址（空间）**

用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚按发送到内存总线上的电信号对应。物理地址由32位或64位无符号整数表示

**虚拟地址**

就是在分段、分页的基础上，比如将地址分位32位

![image-20200208120501963](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200208120501963.png)

**逻辑地址**

包含在机器语言指令中用来指定一个操作数或者一条指令的地址，每个逻辑地址都由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。

### 链接

#### 编译系统

以下是一个 hello.c 程序：

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}Copy to clipboardErrorCopied
```

在 Unix 系统上，由编译器把源文件转换为目标文件。

```bash
gcc -o hello hello.cCopy to clipboardErrorCopied
```

这个过程大致如下：

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg)

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。

#### 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg)

#### 目标文件

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接

#### 动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg)



## Linux

### 前言

面试中比较重要的知识点：

- 能简单实用cat、grep、cut等命令进行一些操作；
- 文件系统相关的原理，inode和block等概念，数据恢复；
- 硬链接和软链接；
- 进程管理相关，僵尸进程和孤儿进程，SIGCHLD。

### 常用操作以及概念

#### 快捷键

- Tab：命令和文件名补全
- Ctrl+C：中断正在运行的程序
- Ctrl+D：结束键盘输入（End Of File，EOF）

#### 求助

1. --help：指令的基本用法与选项介绍

2. man：manual的缩写，将指令的具体信息显示出来，当执行man date时，有DATE（1）出现，其中数字代表指令的类型：

   | 代号 | 类型                                          |
   | ---- | --------------------------------------------- |
   | 1    | 用户在shell环境中可以操作的指令或者可执行文件 |
   | 5    | 配置文件                                      |
   | 8    | 系统管理员可以使用的管理指令                  |

3. Info：info与man类似，但是info将文档分成一个个页面，每个页面可以跳转

4. doc：/ust/share/doc存放着软件的一整套说明文件

#### 关机

1. who：关机前首先使用who命令查看有没有其他用户在线。
2. sync：为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行sync同步操作。
3. shutdown

```
# shutdown [-krhc] 时间 [信息]
-k : 不会关机，只发送警告信息，通知所有在线用户
-r : 将系统的服务停掉后就重新启动
-h : 将系统的服务停掉后就立即关机
-c : 取消已经在经常的shutdown
```

#### PATH

可以在环境变量PATH中声明可执行文件的路径，路径之间用:分隔。

```
/usr/loacl/bin:/usr/bin   ......
```

#### sudo

sudo允许一般用户使用root可执行的命令，不过只有在/etc/sudoers配置文件中添加的用户才能使用该指令。

#### 包管理工具

RPM和DPKG为最常见的两类软件包管理工具：

- RPM全称为Redhat Package Manager，最早由Red Hat公司制定实施，随后被GNU开源操作系统接受并称为许多Linux操作系统的既定软件标准。YUM基于RPM，具有依赖管理和软件升级功能。
- 与RPM竞争的是基于Debian操作系统的DEB软件包管理工具，DPKG，全称Debian Package，功能与RPM类似。

#### 发行版

Linux发行版是Linux内核及各种应用软件的集成版本。

| 基于的包管理工具 | 商业发行版 | 社区发行版      |
| ---------------- | ---------- | --------------- |
| RPM              | Red Hat    | Fedora / Centos |
| DPKG             | Ubuntu     | Debian          |

#### VIM三个模式

![image-20200229124053722](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229124053722.png)

- 一般指令模式（Command mode）：VIM的默认模式，可以用于移动过游标查看内容；
- 编辑模式（Insert mode）：按下"i"、“o”等进入，可以对文本进行编辑；
- 指令列moist(Bottom-line mode)：按下":"键之后进入，用户保存退出搜索等操作。

#### GNU

GNU计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为GNU，其内容软件完全以GPL方式发布。其中GPL全称为GNU通用公共许可协议（GNU General Public License），包含以下内容：

- 以任何目的运行此程序的自由；
- 再复制的自由；
- 改进此程序，并公开发布改进的自由；

### 磁盘

#### 磁盘接口

##### IDE

IDE（ATA）全称Advanced Technology Attachment，接口速度最大为133MB/s，因为并口线的抗干扰性能太差，且排线占用空间较大，不利电脑内部散热，已逐渐被SATA取代；![image-20200229124826283](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229124826283.png)

##### SATA

SATA全称Serial ATA，也就是使用串口的ATA接口，抗干扰性强，且对数据线的长度要求比ATA低很多，支持热插拔等功能。SATA-II的接口速度为300MiB/s，而SATA-III标准可达600MiB/s的传输速度。SATA的数据线也比ATA的细的多，有利于机箱内的空气流通，整理线材也比较方便。![image-20200229124835571](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229124835571.png)

##### SCSI

SCSI全称Small Computer System Interface（小型机系统接口），SCSI硬盘广为工作站及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速15000rpm的高转速，且传输时CPU占用率较低，但是单价也比相同容量的ATA及SATA硬盘更加昂贵。![image-20200229125017188](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229125017188.png)

##### SAS

SAS（Serial Attached SCSI）是新一代SCSI技术，和SATA硬盘相同，都是采取序列式技术以获得更高的传输速度，可达6Gb/s。此外也通过缩小连接线改善系统内部空间等。![image-20200229125136470](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229125136470.png)

##### 为什么串行传输比并行传输快？

- 并口存在干扰；
- 并口需要同步——致命缺点，常常传输失败，随着信号线加长，这种情况越发严重

#### 磁盘的文件名

Linux中每个硬件都被当作一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：

- IDE硬盘：/dev/hd[a-d]
- SATA/SCSI/SAS硬盘：/dev/sd[a-p]

其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的槽位无关。

### 分区

磁盘分区表主要有两种格式，一种是限制较多的MBR分区表，一种是较新且限制较少的GPT分区表。

#### 分区表

##### MBR

MBR中，第一个扇区最重要，里面有主要开机记录（Master boot record，MBR）及分区表（partition table），其中主要开机记录占446bytes，分区表占64bytes。

分区表只有64bytes，最多只能存储4个分区，这4个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其他扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。

Linux也把分区当成文件，分区文件的命名方式为：磁盘文件名+编号，例如/dev/sda1。注意，逻辑分区的编号从5开始。

##### GPT

扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为512bytes，而最新的磁盘支持4k。GTP为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address，LBA），LBA默认大小为512bytes。

GPT第1个区块记录了主要开机记录（MBR），紧接着是33个区块记录分区信息，并把最后的33个区块用于对分区信息进行备份。这33个区块第一个为GPT表头记录，这个部分记录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码（CRC32），操作系统可以根据这个校验码来判断GPT是否正确。若有错误，可以使用备份分区进行恢复。

GPT没有扩展分区的概念，都是主分区，每个LBA可以分为4个区，因此总共可以分4*32 = 128个分区。

MBR支持2.2TB以上的硬盘，GPT则最多支持到2sup33TB = 8ZB。

![image-20200229131308841](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229131308841.png)

#### 开机检测程序

##### BIOS

BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS程序存放在断电后内存不会丢失的只读内存中。![image-20200229131659939](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229131659939.png)

BIOS是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。

主要开机记录（MBR）中的开机管理程序提供如下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。

下图中，第一扇区的主角开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1指向了Windows操作系统，而M2指向其它分区的启动扇区，里面包含了另一个开机管理程序，提供了一个指向Linux的选单。![image-20200229132042958](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229132042958.png)

安装多重引导，最好先安装Windows再安装Linux。因为安装Windows时会覆盖掉主要开机记录（MBR），而Linux可选择将开机管理程序安装在主要开机记录或者其他分区的启动扇区，并且可以设置开机管理程序的选单。

##### UEFI

BIOS不可以读取GPT分区表，而UEFI可以。

### 文件系统

#### 分区与文件系统

对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。

#### 组成

最主要的几个组成部分如下：

- inode：一个文件占用一个inode，记录文件的属性，同时记录此文件的内容所在的block编号；
- block：记录文件的内容，文件太大时，会占用多个block。

除此之外还包括：

- superblock：记录文件系统的整体信息，包括inode和block的总量、使用量、剩余量，以及文件系统的格式与相关信息等；
- block bitmap：记录block是否被使用的位图。![image-20200229132712745](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229132712745.png)

#### 文件读取

对于Ext2文件系统，当要读取一个文件的内容时，先在inode中查找文件内容所在的所有block，然后把所有block的内容读出来。

![image-20200229132840776](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229132840776.png)

而对于FAT文件系统，它没有inode，每个block中存储着下一个block的编号。![image-20200229132915859](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229132915859.png)

#### 磁盘碎片

指一个文件内容所在的block过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。

#### block

在Ext2文件系统中所支持的block大小由1K、2K及4K三种，不同的大小限制了单个文件和文件系统的最大大小。

| 大小         | 1KB  | 2KB   | 4KB  |
| ------------ | ---- | ----- | ---- |
| 最大单一文件 | 16GB | 256GB | 2TB  |
| 最大文件系统 | 2TB  | 8TB   | 16TB |

一个block只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的block。

#### inode

inode具体包含以下信息：

- 权限（rwx）
- 拥有者与群组（owner/group）
- 容量
- 建立或状态改变的时间（ctime）
- 最近读取时间（atime）；
- 最近修改时间（mtime）；
- 定义文件特性的旗标（flag），如SetUID
- 该文件真正内容的指向（pointer）

inode具有以下特点：

- 每个inode大小均固定为128bytes（新的ext4与xfs可设定到256bytes）；
- 每个文件都会占用一个inode。

inode中记录了文件内容所在的block编号，但是每个block非常小，一个大文件随便都需要几十万的block。而一个inode大小有限，无法直接引用这么多的block编号。因此引入了间接、双间接、三间接引用。间接引用让inode记录的引用block块来记录引用信息。

![image-20200229134734222](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229134734222.png)

#### 目录

建立一个目录树，会分配一个inode与至少一个block。block记录的内容是目录下所有文件的inode编号以及文件名。

可以看到文件的inode本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。

#### 日志

如果突然断电，那么文件系统会发生错误，例如断电前只修改了block bitmap，而还没有将真正写入block中。

Ext3/ext4文件系统引入了日志功能，可以利用日志来修复文件系统。

#### 挂载

挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。

#### 目录配置

为了使不同Linux发行版本的目录结构保持一致性，Filesystem Hierarchy Standard（FHS）规定了Linux的目录结构。最基础的三个目录如下：

- /（root，根目录）
- /usr（unix software resource）：所有系统默认软件都会安装到这个目录
- /var（variable）：存放系统或程序运行过程中的数据文件

![image-20200229135258646](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229135258646.png)

### 文件

#### 文件属性

用户分为3种：文件拥有者、群组以及其他人，对不同的用户有不同的文件权限。

使用ls查看一个文件时，会显示一个文件的信息，例如drwxr-xr-x 3 root root 17 May 6 00:14 .config，解释：

- drwxr-xr-x：文件类型以及权限，第一位为文件类型字段，后9位为文件权限字段；
- 3：链接数
- root：文件拥有者；
- root：所属群组
- 17：文件大小
- May 6 00:14：文件最后被修改的时间
- .config：文件名

常见的文件类型及其含义有：

- d：目录
- -：W摁键
- l：链接文件

9位的文件权限字段中，每3个为一组，共3组，每一组分别代表对文件拥有者、所属群组以及其他人的文件权限。一组权限中的3位分别为r、w、x权限，表示可读、可写、可执行。

文件时间有以下三种：

- Modification time(mtime)：文件的内容更新就会更新；
- status time(ctime)：文件的状态（权限、属性）更新就会更新；
- access time(atime)：读取文件时就会更新。

#### 文件与目录的基本操作

##### ls

列出文件或者目录信息，目录的信息就是其中包含的文件。

```shell
# ls [-aAdFhilnrRst] file|dir
-a ：列出全部的文件
-d ： 仅列出目录本身
-l ： 以长数据串行列出，包含文件的属性与权限等等数据
```

##### cd

更换当前目录。

##### mkdir

创建目录

```shell
# mkdir [-mp] 目录名
-m ： 配置目录权限
-p ： 递归创建目录
```

##### rmdir

删除目录，目录必须为空

```shell
# rmdir [-p] 目录名
-p ： 递归删除目录
```

##### touch

更新文件时间或者建立新文件

```shell
# touch [-acdmt] fileName
-a : 更新atime
-c : 更新ctime，若文件不存在则建立新文件
-m : 更新mtime
-d : 后面可以接更新日期而不使用当前日期，也可以使用--daye=“日期或时间”
-t : 后面可以接更新时间而不使用当前时间，格式为【YYYYMMDDhhmm】
```

##### cp

复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。

```shell
cp [-adfilprsu] source destination
-a : 相当于 -dr --preserve=all
-d : 若来源文件为链接文件，则复制链接文件属性而非文件本身
-i : 若目标文件已经存在时，在覆盖前先回询问
-p : 连同文件的属性一起复制过去
-r : 递归复制
-u : destination比source旧才更新destination，或destination不存在的情况下才复制
--preserve=all : 除了-p的权限相关参数外，还加入SELinux的属性，links，xattr等也复制了。
```

##### rm

删除文件

```shell
# rm [-fir] 文件或目录
-r : 递归删除
-f : 强制，不询问
```

##### mv

移动文件

```
# mv [-fiu] source destination
# mv [options] source1 source2 source3 .... directory
-f : force强制，如果逸存在则不询问直接覆盖
```

#### 修改权限

可以将一组权限用数字来表示，此时一组权限的三个位当作二进制数字的位，从左到右每个位的权值为4、2、1，即每个权限对应的数组权值为r：4、w：2、x：1.

```shell
chmod [-R] xyz dirname/filename
chmod 754 .bashrc
```

也可以使用符号来设定权限

```shell
chmod [ugoa] [+-=] [rwx] dirname/filename
u 所有者
g 所属群组
o 其他人
a 所有人
+ 添加权限
- 移除权限
= 设定权限

chmod a+w .bashrc
```

#### 默认权限

- 文件默认权限：文件默认没有可执行权限，因此为666，即-rw-rw-rw-
- 目录默认权限：目录必须要能过进入，也就是必须拥有可执行权限，因此为777，也就是drwxrwxrwx。

可以通过umask设置或者查看默认权限，通过以掩码的形式来表示，例如002表示其他用户的权限除了一个2的权限，即写权限，因此建立新文件时的默认权限为-rw-rw-r--。

#### 目录的权限

文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的w权限并不能对文件名进行修改。

目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的r权限可以表示读取文件列表；w权限表示可以修改文件列表，就是说可以添加删除文件，对文件名进行修改；x权限可以让该目录成为工作目录，x权限是rw权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。

#### 链接

![image-20200229141809741](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229141809741.png)

```shell
ln [-sf] source_filename dist_filename
-s 默认是实体链接，加-s为符号链接
-f 如果目标文件存在，先删除目标文件
```

##### 实体链接

在目录下创建一个条目，记录着文件名与inode编号，这个inode就是源文件的inode。

删除任意一个条目，文件还是存在，只要引用数量不为0.

有以下限制：不能跨越文件系统、不能对目录进行链接。

```
 ln /etc/crontab .
 ll -i /etc/crontab crontab
 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
```

##### 符号链接

符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为Windows的快捷方式。

当源文件被删除了，链接文件就打不开了。

因为记录的是路径，所以可以为目录建立符号链接

```
ll -i /ect/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -> /etc/crontab
```

#### 获取文件内容

##### cat

##### tac

##### more

##### less

##### head

##### tail

##### od

#### 指令与文件搜索

##### which

指令搜索

##### whereis

文件搜索。速度较快，因为它只搜索几个特定的目录。

##### locate

文件搜索。可以用关键字或者正则表达式进行搜索。

locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。

##### find

文件搜索。可以使用文件的属性和权限进行搜索。

### 压缩与打包

#### 压缩文件名

Linux底下有很多压缩文件名，常见：

| 扩展名    | 压缩程序                           |
| --------- | ---------------------------------- |
| *.z       | Compress                           |
| *.zip     | Zip                                |
| *.gz      | gzip                               |
| *.bz2     | bzip2                              |
| *.xz      | xz                                 |
| *.tar     | tar程序打包的数据，没有经过压缩    |
| *.tar.gz  | tar程序打包的文件，经过gzip的压缩  |
| *.tar.bz2 | tar程序打包的文件，经过bzip2的压缩 |
| *.tar.xz  | tar程序打包的文件，经过xz的压缩    |

#### 压缩指令

##### gzip

gzip是Linux使用最广的压缩指令，可以解开compress、zip与gzip所压缩的文件。

经过gzip压缩过，源文件旧不存在了。

有9个不同的压缩等级可以使用。

可以使用zcat、zmore、zless来读取压缩文件的内容

```
gzip [-cdtv#] filename
-c 将压缩的数据输出到屏幕上
-d 解压缩
-t 检验压缩文件是否出错
-v 显示压缩比等信息
-# #为数字的意思，代表压缩等级，数字越大压缩比越高，默认为6
```

##### bzip2

提供比gzip更高的压缩比。

查看命令：bzcat、bzmore、bzless、bzgrep

```
bzip2 [-cdkzv#] filename
-k 保留源文件
```

##### xz

提供比bzip2更佳的压缩比。

可以看到，gzip、bzip2、xz的压缩比不断优化。不过要注意，压缩比越高，压缩的时间也越长。

查看命令：xzcat、xzmoer、xzless、xzgrep

```
xz [-dtlkc#] filename
```

#### 打包

压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar不仅可以用于打包，还可以借助gzip、bzip2、xz将打包文件进行压缩。

```
tar [-z|-j|-J] [cv] [-f 新建的tar文件] filename == 打包压缩
tar [-z|-j|-J] [tv] [-f 已有的tar文件]  == 查看
tar [-z|-j|-J] [xv] [-f已有的tar文件] [-C 目录] == 解压缩
-z 使用zip
-j 使用bzip2
-J 使用xz
-c 新建打包文件
-t 查看打包文件里面有哪些文件
-x 解打包或解压缩的功能
-v 在压缩/解压缩的过程中，显示正在处理的文件名
-f filename 要处理的文件
-C 目录：在特定目录解压缩
```

| 使用方式 | 命令                                                   |
| -------- | ------------------------------------------------------ |
| 打包压缩 | tar -jcf -f filename.tar.bz2要被压缩的文件或着目录名称 |
| 查看     | tar -jtv filename.tar.bz2                              |
| 解压缩   | Tar -jxv -f filename.tar.bz2 -C 要解压缩的目录         |

### Bash

可以通过Shell请求内核提供服务，Bash正是Shell的一种。

#### 特性

- 命令历史：记录使用过的命令
- 命令与文件补全：快捷键tab
- 命名别名：例如ll是ls -al的全称
- shell scripts
- 通配符：例如ls -l /usr/bin/X* 列出下面所有以X开头的文件

#### 变量操作

对一个变量赋值直接使用-。

对变量取用需要在变量前加上$$$，也可以用${}的形式。

输出变量使用echo命令。

```shell
$ x = abc
$ echo $x
$ echo ${X}
```

变量内容如果有空格，必须使用双引号或者单引号。

- 双引号内的特殊字符可以保留原本特性，例如x="lang is $LANG"，则x的值为lang is zh_TW.UTF-8；
- 单引号内的特殊字符就是特殊字符本身，例如x='lang is $$$LANG'，则x的值为lang is $LANG。

可以使用``或者${指令}的方式将指令的执行结果赋值给变量。例如，

```shell
version=$(uname -r)，则version的值为4.15.0-22-generic
```

可以使用export命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前Bash而产生的子Bash。

Bash的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用declare命令：

```
declare [-aixr] variable
-a 定义为数组类型
-i 定义为整数类型
-x 定义为环境变量
-r 定义为readonly类型
```

使用[]来对数组进行索引操作：

```shell
$ array[1]=a
$ array[2]=b
$ echo ${array[1]}
```

#### 指令搜索顺序

- 以绝对或相对路径来执行指令，例如/bin/ls或者./ls
- 由别名找到该指令来执行
- 由bash内置的指令来执行
- 按$PATH变量制定的搜索路径的顺序找到第一个指令来执行。

#### 数据流重定向

重定向指的是使用文件代替标准输入、标准输出和标准错误输出。

| 1                      | 代码 | 运算符  |
| ---------------------- | ---- | ------- |
| 标准输入（stdin）      | 0    | <或<<   |
| 标准输出（stdout）     | 1    | >或>>   |
| 标准错误输出（stderr） | 2    | 2>或2>> |

其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头表示以追加的方式重定向。

可以将不需要的标准输出以及标准错误输出重定向到/dev/null，相当于扔进垃圾箱。

如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如2>&1表示将标准错误输出转换为标准输出。

```
find /home -name .bashrc > list 2>&1
```

### 管道指令

管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤处理之后才能得到我们想要的内容时就可以使用管道。

在命令之间使用|分隔各个管道命令。

```shell
$ ls -al /etc | less
```

#### 提取指令

cut对数据进行切分，取出想要的部分。

切分过程一行一行地进行。

```
$ cut
-d 分隔符
-f 经过-d分隔后，使用-f n取出第n个区间
-c 以字符为单位取出区间
```

示例1:last显示登入者的信息，取出用户名

```
$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)

$ last | cut -d ' ' -f 1
```

示例2:将export输出的信息，取出第12字符以后的所有字符串

```shell
$ export
declare -x HISTCONTROL="ignoredups"
declare -x HISTSIZE="1000"
declare -x HOME="/home/dmtsai"
declare -x HOSTNAME="study.centos.vbird"
.....(其他省略).....

$ export | cut -c 12-
```

排序指令

sort用于排序。

```
$ sort [-fbMnrtuk] [file or stdin]
-f 忽略大小写
-b 忽略最前面的空格
-M 以月份的名字来排序，例如JAN，DEC
-n 使用数字
-r 反向排序
-u 相当于unique，重复的内容只出现一次
-t 分隔符，默认为tab
-k 指定排序的区间
```

示例：/etc/passwd文件内容以：分隔，要求以第三列进行排序

```
$ cat /etc/passwd | sort -t ":" -k 3
```

uniq可以将重复的数据只取一个

```
$ uniq [-ic]
-i 忽略大小写
-c 进行计数
```

示例：取得每个人的登陆总次数

```
$ last | cut -d ' ' -f 1 | sort | uniq -c
```

#### 双向输出重定向

输出重定向会将输出内容重定向到文件中，而tee不仅能够完成这个功能，还能保留屏幕上的输出。即，使用tee命令，一个输出会同时传送到文件和屏幕上。

```shell
$ tee [-a] file
```

#### 字符转换指令

tr用来删除一行中的字符，或者对字符进行替换

```
$ tr [-ds] SET1 ....
-d 删除行中SET1这个字符串
```

示例：将last输出的信息所有小写转换为大写。

```shell
$ last | tr '[a-z]' '[A-Z]'
```

col将tab字符转换为空格字符

```
$ col [-xb]
-x 将tab键转换成对等的空格键
```

expand将tab键转换为一定数量的空格，默认8个

```
expand [-t] file
-t tab转为空格的数量
```

join将有相同数据的哪一行合并在一起

```
$ join [-ti12] file1 file2
-t 分隔符，默认空格
-i 忽略大小写差异
-1 第一个文件所用的比较字段
-2 第二个文件所有的比较字段
```

paste直接将两行粘贴在一起

```
$ paste [-d] file1 file2
-d 分隔符，默认为tab
```

#### 分区指令

split将一个文件划分为多个文件

```
$ split [-bl] file PREFIX
-b 以大小来进行区分，可加单位，例如b、k、m等
-l 以行数来进行区分
-PREFIX 分区文件的前导名称
```

### 正则表达式

#### grep

g/re/p（globally search a regualr expression and print），使用正则表达式进行全局查找并打印。

```
$ grep [-acinv] [--color=auto] 搜索字符串 filename
-c 统计匹配到行的个数
-i 忽略大小写
-n 输出行号
-v 反向选择，也就是显示出没有搜索字符串内容的哪一行
--color=auto 找到的关键字加颜色显示
```

示例：把含有the字符串的行提取出来（注意默认会有--color=auto选项，因此一下内容在Linux中有颜色显示the字符串

```
$ grep -n 'the' regular_express.txt
8:I can't finish the test.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with "glad".
18:google is the best tools for search keyword
```

示例：正则表达式a{m,n}用来匹配字符a m~n次，这里需要将{和}进行转义，因为它们在shell是有特殊意义的。

```
$ grep -n 'a\{2,5\}' regular_express.txt
```

#### printf

用于格式化输出。它不属于管道命令，在给printf传数据时需要使用$()形式。

```
$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33

```

#### awk

是由Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。

awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$$$n，n 为字段号，从 1 开始，$0 表示一整行。

示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $$$1 和 $3 就能取出这两个字段，然后用 print 进行打印。

```html
$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)

$ last -n 5 | awk '{print $1 "\t" $3}'

```

可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。

```html
$ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filenameCopy to clipboardErrorCopied
```

示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。

```text
$ cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'
root 0
bin 1
daemon 2
```

awk 变量：

| 变量名称 | 代表意义                     |
| -------- | ---------------------------- |
| NF       | 每一行拥有的字段总数         |
| NR       | 目前所处理的是第几行数据     |
| FS       | 目前的分隔字符，默认是空格键 |

示例：显示正在处理的行号以及每一行有多少字段

```html
$ last -n 5 | awk '{print $1 "\t lines: " NR "\t columns: " NF}'
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
```

### 进程管理

#### 查看进程

##### ps

查看某个时间点的进信息。

示例：查看自己的进程

```
# ps -l
```

示例：查看系统所有进程

```
# ps aux
```

示例：查看特定进程

```
# ps aux | grep threadx
```

##### pstree

查看进程树

示例：查看所有进程树

```
# pstree -A
```

##### top

实时显示进程信息。

示例：两秒钟刷新一次

```
# top -d 2
```

##### netstat

查看占用端口的进程

示例：查看特定端口的进程

```
# netstat -anp | grep root
```

#### 进程状态

| 状态 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| R    | running or runnable(on run queue)                            |
| D    | uninterruptible sleep(usually I/O)                           |
| S    | interruptible sleep(waiting for an event to complete)        |
| Z    | zobie(terminated but not reaped by its parent)               |
| T    | stopped(either by a job control signal or because it is being traced) |

![image-20200301003938410](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301003938410.png)

#### SIGCHLD

当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：

- 得到SIGCHLD信号
- waitpid()或者wait()调用会返回。

其中子进程发送的SIGCHLD信号包含了子进程的信息，比如进程ID、进程状态、进程使用CPU的时间等。

在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程的到子进程信息，父进程通过wait()和waitpid()来获得一个已经退出的子进程的信息。

#### wait()

```c
pid_t wait(int *status)
```

父进程调用wait()会一直阻塞，知道收到一个子进程退出的SIGCHLD信号，之后wait()函数会销毁子进程并返回。

如果成功，返回被收集的子进程的进程ID；如果调用进程没有子进程，调用就会失败，此时返回-1，同时errno被设置为ECHILD。

参数status用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的豪不在意，只想把这个子进程消灭掉，可以设置这个参数为NULL。

#### waitpid()

```c
pid_t waitpid(pid_t pid, int *status, int options) 
```

作用和wait()完全相同，但是多了两个可由用户控制的参数pid和options。

pid参数指示一个子进程的ID，表示只关心这个子进程退出的SIGCHLD信号。如果pid=-1时，那么和wait()作用相同，都是关心所有子进程退出的SIGCHLD信号。

options参数主要有WNOHANG和WUNTRACED两个选项，WNOHANG可以使waitpid()调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其他任务。

#### 孤儿进程

一个父进程退出，而它的一个或者多个子进程还在运行，那么这些进程将成为孤儿进程。

孤儿进程将被init进程（进程号为1）收养，并由init进程对他们完成状态收集工作。

由于孤儿进程会被init进程收养，所以孤儿进程不会对系统造成危害。

#### 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过wait()或者waitpid()获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用wait()或者waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。

僵尸进程通过ps命令显示出来的状态为Z（zombie）。

系统所能使用的进程号是有限的，如果大量产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被init进程所收养，这样init进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

### 基本命令

- cpu使用率：top 或 /proc/stat cpu
- 内存使用率：free 或 /proc/meminfo
- 磁盘使用情况：du（disk usage）（磁盘使用量，占用的磁盘空间）（通过搜索文件来计算每个文件的大小然后累加）
- 磁盘空间及使用情况： df -h（使用文件系统支持）
- 网络相关信息：netstat
- 查看进程端口号：netstat -apn | grep 8080
- grep -v逐行过滤不符合条件的 -e正则表达式
- 查看带宽：nload
- 最后登陆信息：last，即访问/var/log/wtmp
- /var/log/messages：centos记录操作系统常见的系统和服务错误信息
- /var/log/syslog：ubuntu记录操作系统常见的系统和服务错误信息
- 统计文件中出现次数最多的前10个单词
  - cat word.txt | sort | uniq -c | sort | -k1,1nr | head - 10
  - sort命令对一行一个单词的列表进行排序
  - uniq -c命令对排序号的单词列表统计每个单词出现的次数
  - 再用sort按照单词出现的次数从大到小排序，如果出现频率相同，则再按字母顺序排序
  - uniq -c只对相邻的行可以进行合并
  - -n使用纯数字进行排序，-r倒序，-k指定字段，-t指定分隔符

#### 查看端口被哪个进程占用

lsof -i:端口号

#### 查看进程打开了哪些文件

lsof -p pid

#### Top

**字段含义**

- PID：进程的id
- USER：进程的所有者
- PR：进程的优先级别，越小越优先被执行
- NInic：值??
- VIRT：进程占用的虚拟内存
- RES：物理内存
- SHR：共享内存
- S：进程的状态：S表示休眠（interruptable）D（Uninterruptable），R表示正在运行，Z表示僵尸进程，N表示该进程优先值为负数，I？ T？
- %CPU：进程CPU占用率
- %MEM：进程使用的物理内存和总内存的百分比
- TIME+：该进程启动后占用的总的CPU时间，占用CPU即累加
- COMMAND：进程启动命令名称

**参数**

- top -p 进程id 查看具体的进程的内存占用
- top -u 用户名 查看用户的进程内存
- top之后，输入M按照内存排序，输入P按照CPU排序，输入T按照占用CPU时间排序

#### 查看CPU核的个数、主频

cat /proc/cpuinfo

#### linux创建守护进程

1. 创建子进程，父进程退出：子进程成为孤儿进程，被init进程收养，使用fork()函数，如果返回值大于0，表示为父进程，exit(0)，父进程退出，子进程继续。
2. 在子进程中创建新会话，使当前进程成为新会话的组长：使用setsid（）函数，如果当前进程不是进程组的组长，则为当前进程创建一个新的会话期，使当前进程成为这个会话组的首进程，成为这个进程组的组长
3. 改变当前目录为根目录：由于守护进程在后台运行，开始于系统开启，终止于系统关闭，所以要讲其目录改为系统的根目录下。进程在执行时，其文件系统不能被卸下
4. 重新设置文件权限掩码：进程从父进程那里继承了文件创建掩码，所以可能会修改守护进程存取权限位，所以要讲文件创建掩码清除，umask（0）
5. 关闭文件描述符：子进程从父进程那里继承了打开文件描述符，所以用close即可关闭

#### 查看进程下的线程

Top -H -p 进程id

```shell
top -H -p <pid>
ps -T -p <pid>
```

#### 查看行数

1. 显示100行到150行的内容：sed - n "100,150p" filename（p表示print显示）
2. 有一个文件ip.txt，每行一条ip记录，如何实现统计出现次数最多的前3个ip及次数：sort ip.txt | uniq -c | sort -rn | head -n 3
3. 同上，统计ip地址出现次数：sort ip.txt | uniq -c | sort -rn
4. 统计最多的前10个单词：sort word.txt | uniq -c | sort -k1,1rn | head -n 10

### Vim

#### 打开与退出

- vi file：打开文件file

- :q：退出vi编辑器

- :wq：保存缓冲区的修改并退出编辑器

- :q!：不保存直接退出

- :w：保存缓冲区内容至默认的文件

- :w file：保存缓冲区的内容至file文件

#### 插入文本

- a：在光标的右边插入文本
- A：在光标行的末尾插入文本
- i：在当前光标的左边插入文本
- I：在当前光标所在行的开始插入文本
- o：在当前行下面新建一行
- O：在当前行的上面新建一行
- R：替换当前光标位置以及以后的若干文本
- J：链接光标所在行和下一行

#### 删除文本

- x：删除一个字符
- dd：删除一行
- ndd：删除n行
- u：撤销上一次操作
- U：撤销对当前行的所有操作

#### 搜索

- /word 从前向后搜索第一个出现的word
- ?word 从后向前搜索第一个出现的word

#### 设置行号

- :set nu：在屏幕上显示行号
- :set nonu：取消行号

#### 其他

- dd，删除并放入缓冲区，可以使用put（p或P）访问该缓冲区
- yy，复制指定位置文本到缓冲区
- p，将指定缓冲区的内容放在当前光标位置之上
- P，将指定缓冲区的内容放在当前光标位置之下

### Linux管道通信机制

实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4KB，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，如果在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够空间供write()调用写

读取进程也可能工作得比写进程快。当所有当前进程数据已经被读取时，管道空。此种情况下，一个随后的read()调用将默认地被阻塞，等到某些数据写入，者解决了read()调用返回文件结束的问题。

### Linux锁

1. 互斥锁：互斥锁只能有一对线程使用，就是用来互斥的。

2. 信号量：

3. 自旋锁自旋锁上锁后让等待线程进行忙等待而不是睡眠阻塞，而信号量时让等待线程睡眠阻塞。自旋锁的忙等待浪费了处理器的时间，但通常很短，在1ms以下。

   

## 网络

// TODO 20200301

缓存、Cookie、socket

数据库基本原理

MySQL

// TODO 20200302

系统设计。。。工具

### HTTP

#### 请求报文与响应报文

##### 请求报文

HTTP请求：请求行，请求头，空行和请求体

请求行：get/post url的path路径，http版本

请求头：键值对，每行一对，键值之间用英文冒号

空行

请求体

##### 响应报文

HTTP响应：状态行，响应头，空行和响应体

状态码：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可以用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK

响应头部：键值对，包含详细信息。如指定响应过期日期、指定用来用来给用户安全的传输实体内容的编码格式

空行

请求体：包含了响应的内容。它可以包含HTML代码、图片等。

##### 常见请求头和响应头

![image-20200217162838755](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200217162838755.png)

![image-20200217162848140](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200217162848140.png)

##### 请求方法

- OPTIONS：返回服务器对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送*的请求来测试服务器的功能性；
- HEAD：向服务器请求与GET请求相一致的响应，只不过响应体将不会被范围。可以获取包含在响应头中的元信息；
- GET：向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中。
- POST：向指定资源提交数据进行处理请求（例如提交表单或上传文件）。数据被包含在请求体中，POST可能会导致新的资源建立或已有资源的修改（副作用）。
- PUT：向指定资源位置上传其最新内容
- DELETE：请求服务器删除Request-URL所标识的资源
- TRACE：回显服务器收到的请求，主要用于测试或诊断
- CONNECT：HTTP/1.1协议中预留给能够将链接改外管道方式的代理服务器

#### HTTP请求过程

1. 客户端连接到WEB服务器：一个HTTP客户端，通常为浏览器，与WEB服务器的HTTP端口（默认80）建立一个TCP套接字连接
2. 发送HTTP请求：通过TCP套接字，客户端向WEB服务器发送一个文本的请求报文；
3. 服务器接收请求并返回HTTP响应：WEB服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，由客户端读取；
4. 释放TCP链接：若connection模式为close，则服务器主动关闭TCP链接，客户端被动关闭连接，释放TCP连接；若connection模式为keep-alive，则该连接会保持一段时间，在该时间内可以继续接收请求
5. 客户端浏览器解析HTML内容：客户端浏览器首先解析状态行。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对器进行格式化，并在浏览器窗口中显示

#### GET和POST的区别

- GET用于获取资源，而POST用于传输实体主体
- GET参数以查询字符串形式URL中（只支持ASCII编码，中文字符需要转码，URL长度有限制），POST参数存储在实体主体中。（支持多种编码，“相对”更安全，长度无限制）。
- GET请求安全（只是可读的HEAD、OPTIONS），即不会改变服务器状态；POST（PUT、DELETE）不是。
- GET是幂等的（所有安全方法都是幂等），而POST不是。
- 可缓存：GET、HEAD可缓存，PUT、DELETE不可缓存，POST大多数情况下不可缓存。缓存还需满足：状态码可缓存，包括200、203、204、206、300、301、404、410、414、501；响应报文的Cache-control首部字段没有指定不进行缓存。

#### HTTP状态码

| 代码 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 100  | (继续)请求这应该继续提出请求。服务器返回此代码表示已经收到请求的第一部分，正在等待其余部分 |
| 101  | （切换协议）请求者以要求服务器切换协议，服务器已确认并准备切换 |
| 2xx  | 成功表示成功处理了请求的状态代码                             |
| 200  | （成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页 |
| 201  | （已创建）请求成功并且服务器创建了新的资源                   |
| 202  | （已接受）服务器已接受请求，但尚未处理                       |
| 203  | （非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一来源 |
| 204  | （无内容）服务器成功处理了请求，但没有返回任何内容           |
| 205  | （重置内容）服务器成功处理了请求，但没有返回任何内容         |
| 206  | （部分内容）服务器成功处理了部分GET请求                      |
| 3xx  | 重定向，表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向 |
| 300  | （多种选择）针对请求，服务器可以执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。 |
| 301  | （永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置 |
| 302  | （临时移动）服务器目前从不同位置的响应网页请求，但请求者应继续使用原有位置进行以后的请求 |
| 303  | （查看其他位置）请求者应当对不同的位置单独使用GET请求来检索响应 |
| 304  | （未修改）自从上次请求后，请求的网页未修改过。不会返回网页内容 |
| 305  | （使用代理）请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理 |
| 307  | （临时重定向）服务器目前从不同的位置响应网页请求，但请求者应继续使用原有位置进行以后的请求 |
| 4xx  | 请求错误                                                     |
| 400  | （错误请求）服务器不理解请求的语法                           |
| 401  | （未授权）服务器要求身份验证。对于需要登录的网页             |
| 403  | （禁止）服务器拒绝请求                                       |
| 404  | （未找到）服务器找不到请求的网页                             |
| 405  | （方法禁用）禁用请求中指定的方法                             |
| 406  | （不接受）无法使用请求的内容特性响应请求的网页               |
| 407  | （需要代理授权）与401类似，但指定请求者应该授权使用代理      |
| 408  | （请求超时）服务器等候请求时发生超时                         |
| 409  | （冲突）服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 |
| 410  | （已删除）如果请求的资源已永久删除，服务器返回此响应）       |
| 411  | （需要有效长度）服务器不接受不含有效内容长度标头字段的请求   |
| 412  | （未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件 |
| 413  | （请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器处理能力。 |
| 414  | （请求的URI过长）请求的URI（通常为网址）过长，服务器无法处理 |
| 415  | （不支持的媒体类型）请求的格式不受请求页面的支持             |
| 416  | （请求范围不符合要求）如果页面无法提供请求的范围，则服务器会返回此 |
| 417  | （未满足期望值）服务器未满足“期望”请求标头字段的要求         |
| 5xx  | 服务器错误，表示服务器在尝试处理请求时发生内部错误。可能是服务器本身的错误，而不是请求出错 |
| 500  | （服务器内部错误）服务器遇到错误，无法完成请求               |
| 501  | （尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能返回此。 |
| 502  | （错误网关）服务器作为网关或代理，从上游服务器收到无效响应   |
| 503  | （服务不可用）服务器目前无法使用（由于超载或停机维护）。     |
| 504  | （网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求 |
| 505  | （HTTP版本不受支持）服务器不支持请求中所用的HTTP协议版本     |
| 600  | 源站没有返回响应头部，只返回实体内容                         |
|      |                                                              |
|      |                                                              |
|      |                                                              |
|      |                                                              |
|      |                                                              |

#### URI与URL

##### URI

URI，通一资源标志符(Uniform Resource Identifier， URI)，表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行定位的。

URI结构组成：

- 访问资源的命名机制

- 存放资源的主机名

- 资源自身的名称

- 如：https://blog.csdn.net/qq_32595453/article/details/79516787

  我们可以这样解释它：

  ①这是一个可以通过https协议访问的资源，

  ②位于主机 blog.csdn.net上，

  ③通过“/qq_32595453/article/details/79516787”可以对该资源进行唯一标识（注意，这个不一定是完整的路径）

  注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，**URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。**

##### URL

**URL是URI的一个子集**。它是Uniform Resource Locator的缩写，译为“统一资源定位 符”。

通俗地说，**URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。**

采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。**URL是URI概念的一种实现方式**。

URL的一般格式为(带方括号[]的为可选项)：

protocol :// hostname[:port] / path / [;parameters][?query]#fragment

URL的格式由三部分组成： 

- 第一部分是协议(或称为服务方式)。
- 第二部分是存有该资源的主机IP地址(有时也包括端口号)。
- 第三部分是主机资源的具体地址，如目录和文件名等。

第一部分和第二部分用“://”符号隔开，

第二部分和第三部分用“/”符号隔开。

第一部分和第二部分是不可缺少的，第三部分有时可以省略。 

##### 区别

URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。

#### HTTP长、短链接、无状态

无状态：HTTP协议时无状态的，指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的UDP协议。

短链接：在HTTP/1.0中默认使用短连接，即客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问某个HTML或其他类型的WEB页中包含其他的WEB资源（如js、pic、css等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

长连接：HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入：Connection:keep-alive。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接实质上是TCP协议的长连接和短连接。

##### 什么时候用长连接、短连接

**长连接**多用于操作频繁，点对点通讯，而且连接数不能太多的情况。每个TCP连接都需要三次握手，需要时间。如果每个操作都是先连接再操作的话处理速度会降低很多。所以诶个操作后完成后不断开，再次处理时直接发送请求即可。例如，数据库的连接用长连接，如果用短连接频繁的通信会操成socket错误，而且频繁的socket创建也是对资源的浪费。

而像WEB网站的http服务器一般使用短连接，因为长连接对于服务端来说会耗费一定的资源，而像Web网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。

#### HTTP/1.1与HTTP/1.0的区别

1. HTTP/1.0需要keep-alive参数来告知服务器建立一个长连接，而**HTTP/1.1默认支持长连接**。
2. HTTP/1.1**支持只发送header信息**（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送给服务器，这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。
3. **host域**：HTTP/1.0没有host域，HTTP/1.1才支持host域
4. 带宽优化及网络连接的使用，HTTP/1.0中，存在带宽浪费的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来，并且不支持断点续传功能，**HTTP/1.1则在请求头引入了range域，它允许只请求资源的某个部分**，及返回码是206，这样就方便了开发者自由的选择以便于充分利用带宽和连接。

#### HTTP/2.0与HTTP/1.0的区别

**新的二进制格式**：HTTP1.x的解析是基于文本。基于文本系诶的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。二进制则不同，只认0和1的组合，基于这种考虑，HTTP/2.0的洗衣解析决定采用二进制格式，实现方便且健壮。

**多路复用**：即连接共享，建立起一个连接请求后，可以在这个连接上一直发送，不要等待上一次发送完并且收到回复后才能发送下一个，是可以同时发送多个请求，而且互不干扰。

**header压缩**：HTTP2.0利用HPACK对消息头进行压缩传输，客户端和服务器维护一个动态链表（当一个头部没有出现的时候，就插入，已经出现了就用表中的索引值进行替代），既避免了重复header的传输，又减小了需要传输的大小。

**服务端推送**：客户端请求html时，服务器顺带把此html需要的css，js也一起发送给客户端。

#### 转发与重定向

**转发时服务器行为，重定向是客户端行为。**

**转发过程**：客户端浏览器发送http请求->web服务器接受此请求->调用内部的一个方法在容器内完成请求处理和转发动作->将母包资源发送给客户；这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己容器内的request。客户端浏览器路径栏仍显示的是其第一次访问的路径，也就是说客户端感受不到服务器做了转发。转发行为是浏览器只做了一次访问请求。

**重定向过程**：客户端浏览器发送http请求->web服务器接受后发送302状态码响应及对应新的location给客户端浏览器->客户端浏览器收到后自动再发送一个新的HTTP请求，请求url是新的location地址->服务器根据此请求寻找资源并返回给客户。这里，location可以重定向到任意url，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户端浏览器路径栏显示其重定向的路径，客户可以观察到地址的变化。重定向行为是浏览器做了至少两次的访问请求。

### TCP/UDP

#### TCP头部

![image-20200210143256036](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200210143256036.png)

- ACK设置为1，表示前面的确认是有效的
- PSH设置为1，表示要求对方在接到数据之后立即将请求递交给应用程序，而不是缓冲起来直到缓冲区收满为止。一些交互式应用需要，降低命令的响应时间
- RST设置为1，表示当前TCP连接出现严重问题，必须释放重连，用于重置一个已经混乱的链接
- SYN用于建立连接的过程
- FIN用来释放一个连接
- 窗口大小：指定了从被确认的字节算起可以发送多少个字节。
- 校验和：校验范围包括TCP头、数据报内容和概念性伪头部。概念性伪头部又包括源IP、目的IP，TCP协议号
- URG设置为1，表示本数据报的数据部分包含紧急信息，此时紧急指针有效。紧急数据一定位于当前数据报数据部分的最前面，紧急指针表名了紧急数据的尾部

三次握手需要的信息：

- ACK：**TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文ACK必须为1**，ACK为确认位
- SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1，因此SYN置1就表示这是一个请求连接或连接接受报文
- FIN：用来释放一个连接。但FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

#### TCP与UDP的区别

|          | TCP                                                          | UDP                                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可靠性   | 可靠，无差错、不丢失、不重复、按序到达，TCP通过校验和、序号标识、滑动窗口、确认应答等机制实现可靠传输 | 不可靠，尽最大努力交付                                       |
| 连接性   | 面向连接                                                     | 无连接                                                       |
| 报文     | 面向字节流                                                   | 面向报文（保留报文的边界）                                   |
| 效率     | 对系统资源要求多，传输效率低                                 | 对系统资源要求较少，传输效率高                               |
| 双工性   | 全双工                                                       | 一对一、一对多、多对一、多对多                               |
| 流量控制 | 有（滑动窗口）                                               | 无                                                           |
| 用塞控制 | 有（慢开始、拥塞避免、快重传、快恢复）                       | 无                                                           |
| 传输速度 | 慢                                                           | 快                                                           |
| 应用场合 | 对效率要求相对较低，但对准确性要求相对高！或者有要求有连接的场景 | 对效率要求相对高，对准确性要求相对低的场景                   |
| 应用示例 | TCP一般用于<br />**文件传输**（FTP、HTTP对数据准确性要求高，速度可以相对慢）<br />**发送或者接收邮件**（pop，imap，SMTP对数据准确性要求高，非紧急应用）<br />**远程登陆**（telnet，ssh对数据准确性有一定要求，有连接）等等 | UDP一般用于<br />**即时通信**（QQ聊天，对数据准确性和丢包要求比较低，但速度必须快）<br />**在线视频**（rstp速度一定要快，保证视频连续，但是偶尔坏一帧还是能接受）<br />**网络语音电话**（VoIP语音数据报一般比较小，需要高速发送，偶尔断音或串音也没问题）等 |
| 对应协议 | FTP：文件传输协议，使用21端口。<br />Telnet：用于远程登陆，可以提供一种基于DOS模式下的通信服务，使用23端口。<br />SMTP定义了简单邮件传送协议，用于发送邮件，25号端口。<br />POP3:与SMTP对应，POP3常用于接受邮件。通常POP3使用110端口<br />HTTP协议：从Web服务器传输超文本到本地浏览器的传送协议。 | DNS：域名协议服务，将域名地址转换为IP地址，用53号端口。<br />SNMP：简单网络管理协议，用161端口，用来管理网络设备，由于网络设备多，无连接的服务体现出优势。<br />TFTP（Trival File Transfer Protocal）：简单文件传输协议，该协议在熟知端口69上使用UDP服务。 |

#### TCP三次握手

![image-20200212154418299](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200212154418299.png)

![image-20200212152210484](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200212152210484.png)

1. 首先由Client发出请求连接，SYN=1，ACK=0，TCP规定SYN=1时不能携带数据，但要消耗一个序号，因此声明自己的序号是seq=x；
2. 然后Server进行回复确认，即SYN=1，ACK=1，seq=y，ack=x+1（ACK为确认位，ack为确认号，ack表明下一个预期接收的报文seq）
3. 然后Client再进行一次确认，不需要SYN，此时ACK=1，seq=x+1，ack=y+1，完成连接建立。

**为什么是三次握手而不是两次？**

> 主要是为了防止已经失效的连接请求报文段突然又传送到了B，因而产生错误。
>
> “已经失效的连接请求报文段”：
>
> 考虑正常情况：A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。没有“已经失效的连接请求报文段”；
>
> 考虑一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以导致延误到连接释放以后的某个时间才到达B。B收到了这个失效的连接请求报文段后，就误认为是A又发出一次心的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么B只要发出确认，新的连接就建立了。
>
> 由于A现在没有发出连接的请求，因此A可以不理会B的确认，也不会向B发送数据。但B却以为连接已经建立，并一致等待A发来数据，导致B的资源浪费。

上面不准确。

- 确保通信双向正常。
- 同步序列号：为了实现可靠数据传输，TCP协议的通信双方，都必须维护一个序列号，以表示发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是通信双方告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。（如果两次，对方B无法确认其选择的序列号是否被A正确接收）

**序列号（32位）的作用**

建立连接时，告知对方自己的起始序列号；传输阶段，用于标识每个报文段，进而保证报文段的按序。

在建立连接时发送的第一个报文段中，双方都提供一个初始序列号。**TCP标准推荐使用以4ms间隔递增1的计数器值作为这个初始序列号的值。使用计数器可以防止连接关闭再重新连接时出现相同的序列号。**
　　 对于那些包含数据的报文段，报文段中第一个数据字节的数量就是初始序列号，其后数据字节按顺序编号。**如果源主机使用同样的连接发送另一个报文段，那么这个报文段的序列号等于前一个报文段的序列号与前一个报文段中数据字节的数量之和**。例如，假设源主机发送3个报文段，每个报文段有100字节的数据，且第一个报文段的序列号是1000，那么第二个报文段的序列号就是1100（1000＋100），第三个报文段的序列号就是1200（1100＋100）。
　　 **如果序列号增大至最大值将复位为0。**

**确认号（32位）**

目的主机返回确认号，使源主机知道某个或几个报文段已被接收。如果ACK控制位被设置为1，则该字段有效。**确认号等于顺序接收到的最后一个报文段的序号加报文段字节数，这也是目的主机希望下次接收的报文段的序号值。**返回确认号后，**计算机认为已接收到小于该确认号的所有数据。**
　　 例如，序列号等于前一个报文段的序列号与前一个报文段中数据字节的数量之和。例如，假设源主机发送3个报文段，每个报文段有100字节的数据，且第一个报文段的序列号是1000，那么接收到第一个报文段后，目的主机返回含确认号1100的报头。接收到第二个报文段（其序号为1100）后，目的主机返回确认号1200。接收到第三个报文段后，目的主机返回确认号1300。
　　 目的主机不一定在每次接收到报文段后都返回确认号。在上面的例子中，目的主机可能等到所有3个报文段都收到后，再返回一个含确认号1300的报文段，表示已接收到全部1200字节的数据。但是如果目的主机再发回确认号之前等待时间过长，源主机会认为数据没有到达目的主机，并自动重发。
　　 上面的例子中，如果目的主机接收到了报文段号为1000的第一个报文段以及报文段号为1200的最后一个报文段，则可返回确认号1100，但是再返回确认号1300之前，应该等待报文段号为1100的中间报文段。

#### TCP四次挥手

![image-20200212154609203](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200212154609203.png)

假设Clinet端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，“Client端没有数据要发了”，但Server可以继续发送数据。因此Server先发ACK，“你的请求我收到了，请继续等我的消息”。此时Client端进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端的数据发送完成，向Cient端发送FIN报文，“Server数据发完了，准备好关闭连接了”。Client收到FIN报文之后，“知道可以关闭连接了，但他还不相信网络，怕Server端不知道要关闭，所以发送ACK之后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传“，Server端收到ACK后，就知道可以断开连接了。Client等待2MSL后依然没有收到重传，证明Server端已经关闭，那么CLient端也可以关闭了。

**为什么是4次挥手？**

因为TCP有个半关闭状态，假设A、B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，此时A不发数据，但是B如果发数据A还要接收，然后B还要发给A连接释放报文，然后A发确认，所以4次；

TIME_WAIT阶段要等待2个MSL时间才关闭，因为网络原因可能要重返，CLOSE_WAIT是要等待自己（通常是服务器）把自己传输的东西发送完了。

**为什么连接的时候是三次握手，关闭的时候四次？**

因为当Server端收到Client的SYN连接请求后，可以直接发送SYN+ACK。其中ACK用于应答，SYN用于发起请求（同步序号）。

但是关闭连接时，当Server端收到FIN报文时，很可能还有数据要发送，因此先回一个ACK，表明收到FIN。等Server端的所有报文都发送完了，Server再发送FIN。因此ACK和FIN不能一起发送，之后Client需要回个ACK，一共四次。

**为什么TIME_WAIT状态需要经过2MSL（最大报文段生存时间）才能返回到CLOSE状态？**

我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来等待重发可能丢失的ACK报文的。在最后一个ACK若丢失，Server没有收到，将不断重复发送FIN报文段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。

如果说发送ACK立即关闭连接，首先服务器端的连接无法正确被释放，浪费资源；其次如果客户端启动新的进程，重新向服务端发起请求时，由于服务端还在等待最后一次ACK，他收到SYN就会被服务器认为是请求码错误，服务端就会回复RET重置连接。

Client在发送ACK之后进入到TIME_WAIT状态，同时设置一个计时器，等待2MSL时间。如果在该时间内再次收到FIN，那么Client回重发ACK并再次等待2MSL（2倍的MSL Maximun Segment Lifetime），2SML就是一个发送和一个回复需要的最大时间；如果在该时间内没有收到FIN，那么Client认为ACK已经成功倍接收，结束TCP进程。

**为什么不能用两次握手？**

3次握手完成两根重要的功能：

- 双方做好数据收发的准备工作（双方都知道彼此已准备好）
- 双方同步初始序列号，在握手过程中被发送和确认

**如果已经建立了连接，但是客户端突然出现了故障怎么办？**

TCP设有一个保活计时器，服务器每收到一次客户端的请求后会重新复位这个计时器，时间通常为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75s发送一次。如果发送10个探测报文仍无反应，服务器认为客户端出现故障，然后关闭连接。

**大量的TIME_WAIT怎么办？**

开启重用，允许将TIME_WAIT中的sockets重新用于新的TCP连接；

#### TCP粘包问题——nagle算法

##### 粘包

发送端为了将多个发往接收端的包，更有效的发到对象，使用了优化方法（nagle算法），将多次间隔较小且数据量小的数据，合并称一个大的数据块，然后进行封包。这样接收端难以分辨，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。解决办法：

- 对于发送方咋成的粘包现象，我们可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭Nagle算法
- 发送**定长包**，如果每个消息的大小都是一样的，那么在接收对等方之遥累计接收数据，直到数据等于一个定长的数值就将他作为一个消息
- 包尾部加上\r\n标记。FTP协议的做法。问题在于如果数据征文也含有\r\n，则会产生误判（FTP怎么解决的？）
- 包头加上包体长度。包头是定长的四字节，说明了包体的长度。接收对等方先接收包体长度，根据包体长度来接收包体

- 使用更加复杂的应用层协议。

##### Nagle算法

Tcp默认开启。

Nagle算法：如果发送端欲多次发送包含少量字符的数据包，则发送端会将第一个小包发送出去，而后面到达的少量字符数据都缓存起来而不立即发送，直到收到接收端对前一个数据报文段的ACK确认，或当前字符属于紧急数据，或者积攒到了一定数量的数据（如缓存的字符数据达到数据包报文段的最大长度）等情况才将其组成一个较大的数据包发送出去。

Nagle算法在一些场景下能够提高网络利用率、降低包处理主机资源消耗，但是在某些场景下不太行。

Minshall对Nagle算法所做的改进简言之：在判断当前包是否可发送时，之需要检查最近的一个小包是否已经确认

#### TCP如何保证可靠性传输

1. 数据包校验：出错丢弃，等待发送端超时后重传
2. 数据合理分片和排序（UDP难以分片重组，一片数据丢失就无法重组，导致丢弃整个UDP数据包）
3. 对失序数据包重排序
4. 丢弃重复数据
5. 应答机制：通常不是立即发送，延迟几分之一秒发送确认（ack？）
6. 超时重发：TCP发出一个段之后，启动一个定时器，等待目的端确认。如果不能及时确认，将重发这个报文段
7. 流量控制：每一方都有一个固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，接收方来不及处理时会通知降低发送速率，这可以防止较快主机致使较慢主机的缓冲区溢出导致包丢失，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。
8. 拥塞控制：网络拥塞时，减少数据的发送。发送方让自己的发送窗口等于拥塞窗口。
   1. 慢启动
   2. 拥塞避免
   3. 快重传和快恢复
   4. 滑动窗口：安全性考量

#### TCP流量控制

原因：发送方把数据发送得过快，接收方可能会来不接接收，这会造成数据的丢失

原理：**利用滑动窗口实现，接收方告诉发送方自己的接收窗口大小，然后发送方发送窗口不能超过接收方给出的接收窗口值。**

#### TCP拥塞控制

##### 慢启动

发送方维持一个叫做拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。

慢开始算法：不一开始就发送大量数据，先探测网络拥塞程度，由小到大逐渐增加拥塞窗口的大小。

例子：以报文段个数的拥塞窗口为例（实际是以字节为单位的），窗口指数增长

![image-20200212232336006](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200212232336006.png)

为防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh：

当cwnd<ssthresh时，使用慢开始算法；

当cwnd>ssthresh时，改用拥塞避免算法；

当cwnd=ssthresh时，慢开始与拥塞避免算法任意。

##### 拥塞避免

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。拥塞窗口按线性规律缓慢增长。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判断，所以都按拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口大小设置为1，执行慢开始算法。

![image-20200212233241651](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200212233241651.png)

##### 快重传和快恢复

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方尽早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置爹重传计时器时间到期。如图：

 ![image-20200213003537697](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213003537697.png)

快重传配合使用快恢复算法，要点：

- 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不是执行慢启动算法。
- 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢启动，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法，如图： ![image-20200213003910988](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213003910988.png)

##### 滑动窗口机制（流量控制）

- 发送窗口

![image-20200213181858647](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213181858647.png)

发送窗口的大小由接收窗口的剩余大小决定，接受者会把当前接收窗口的剩余大小写入应答TCP报文段的头部（窗口字段，16bit，选项中可以添加放大倍数），发送着收到相应应答后，根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小时不断变化的。发送窗口由三个指针构成：

- P1:P1指向发送窗口的后沿，它后面的字节表示已经发送且收到应答；

- P2:P2指向尚未发送的第一个字节。P1-P2之间的表示已发送字节，还没收到确认。P2-P3表示可以发送，仍未发送的字节；
- P3:P3指向发送窗口的前沿，它前面（右边）的字节尚未发送，且不允许发送。

发送者每收到一个应答后，后沿可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。当p2和前沿重合时，发送着必须等待确认应答。

- 接收窗口

![image-20200213184209137](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213184209137.png)

接收者收到的字节会存入接收窗口，接受者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。

如果某些字节并未按序到达，接受者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送（？）。

- 注意

各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。

#### TCP状态转移

![image-20200213185118945](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213185118945.png)

**当一个tcp监听了80端口后，udp还能否监听80端口**

由于TCP和UDP时两个完全独立的软件模块，因此各自的端口号也相互独立

**TCP的滑动窗口机制，如果保证不重复发送的**

 ？？？

**描述TCP滑动窗口机制，如何实现流量控制**

接收方接收能力不足，则通知TCP协议栈缩小TCP的接收窗口。然后TCP协议栈在下个段发送时包含新的窗口大小通知给对端，对端按通知的窗口来改变发送窗口，以此达到减缓发送速率的目的。

另，如果出现发送拥塞，发送窗口缩小为原来的一半，同时将超时重传的时间间隔扩大一倍。

**防止xss攻击和sql攻击** 

在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制。Xss脚本攻击类型分为：非持久型xss攻击、持久型xss攻击。

1.非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。

2.持久型xss攻击会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。

防止Xss攻击：过滤表单提交的数据，将可疑的内容去掉。

所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

防止sql注入的方法主要有：

1.使用存储过程

2.校验输入的字符串

3.参数化sql

在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值，用@或？来表示参数。

**TCP包可以被篡改吗**

可以吧

**TCP/IP协议栈**

![image-20200213192344403](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213192344403.png)

### 计算机网络分层模型

#### OSI七层/TCP/IP四层

- 应用层：对应用程序的通信服务/telnet、http、ftp、nfs、smtp等
- 表示层：定义数据格式及加密/加密，ASCII等
- 会话层：定义如何开始、控制和结束一个会话（包括对多个双向消息的控制和管理）/RPC，SQL
- 传输层：决定选择差错恢复协议还是无差错恢复协议；在同一主机上对不同应用的数据流的输入进行复用；对收到的顺序不对的数据包的重新排序。/TCP、UDP、SPX
- 网络层：定义了端到端的包传输，还定义了逻辑地址，路由/IP、ICMP、ARP、RARP、IPX
- 数据链路层：研究单个连路上如何传输数据，与介质有关/802.11、802.3
- 物理层：定义了有关传输介质的特性标准

| OSI七层    | TCP/IP四层 | 网络协议                                 |                                                              |
| ---------- | ---------- | ---------------------------------------- | ------------------------------------------------------------ |
| 应用层     | 应用层     | HTTP、TFTP、FTP、NFS、WAIS、SMTP         |                                                              |
| 表示层     | 应用层     | Telnet、Rlogin、SNMP、Gopher             |                                                              |
| 会话层     | 应用层     | SMTP、DNS                                |                                                              |
| 传输层     | 传输层     | TCP、UDP                                 | 1、为端到端连接提供传输服务<br />2、这种传输服务分为可靠和不可靠的，其中TCP是典型的可靠传输，而UDP则是不可靠传输<br />3、为端到端连接提供流量控制，差错控制，服务质量等管理服务 |
| 网络层     | 网络层     | IP、ICMP、ARP、RARP、AKP、UUCP           | 路由与中继，网络层还可以实现拥塞控制、网际互连等功能         |
| 数据链路层 | 数据链路层 | FDDI、Ethernet、Arpanent、PDN、SLIP、PPP |                                                              |
| 物理层     | 数据链路层 | IEEE 802.1a，IEEE 802.2-202.11           |                                                              |



### IP

### 网络攻击

### DNS——浏览器中输入URL到页面加载完成发生了什么

#### DNS的解析过程

- 查询DNS，获取域名对应的IP地址
  - 浏览器搜索自身的DNS缓存
  - 搜索操作系统的DNS缓存
  - 读取本地的HOST文件
  - 发起一个DNS的系统调用
    - 宽带运营商服务器查看本身缓存
    - 运营商服务器发起一个迭代DNS解析请求
- 浏览器获得域名对应的IP地址后，发起TCP发次握手，建立TCP链接
- TCP链接建立起来后，浏览器就可以向服务器发送HTTP请求了
- 服务器根据这个请求，根据路径参数，经过后端一些处理生成HTML页面代码返回给浏览器
- 浏览器拿到完成的HTML页面代码开始解析和渲染，如果遇到引用外部JS、CSS、图片等静态资源，它们同样时一个个HTTP请求，都需要经过上面的步骤

#### CDN

其中在DNS通过域名解析程IP地址的过程中，会涉及到DNS重定向的问题。

定义：CDN，英文Content Delivery Network，内容分发网络，目的就是通过现有的Internet中增加新的网络架构，将网站内容发布到离用户最近的网络边缘，提高用户访问网站的速度，更像是增加了一层CAHCE（缓存）层。

功能：当用户访问加入CDN服务器的网站时，域名解析请求将最终交给全局负载均衡DNS进行处理。全局负载均衡DNS通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务。

组成：每个CDN节点由两部分组成：负载均衡设备和高速缓存服务器。负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率。同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载DNS的通信，实现整个系统的负载均衡。

高速缓存服务器（Cache）负载存客户网站的大量信息，就像一个靠近用户的网站服务器一样响应本地用户的访问请求。

#### 在浏览器输入www.bytedance.com后执行的全部过程

1. 客户端浏览器通过DNS解析到该URL的IP地址为xxx，通过这个IP地址找到客户端到服务器的路径，客户端浏览器发起一个http会话到xxx，然后通过TCP进行封装数据包，输入到网络层。
2. 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器用80端口监听客户端的请求，客户端由系统随机选择一个端口，如5000，与客户端进行交换，服务器把相应的响应返回给客户端的5000端口。
3. 客户端的网络层不用关心应用层和传输层的东西，主要是路由。

### HTTPS

#### 简介

HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。

#### HTTPS与HTTP区别

- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
- http是超文本传输协议，信息明文传输，https则是具有安全性的ssl加密传输协议。
- http和https使用的是完全不同的连接方式，端口也不同，前者80，后者443。
- http的连接简单，无状态；https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
- http的url以http://开头，https的url以https://开头
- OSI模型中，http工作于应用层，https工作在传输层？？？？？
- http运行在tcp之上；https运行在ssl/tls之上，ssl/tls运行在TCP之上，内容加密，采用对称加密，密钥用服务器方的证书进行非对称加密，客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。

#### HTTPS通信过程

**非对称加密是构造难以解决的数学问题来保证安全性的**

**所以加密或解密必然会有一边很慢**

![image-20200213211903889](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213211903889.png)

1. A与B通过TCP建立连接，初始化SSL层。
2. 进行SSL握手，A发送HTTPS请求，传送客户端SSL协议版本号、支持的加密算法、随机数等。
3. 服务器B把CA证书（包含B的公钥），把自己选择的加密算法、随机数等回传给A。
4. A收到CA证书，验证证书有效性。
5. 校验通过，客户端？随机？产生一个字符串作为与B通信的对称密钥（根据双方同意的SSL连接的安全等级建立**会话密钥**），通过CA证书里的公钥，对其加密，发送给服务端![image-20200213212800550](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213212800550.png)
6. B用私钥解开信息，得到随机字符串（对称密钥/根据双方同意的SSL连接的安全等级会话密钥），利用这个会话密钥作为之后的通信密钥。
7. 客户端向服务器发出消息，指明后面的数据使用该会话密钥（对称）进行加密，同时通知服务器SSL握手结束。
8. 服务器接收到信息，使用会话（对称）密钥通信，返回响应，通知客户端握手结束。
9. SSL握手结束。
10. ![image-20200213223523338](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200213223523338.png)

##### 如何向证书的发布机构去申请证书

举个例子方便大家理解，假设我们公司"ABC Company"花了1000块钱，向一个证书发布机构"SecureTrust CA"为我们自己的公司"ABC Company"申请了一张证书，注意，这个证书发布机构"SecureTrust CA"是一个大家公认并被一些权威机构接受的证书发布机构，我们的操作系统里面已经安装了"SecureTrust CA"的证书。"SecureTrust CA"在给我们发布证书时，把Issuer,Public key,Subject,Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个指纹算法计算出这些数字证书内容的一个指纹，并把指纹和指纹算法用自己的私钥进行加密，然后和证书的内容一起发布，同时"SecureTrust CA"还会给一个我们公司"ABC Company"的私钥给到我们。我们花了1000块钱买的这个证书的内容如下：

×××××××××××××××证书内容开始×××××××××××××××××

Issuer : SecureTrust CA

Subject : ABC Company

Valid from ： 某个日期

Valid to： 某个日期

Public Key : 一串很长的数字

…… 其它的一些证书内容……

{证书的指纹和计算指纹所使用的指纹算法}[SecureTrust CA的私钥|RSA]   //这个就是"SecureTrust CA"对这个证书的一个数字签名，表示这个证书确实是他发布的，有什么问题他会负责(收了我们1000块，出了问题肯定要负责任的)

×××××××××××××××证书内容结束×××××××××××××××××

​        ***\**\*// 记不记得前面的约定？{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密\*\**\***

 

我们"ABC Company"申请到这个证书后，我们把证书投入使用，我们在通信过程开始时会把证书发给对方，对方如何检查这个证书的确是合法的并且是我们"ABC Company"公司的证书呢？首先应用程序(对方通信用的程序，例如IE、OUTLook等)读**取证书中的Issuer(发布机构)为"SecureTrust CA"** ，然后会**在操作系统中受信任的发布机构的证书中去找"SecureTrust CA"的证书**，如果找不到，那说明证书的发布机构是个水货发布机构，证书可能有问题，程序会给出一个错误信息。 如果在系统中找到了"SecureTrust CA"的证书，那么应用程序就会**从证书中取出"SecureTrust CA"的公钥**，然后**对我们"ABC Company"公司的证书里面的指纹和指纹算法用这个公钥进行解密，然后使用这个指纹算法计算"ABC Company"证书的指纹，将这个计算的指纹与放在证书中的指纹对比**，如果一致，说明"ABC Company"的证书肯定没有被修改过并且证书是"SecureTrust CA" 发布的，证书中的公钥肯定是"ABC Company"的。对方然后就可以放心的使用这个公钥和我们"ABC Company"进行通信了。

#### SSL工作原理

握手协议、记录协议、警报协议

1. 握手协议
   1. Client给出协议版本号、一个客户端生成的随机数（CLient random）、客户端支持的加密方法。
   2. Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）
   3. Client确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。
   4. Server使用自己的私钥，获取Client发来的随机数（Premaster secret）
   5. Client和Server根据约定的加密算法，使用前面的三个随机数，生成“对话密钥（session key）”，用来加密接下来的整个对话过程。
2. 记录协议
3. 警报协议

#### 输入网址的时候，浏览器如何判断你是http协议还是https协议?

1.问题

拿淘宝来说事。

在浏览器中通常人们输入淘宝的网址有taobao.com www.taobao.com http://www.taobao.com

而最终浏览器中的显示的网址是https://www.taobao.com,这是怎么实现的呢？

2.taobao.com -> www.taobao.com

taobao.com 和www.taobao.com是不同的域名，淘宝会把相似的域名都买下来，都定向到同一个域名下。

当输入taobao.com 返回的是302重定向，使浏览器访问www.taobao.com

而百度的实现方式的通过返回 刷新元信息 http://www.baidu.com/“>

使浏览器刷新到www.baidu.com，实现原理大抵相似。

3.http://www.taobao.com -> https://www.taobao.com

http默认端口是80，https默认端口是443。

很多网站都提供https服务，为了避免用户输入http导致访问80端口出现访问不通的情况，同时也是为了与http版本的网站兼容，服务器监听80端口，对所有的80端口的访问都定向到https的url，实现方式都多种，最简单的就是使用302重定向，将其重定向到https://www.taobao.com

这实现了http->https,但是不能每次都重定向，http协议实现了一个叫做HSTS机制。返回的302报文中有这样一条

Strict-Transport-Security: max-age=31536000\r\n

其含义是强制浏览器在max-age到期之前，把所有的http://www.taobao.com自动转换成https://www.taobao.com

是浏览器实现的url转换，不用每次访问两次服务器，一步到位。这样避免了302跳转80->443的中间人劫持的问题。所以之后每次访问就不会出现302了，只有第一次会出现。

小结

通过上面的案例可以知道，浏览器默认的端口一直都是80端口，也就是说**默认情况下它是走的http协议，那么为了让它通过https协议来访网站，服务器（服务器决定）实际上做了这些事情**。
1.使用http协议并监听80端口，等待浏览器的访问.
2.在监听的80端口上设置url重定向，指向监听端口为443的https协议的网站
3.通过这样一种方式就可以实现网站地址的重定向了。

因此，即使你输入http://www.baidu.com:80,做了重定向的服务器也会将此url修改为https://www.baidu.com:443。也就是说，实际判断的过程是由服务器来保证的，浏览器的默认端口一直都是80端口。

### Socket

#### I/O模型

一个输入操作通常包括两个阶段：

- 等待数据准备好
- 从内核向进程复制数据

对于套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二部就是把数据从内核缓冲区复制到应用进程缓冲区。

Unix有五种I/O模型：

- 阻塞式I/O
- 非阻塞式I/O
- I/O复用（select和poll）
- 信号驱动式I/O（SIGIO）
- 异步I/O（AIO）

##### 阻塞式IO

应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。

应该注意到，在阻塞的过程中，其它应用进程还可以执行，**因此阻塞不意味着整个操作系统都被阻塞**。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。

下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。![image-20200302111324221](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200302111324221.png)

##### 非阻塞式I/O

应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为**轮询（polling）**。

由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。

![image-20200302111410510](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200302111410510.png)

##### I/O复用

使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。

它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。

如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，**I/O 复用不需要进程线程创建和切换的开销，系统开销更小。**![image-20200302111431618](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200302111431618.png)

##### 信号驱动I/O

应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。![image-20200302111625023](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200302111625023.png)

##### 异步I/O

应用程序执行aio_read系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

异步I/O与信号驱动I/O的区别在于，异步I/O的信号是通知应用进程I/O完成，而信号驱动I/O的信号是通知应用进程可以开始I/O。![image-20200302112415812](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200302112415812.png)

##### 五大I/O模型

- 同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。
- 异步I/O：第二阶段应用程序不会阻塞，直接从内核缓冲区复制到应用进程缓冲区，复制完通知应用进程来处理，可能基于回调机制吧。

同步I/O包括阻塞式I/O、非阻塞式I/O、I/O复用和信号驱动I/O，它们的主要区别在第一个阶段。

非阻塞式I/O、信号驱动I/O和异步I/O在第一阶段不会阻塞。

![image-20200424191616334](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200424191616334.png)

#### I/O复用

select/poll/epoll都是I/O多路复用的具体体现，select出现的最早，之后是poll，再是epoll。

##### select

```
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

select 允许应用程序**监视一组文件描述符**，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。

- **fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。**有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。
- timeout 为超时参数，调用 select 会**一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout**。
- 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。

##### poll

```
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
```

poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。

采用链表的方式替换原有数组结构，使得没有连接数量的限制？？

poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：

```
struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };
```

##### 比较

**功能**

select和poll的功能基本相同，不过在一些实现细节上有所不同。

- select会修改描述符，而poll不会
- select的描述符类型使用数组实现，FD_SETSIZE大小默认为1024，因此默认只能监听少于1024个描述符。如果要监听更多描述符的话，需要修改FD_SETSIZE之后重新编译；而poll没有描述符数量的限制；
- poll**提供了更多的事件类型**，并且对描述符的重复利用上比select高。
- 如果一个线程对某个描述符调用了select或者poll，另一个线程关闭了该描述符，会导致调用结果不确定。

**速度**

select和poll速度**都比较慢，**每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。

**可移植性**

**几乎所有的系统都支持select，但只有比较新的系统支持poll。**

##### epoll

```
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);

```

epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被**维护在一棵红黑树上**，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。

从上面的描述可以看出，**epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次**，并且进程**不需要通过轮询来获得事件完成的描述符**。

epoll 仅**适用于 Linux OS**。

epoll 比 select 和 poll **更加灵活而且没有描述符数量限制**。

epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。

##### 工作模式

epoll的描述符事件有两种触发模式：LT（level trigger）和ET（edge trigger）

LT**模式**

当 epoll_wait() 检测到描述符事件到达时，将此事件**通知进程**，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

**ET模式**

和 LT 模式不同的是，**通知之后进程必须立即处理事件**，**下次再调用 epoll_wait() 时不会再得到事件到达的通知。**

很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

##### 应用场景

**select应用场景**

select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。

select 可移植性更好，几乎被所有主流平台所支持。

**poll应用场景**

poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。

**epoll应用场景**

只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。

需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。

需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。

## 数据库

### 事务

#### 概念

事务指的是满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。

![image-20200301010120836](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301010120836.png)

#### 数据库（事务）特性ACID

##### 原子性（Atomicity）

事务里的所有操作要么全部做完，要么都不做。事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务失败，需要回滚。

回滚可以使用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

##### 一致性（Connsistency）

从一个一致性状态到另一个一致性状态。例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。能量守恒？

在一致性状态下，所有事务对同一个数据的读取结果都是相通的。

##### 隔离性（Isolation）

一个事务所做的所有修改在最终提交之前，对其他事务不可见。

##### 持久性（Durability）

持久性是指一旦事务提交，它所做的修改将会永久地保存在数据库上，即使宕机也不会丢失。

系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

事务的ACID特性概念简单，但是不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的。

- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久性是为了能够应对系统奔溃的情况。

![image-20200301153706240](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301153706240.png)

##### AUTOCOMMIT

MySQL默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当作一个事务并自动提交。

### 并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

#### 丢失修改

T1和T2两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。

![image-20200301154144157](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301154144157.png)

#### 读脏数据

T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。

![image-20200301154223812](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301154223812.png)

#### 不可重复读

T2读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。

![image-20200301154329185](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301154329185.png)

#### 幻影读

T1读取某个范围内的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。

![image-20200301154420982](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301154420982.png)

产生并发不一致的问题主要原因是破坏了事务的隔离性，解决办法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

### 封锁

#### 封锁粒度

MySQL中提供了两种封锁粒度：行级锁以及表级锁。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个平衡。

#### 封锁类型

##### 读写锁

- 互斥锁（Exclusive），X锁，又称写锁；
- 共享锁（Shared），S锁，又称读锁。

有以下两个规定：

- 一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其他事务不能对A加任何锁。
- 一个事务对数据对象A加了S锁，可以对A进行读取操作，但是不能进行更新操作。加锁期间其它事务可以对A加S锁，但是不能加X锁。

锁的兼容关系：![image-20200301161226703](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301161226703.png)

##### 意向锁

使用意向锁（Intenetion Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要先检测是否有其他事务对表A或者表A中的任意一行加了锁，那么久需要对表A的每一行都检测一次，这是非常耗时的。

意向锁在原来的X/S锁之上引入了IX/IS，IX/IS都是表锁，用来表示一个事务想要在表中的某个数据行上加X锁或S锁。有以下两个规定：

- 一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁；
- 一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁。

通过引入意向锁，事务T想要对表A加X锁，只需要先检测是否有其他事务对表A加了X/IX/S/IS锁，如果加了就表示有其他事务正在使用这个表或者表中某一行的锁，因此事务T加X锁失败。

各种锁的兼容关系如下：

![image-20200301162216209](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301162216209.png)

解释：

- 任意IS/IX锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- 这里兼容关系针对的是表级锁，而表级的IX锁和行级的X锁兼容，两个事务可以对两个数据行加X锁。（事务T1想要对数据行R1加X锁，事务T2想要对同一个表的数据行R2加X锁，两个事务都需要对该表加IX锁，但是IX锁是兼容的，并且IX锁与行级锁X锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。

#### 封锁协议

##### 三级封锁协议

**一级封锁协议**

事务T要修改数据A时必须加X锁，知道T结束才释放锁。

可以解决丢失修改的问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

![image-20200301162609449](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301162609449.png)

**二级封锁协议**

在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。

可以解决读脏数据的问题，因为如果一个事务在对数据A进行修改，根据1级封锁协议，会加X锁，那么久不能再加S锁了，也就是不会读入数据。

![image-20200301162734993](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301162734993.png)

**三级封锁协议**

在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁。

可以解决不可重复读的问题，因为读A时，其他事务不能对A加X锁，从而避免了在读的期间数据发生改变。

![image-20200301162850457](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301162850457.png)

##### 两段锁协议

加锁和解锁分为两个阶段进行。

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性的问题。

事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化掉的。

```
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度

```
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```

#### MySQL隐式与显式锁定

MySQL的InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB也可以使用特定的语句进行显示锁定

```
SELECT ... LOCK In SHARE MODe;
SELECT ... FOR UPADTE;
```

### 事务隔离级别（恶果：脏读、幻读、不可重复读）

Mysql默认级别：可重复读。

![image-20200216114757843](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200216114757843.png)

### InnoDB如何解决幻读_多版本并发控制

#### 基本思想

在封锁中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而MVCC利用了多版本的思想，写操作更新最新的版本快照，而的操作取读旧版本快照，没有互斥关系，这一点和CopyOnWrite类似。

在MVCC中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其他事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读，MVCC规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算事脏读。

#### 版本号

- 系统版本号SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增；
- 事务版本号TRX_ID：事务开始时的系统版本号。

#### Undo日志

MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。

例如在MySQL创建一个表t，包含主键id和一个字段x。我们先插入再更新。

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用START TRANSACTION将上面的操作当成一个事务来执行，根据MySQL的AUTOCOMMIT机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号TRX_ID和操作之外，还记录了一个bit的DEL字段，用于标记是否被删除。

![image-20200301164817317](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301164817317.png)

INSERT、UPDATE、DELETE操作会创建一个日志，并将事务版本号TRX_ID写入。DELETE可以看成是一个特殊的UPDATE，还会额外将DEL字段设置为1。

#### ReadView

MVCC维护了一个ReadView结构，主要包含了当前系统未提交的事务列表TRX_IDs{TRX_ID_1，TRX_ID_2，...}，还有该列表的最小值TRX_ID_MIN和TRX_ID_MAX。

![image-20200301165022252](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200301165022252.png)

在进行SELECT操作时，根据数据行快照的TRX_ID与TRX_ID_MIN和TRX_ID_MAX之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：如果TRX_ID在TRX_IDs列表中，表示该数据行快照对应的事务还没提交，则该快照不可使用，否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其他事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行的到的值就会发生改变，即不可重读。

在数据行快照不可使用的情况下，需要沿着Undo Log的回滚指针ROLL_PTR找到下一个快照，再进行上面的判断。

#### 快照读与当前读

##### 快照读

MVCC的SELECT操作是快照中的数据，不需要进行加锁操作。

```
SELECT * FROM table ...;
```

##### 当前读

MVCC其它会对数据库进行修改的数据（INSERT、UPDATE、DELETE）需要进行行加锁操作，从而读取最新的数据。可以看到MVCC并不是完全不用加锁，而只是避免了SELECT的加锁操作。

在进行SELECT操作时，可以强制指定进行加锁操作。以下第一个语句需要加S锁，第二个需要加X锁。

```
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
```

#### InnoDB解决幻读

在RR隔离级别下，InnoDB采用MVCC和next-key locks解决幻读，MVCC（Multi-Version Concurrency Control,翻译为中文即 多版本并发控制）解决的是普通读（快照读）的幻读，next-key locks解决的是当前读情况下的幻读。

##### 当前读

指的是枷锁的select、update、delete等语句。在RR下，数据库会使用next-key locks来锁住本条纪录以及索引区间。锁住纪录之间的范围，避免范围间插入纪录，以避免产生幻读行纪录

##### 普通读

普通读是不会加锁的读，因此解决手段是MVVC。MVCC（可以认为乐观锁的一种实现），乐观锁大多是基于数据版本纪录机制实现，即为数据增加一个版本标识，在数据库中一般是为表增加一个version字段来实现。读取出数据时，将版本号一同读出；之后更新时，对版本号加一。

MVVC会给每一行元组加一些辅助字段，纪录创建版本号和删除版本号（额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴））。

而在每一个事务在启动的时候，都有一个唯一的递增的版本号。每开启一个新事务，事务的版本号就会递增。

RR级别下，增删改查变为：

- SELECT：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的纪录。现在我读取的话，必须同时满足两个条件的
  1. 读取创建版本小于或等于当前事务版本号  这意味着数据在这个事务之前被创建
  2. 删除版本为空或大于当前事务版本号的记录。 这意味着删除操作在这个事务之后发生
- INSERT：将当前事务的版本号保存至行的创建版本号![image-20200216120425083](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200216120425083.png)
- UPDATE：新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原纪录行的删除版本号设置为当前的事务版本号![image-20200216120435259](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200216120435259.png)
- DELETE：将当前事务的版本号保存至行的删除版本号。![image-20200216120458178](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200216120458178.png)

注：在RC级别下，MVCC不能解决幻读和不可重复读，因为每次读它都会读它自己刷新的快照版本，简单来说就是另一个事务提交，他就刷新一次，去读最新的。

#### 乐观锁和悲观锁

**悲观锁**

> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

**乐观锁**

> 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

**两种锁的使用场景**

> 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适

#### **Innodb中的锁**

> 锁
> Innodb中基本锁有以下4种：
> 行级锁
> 1). 共享锁(S Lock) ： 允许事务读一行数据
> 2). 排它锁(X Lock) ： 允许事务删除或更新一行数据
> 表级锁
> 3). 意向共享锁(IS Lock)：事务想要获得一张表中某几行的共享锁
> 4). 意向排它锁(IX Lock)：事务想要获得一张表中某几行的排它锁
> 由于Innodb引擎支持的均为行锁，所以意向锁其实不会阻塞除全表扫描之外的任何请求

![img](https://pic1.zhimg.com/80/v2-0dc1d80bc32d131eec460017c7b77e10_hd.jpg)

### Next-Key Locks

Next-Key Locks是MySQL的InnoDB存储引擎的一种锁实现。

MVCC不能解决幻影读问题，Next-Key Locks就是为了解决这个问题而存在的。在可重复RR隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题。

#### Record Locks

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB会自动在主键上创建隐藏的聚簇索引，因此Record Locks依然可以使用。

#### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在t.c中插入15.

```
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

#### Next-Key Locks

它是Record Locks和Gap Locks的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10，11，13，and20，那么锁定：

```
(-oo, 10]
(10,11]
(11,13]
(13,20]
(20,+oo)
```

### 关系数据库设计理论

#### 函数依赖

记A->B表示A函数决定B，也可以说B函数依赖于A。

如果{A1,A2,....,An}是关系的一个或多个属性的集合，该集合函数决定了关系的其他所有属性并且是最小的，那么该集合就称为键码。

对于A->B，如果能找到A的真子集A'，使得A'->B，那么A->B就是部分函数依赖，否则就是完全函数依赖。

对于A->B，B->C，则A->C是一个传递函数依赖。

#### 异常

以下的学生课程关系的函数依赖为{Sno，Cname}->{Sname, Sdept, Mname, Grade}，键码为{Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| ---- | ------ | ------ | ------ | ------ | ----- |
| 1    | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100   |
| 3    | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95    |

不符合范式的关系，会产生很多异常，主要有以下四种异常：

- 冗余数据：例如 `学生-2` 出现了两次。
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 `课程-1` 需要删除第一行和第三行，那么 `学生-1` 的信息就会丢失。
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

#### 范式

范式理论是为了解决以上提到的四种异常。

高级别范式的依赖于低级别的范式，1NF是最低级别的范式。

##### 第一范式（1NF）

属性不可分。

##### 第二范式（2NF）

每个非主属性完全函数依赖于键码。

可以通过分解来满足。

**分解前**

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| ---- | ------ | ------ | ------ | ------ | ----- |
| 1    | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80    |
| 2    | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100   |
| 3    | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95    |

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：

- Sno -> Sname, Sdept
- Sdept -> Mname
- Sno, Cname-> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

**分解后**

关系-1

| Sno  | Sname  | Sdept  | Mname  |
| ---- | ------ | ------ | ------ |
| 1    | 学生-1 | 学院-1 | 院长-1 |
| 2    | 学生-2 | 学院-2 | 院长-2 |
| 3    | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖：

- Sno -> Sname, Sdept
- Sdept -> Mname

关系-2

| Sno  | Cname  | Grade |
| ---- | ------ | ----- |
| 1    | 课程-1 | 90    |
| 2    | 课程-2 | 80    |
| 2    | 课程-1 | 100   |
| 3    | 课程-2 | 95    |

有以下函数依赖：

- Sno, Cname -> Grade

##### 第三范式（3NF）

非主属性不传递函数依赖于键码。

上面的 关系-1 中存在以下传递函数依赖：

- Sno -> Sdept -> Mname

可以进行以下分解：

关系-11

| Sno  | Sname  | Sdept  |
| ---- | ------ | ------ |
| 1    | 学生-1 | 学院-1 |
| 2    | 学生-2 | 学院-2 |
| 3    | 学生-3 | 学院-2 |

关系-12

| Sdept  | Mname  |
| ------ | ------ |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |

### 索引

#### 索引特点、优缺点

- 索引的特点
  - 可以加快数据库的检索速度
  - 降低数据库插入、修改、删除等维护的速度？？（缺点）
  - 只能创建在表上，不能创建到视图上 
  - 可以直接创建，也可以间接创建
  - 可以在优化隐藏中使用索引
  - 使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引
- 索引的优点
  - 创建唯一性索引，可保证数据库中每一行数据的唯一性
  - 大大加快数据的检索速度，这是创建索引的最主要原因
  - 加速数据库表之间的连接，特别是在实现数据的参考完整性方面
  - 在使用分组和排序字句进行数据检索时，同样可以显著减少查询中分组和排序的时间
  - 通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能
- 索引的缺点
  - 创建索引和维护索引需要耗费时间，该时间随数据量的增加而增加
  - 索引需要占用物理空间，出了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立索引，那么需要的空间就会更大
  - 当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度

#### 索引使用的注意事项

```sql
SELECT 'sname' FROM 'stu' WHERE 'age'+10=30; --不会使用索引，因为所有索引列参与了计算
SELECT 'sname' FROM 'stu' WHERE LEFT('date',4) < 1990; --不会使用索引，因为对索引列进行了函数运算
SELECT * FROM 'houduanwang' WHERE 'uname' LINKE 'houdun%'; --走索引
SELECT * FROM 'houduanwang' WHERE 'uname' LINKE '%houdun%'; --不走索引
-- 正则表达式不使用索引
-- 字符串与数字比较不使用索引
CREATE TABLE 'a' ('a',char(10));
EXPLAIN SELECT * FROM 'a' WHERE 'a'="1" -- 走索引
EXPLAIN SELECT * FROM 'a' WHERE 'a'=1 -- 不走索引

SELECT * FROM dept WHERE dname='xxx' or loc='xx' or deptno=45 --如果条件中有or，即时其中有条件带索引也不会使用。即要求使用的所有字段，都必须建立索引
-- 如果mysql估计使用全表扫描要比使用索引快，则不使用索引
```

- 索引失效
  - 如果条件中有or，即时其中有条件带索引也不会使用
  - 对于多列索引，不是使用的第一部分，则不会使用索引
  - like查询是以%开头的
  - 如果列类型是字符串，那么移动要在条件中使用引号引起来，否则不会使用索引
  - 如果mysql估计使用全表扫描比使用索引快，则不使用索引

#### 索引适用场景

在什么情况下适合建立索引：

- 为经常出现在关键字order by、group by、distinct后面的字段，建立索引
- 在union等集合操作的结果集字段上，建立索引
- 为经常用作查询选择的字段，建立索引
- 在经常用作表连接的属性上，建立索引
- 考虑使用索引覆盖，对数据很少被更新的表，如果用户经常只查询其中几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描

性别不适用于建立索引？为什么？

访问索引需要付出额外的IO开销，从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO。假如从表的100万行数据中取出几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了。但是你从100万行数据中取出50万行数据，就比如性别字段，那你相对需要访问50万次索引，再王文50万次表，加起来的开销并不会比直接对表进行一次完整扫描小。

#### 索引分类

- 组合索引：实质上是将多个字段建立到一个索引里，列值的组合必须唯一

- 聚集索引：数据行的物理顺序与列值（一般是主键那列）的逻辑顺序相同，一个表中只能拥有一个聚集索引

- 非聚集索引：唯一索引、普通索引、主键索引、全文索引

  - UNIQUE：唯一索引，不可以出现相同的值，可以有NULL值
  - INDEX：普通索引，允许出现相同的索引内容
  - PROMAY KEY：主键索引，不允许出现相同的值（默认聚集索引）
  - fulltext index：全文索引，可以针对值中的某个单词，但效率确实不敢恭维

- 第一：聚集索引的约束是唯一性，是否要求字段也是唯一的呢？     不要求唯一！

  　　分析：如果认为是的朋友，可能是受系统默认设置的影响，一般我们指定一个表的主键，如果这个表之前没有聚集索引，同时建立主键时候没有强制指定使用非聚集索引，SQL会默认在此字段上创建一个聚集索引，而主键都是唯一的，所以理所当然的认为创建聚集索引的字段也需要唯一。

    　　结论：聚集索引可以创建在任何一列你想创建的字段上，这是从理论上讲，实际情况并不能随便指定，否则在性能上会是恶梦。

    　　第二：为什么聚集索引可以创建在任何一列上，如果此表没有主键约束，即有可能存在重复行数据呢？

    　　粗一看，这还真是和聚集索引的约束相背，但实际情况真可以创建聚集索引。

    　　分析其原因是：如果未使用 UNIQUE 属性创建聚集索引，数据库引擎将向表自动添加一个四字节 uniqueifier 列。必要时，数据库引擎 将向行自动添加一个 uniqueifier 值，使每个键唯一。此列和列值供内部使用，用户不能查看或访问。

    　　第三：是不是聚集索引就一定要比非聚集索引性能优呢?

    　　如果想查询学分在60-90之间的学生的学分以及姓名，在学分上创建聚集索引是否是最优的呢？

    　　答：否。既然只输出两列，我们可以在学分以及学生姓名上创建联合非聚集索引，此时的索引就形成了覆盖索引，即索引所存储的内容就是最终输出的数据，这种索引在比以学分为聚集索引做查询性能更好。

    　　第四：在数据库中通过什么描述聚集索引与非聚集索引的？

    　　索引是通过二叉树的形式进行描述的，我们可以这样区分聚集与非聚集索引的区别：聚集索引的叶节点就是最终的数据节点，而非聚集索引的叶节仍然是索引节点，但它有一个指向最终数据的指针。

    　　第五：在主键是创建聚集索引的表在数据插入上为什么比主键上创建非聚集索引表速度要慢？

    　　有了上面第四点的认识，我们分析这个问题就有把握了，在有主键的表中插入数据行，由于有主键唯一性的约束，所以需要保证插入的数据没有重复。我们来比较下主键为聚集索引和非聚集索引的查找情况：聚集索引由于索引叶节点就是数据页，所以如果想检查主键的唯一性，需要遍历所有数据节点才行，但非聚集索引不同，由于非聚集索引上已经包含了主键值，所以查找主键唯一性，只需要遍历所有的索引页就行（索引的存储空间比实际数据要少），这比遍历所有数据行减少了不少IO消耗。这就是为什么主键上创建非聚集索引比主键上创建聚集索引在插入数据时要快的真正原因。

- 创建索引语句

  - 普通索引

    ```sql
    ALERT TABLE table_name ADD index index_name(column_list);
    ```

  - 唯一索引

    ```sql
    ALERT TABLE table_name ADD UNIQUE (column_list);
    ```

  - 主键索引

    ```
    ALERT table table_name add primary key (column_list);
    ```

  - 组合索引

    ```
    ALTER TABLE USER_DEMO ADD INDEX name_city_age（LOGIN_NAME（16），CITY，NAME）；
    建表时，LOGIN_NAME长度为100，这里为16，是因为一般情况下名字的长度不会超过16，这样会加快索引查询速度，还会减少索引文件的大小，提高INSERT、UPDATE的更新速度。
    如果分别给LOGIN_NAME，CITY，AGE建立单列索引，让该表有三个单列索引，查询时和组合索引的效率时大不一样的，甚至会远远低于我们的组合索引。虽然此时有三个索引，但mysql只能用到其中的那个它认为似乎时最有效率的单列索引，另外两个是用不到的，也就是说还是一个全表扫描的过程。
    建立这样的组合索引，就相当于分别建立如下三种组合索引
    LOGIN_NAME,CITY,AGE
    LOGIN_NAME,CITY
    LOGIN_NAME
    为什么没有CITY、AGE这样的组合索引呢，因为mysql索引最左前缀的结果。即从最左边的开始组合，并不是只要包含这三列的查询都会用到该索引。也就是说name_city_age（LOGIN_NAME(16)，CITY，AGE）从左到右进行索引，如果没有左前索引，mysq不会执行索引查询。
    
    ```

    

- 直接创建和间接创建

  - 直接：CREATE INDEX mycolumn_index ON mytable（mycolunm）
  - 间接：定义主键约束或者唯一性约束，可以间接创建索引

- 普通索引和唯一性索引

  - 普通索引：CREATE INDEX mycolunm_index oN mytable（mycolumn）
  - 唯一性索引：保证在索引列中的全部数据是唯一的，对聚集索引和非聚集索引都可以使用CREATE UNIQUE COUSTERED INDEX mycolumn——index ON mytable（mycolumn）；
  - 普通索引允许被索引的数据包含重复的值
  - 如果确定某列数据彼此不同，那么使用UNIQUE，一是简化了MySQL对索引的管理工作，**更有效率**；二是MySQL会在有新纪录插入时，自动检查新纪录这个字段的值是否已经在某个记录的这个字段出现过了，如果是Mysql将会聚会插入新纪录。
  - 主键索引，也就是唯一索引，检索主键，一次；普通索引存主键的地址，检索两次

- 单个索引和组合索引

  - 单个索引：非组合
  - 组合索引：在索引建立语句中同时包含多个字段名，最多16个字段CREATE INDEX name_index ON username（firstname，lastname）

- 聚集索引和非聚集索引

  - 聚集索引：MySQL中的主键就是聚集索引，定义，数据行的物理顺序与列值（一般是主键）的逻辑顺序相同，一个表中只能拥有一个聚集索引

- 主索引和外键索引

  - 主索引和唯一索引的唯一区别是，前者使用PRIMARY后者使用UNIQUE
  - 主索引：CREATE PRIMARY COYSTERED INDEX my column_index ON mytable(mycolumn)//ALTER TABLE 'tablename' ADD PRIAMRY KEY('column')
  - 外键索引：

- 索引太多：删除数据，修改索引字段，新增操作都会对索引进行维护，维护开销大，同时需要更大的磁盘空间







## Java基础

// TODO

完善笔记

刷题

面试题思考模拟

项目：olsrd+LSTM



对象头

### 数据类型

#### 基本数据类型

| 数据类型     | 关键字  | 字节数 | 取值范围                         | 默认值      |
| ------------ | ------- | ------ | -------------------------------- | ----------- |
| 布尔型       | boolean | 1      | true，false                      | false       |
| 字节型       | byte    | 1      | -128-128                         | 0           |
| 短整型       | short   | 2      | -2<sup>15</sup>~2<sup>15</sup>-1 | 0           |
| 整形         | int     | 4      | -2<sup>31</sup>~2<sup>31</sup>-1 | 0           |
| 长整形       | long    | 8      | -2<sup>63</sup>~2<sup>63</sup>-1 | 0           |
| 字符型       | char    | 2      | 0~2<sup>16</sup>-1               | '\u0000'(0) |
| 单精度浮点型 | float   | 4      | （符号位）1.4013E-45~3.4028E+38  | 0.0F        |
| 双精度浮点型 | Double  | 8      | （符号位）4.9E-324~1.7977E+308   | 0.0D        |
|              |         |        |                                  |             |

boolean可以使用1bit存储，但是具体大小没有明确规定。JVM会在编译时期将boolean类型的数据转换为int，使用1来表示true，使用0来表示false。Java支持boolean数组，但是是通过读写byte数组来实现的。

#### 包装类型

基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱和自动拆箱完成。

自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化，反之就是自动拆箱。

原始类型：boolean\char\byte\short\int\long\float\double

封装类型：Boolean\Charactor\Byte\Short\Integer\Long\Float\Double

#### 缓存池

new Integer(123)与Integer.valueOf(123)的区别：

- new Integer(123)每次都新建一个对象
- Integer.valueOf(123)会使用缓存池中的对象，多次调用会取得同一个对象的引用

valueOf()方法的实现比较简单，先判断值是否在缓存池中，如果在的话就直接返回缓存池内容，否则new一个。

Java8中，Integer缓存池大小默认为-128~127

基本类型对应的缓存池：

- boolean：true false
- byte：all
- short：-128~127
- int：-128~127
- char：\u0000 - \u007F

缓存池下界固定，上界可调：在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小。

#### String转出int型，判断能不能转，如何转

可以转，得处理异常Integer.parseInt(s)主要为NumberFormatException：

1. 当输入为字母时，也就是内容不是数字时，如abcd
2. 输入为空
3. 输入超出int上限

#### 关于自动类型转换

```java
short s1 = 1; s1 = s1 + 1;
short s1 = 1; s1 += 1;
```

1. 对于1，在s1+1运算时会自动提升表达式的类型为int（因为1为int），那么将int赋值给short类型的s1会出现类型转换错误。
2. 对于2，+=时java语言规定的运算符，java编译器会对它进行特殊处理

#### 基本数据类型与包装类型的区别

int和Integer的区别：

1. Integer是int的包装类，int则是java的一种基本数据类型；
2. Integer变量必须实例化后才能使用，而int变量不需要；
3. Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象，而int直接存储数据值；
4. Integer的默认值是null，int的默认值是0

延伸：

1. 由于Integer变量实际是引用，所以两个通过new生成的Integer变量永远是不相等的
2. Integer变量和int变量比较时，只要变量的值是相等的，结果就为true（比较时，自动拆箱）
3. 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false（非new指向java常量池中的对象，new Integer()指向堆中新建的对象，两者在内存中地址不同）
4. 对于两个非new生成的Integer，比较时，如果两个变量值区间在-128-127之间，结果为true，否则为false（对于这个范围的数，java会缓存，下次再使用时，直接从缓存中取）



#### 字节字符区别

字节时存储容量的基本单位，字符时数字、字母、汉字以及其他语言的各种符号。

1字节=8个二进制单位；一个字符由一个字节或者多个字节的二进制单位组成。

#### Java基本类型与引用类型的区别

基本类型保存原始值，引用类型保存的是引用值（就是指对象在堆中所处的位置/地址）

### String

#### 概览

String被声明为final，因此它不可被继承。（Integer等包装类也不可）

Java 8中，String内部使用char数字存储数据。

Java 9之后，String类的实现改用byte数组存储字符串，同时使用coder标识使用哪种编码。

value数组被声明为final，意味着数组初始化之后就不能再引用其他数组。并且String内部也没有提供改变value数组的方法，因此可以保证Stirng不可变。

**不可变的好处**

1. 可以缓存hash值：因为String的hash值经常被使用，例如String用作HashMap的key。不可变的特性可以使得hash值也不可变，因此只需要进行一次计算
2. String pool的需要：如果一个String对象已经被创建过了，那么就会从String Pool中取得引用，只有String是不可变的，才可能使用String Pool。
3. 安全性：String经常作为参数，String不可变可以保证参数不可变。例如在作为网络连接参数的情况下，如果String是可变的，那么在网络连接过程中，String被修改，改变String的那一方以为现在连接的是其他主机，而实际情况却不一定是
4. 线程安全：String不可变天生具备线程安全，可以在多个线程中安全地使用。

#### String，StirngBuffer，StringBuilder

- 可变性
  - String不可变
  - StringBuffer、StringBuilder可变
- 线程安全
  - String不可变，线程安全的
  - StringBuilder不是线程安全的额
  - StringBuffer是线程安全的，内部使用synchronized进行同步

#### String Pool

字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。

当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。

在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

#### new String("abc")

使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。

- "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
- 而使用 new 的方式会在堆中创建一个字符串对象。

### 运算

#### 参数传递

Java的参数以值传递的形式传入方法中，而不是引用传递。

不能改变引用 谁，但是可以改变 谁的内容。

#### float与double

Java不能隐式执行乡下转型，因为这会使得精度降低。

1.1字面量属于double类型，不能直接将1.1赋值给float变量，因为是向下转型。

只能float f = 1.1f;

#### 隐式类型转换

因为字面量1是int类型，它比short类型精度要高，因此不能隐式地将int类型向下转型为short类型。

```java
short s1 = 1;
// s1 = s1 + 1; //不行
```

但是使用+=或者++运算符会执行隐式类型转换。

```java
s1 += 1;
s1++;
```

上面语句相当于：

```java
s1 = (short)(s1 + 1)
```

#### switch

从Java7开始，可以在switch条件判断语句中使用String对象。

```java
String s = "a";
switch(s) {
    case "a":
        System.out.println("aaa");
        break;
    case "b":
        System.out.println("bbb");
        break;
}
```

switch不支持long，是因为switch的设计初衷是对那些只有少几个值的类型进行等值判断，如果值过于复杂，那么还是用if比较合适。

### 关键字

#### final

**数据**

声明数据为常量，可以是编译时常量，也可以是运行时被初始化后不能被改变的常量。

- 对于基本类型，final式数值不变；
- 对于引用类型，final使引用不变，也就不能引用其他对象，但是被引用的对象本身是可以修改的。

**方法**

声明方法不能被子类重写。

private方法隐式地被指定为final，如果在子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新方法。

**类**

声明类不允许被继承。

#### static

**静态变量**

- 静态变量：又称类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

**静态方法**

静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

只能访问所属类的静态字段和静态方法，方法中不能有this和super关键字，因为这两个关键字与具体对象关联。

**静态语句块**

静态语句块在类初始化时运行一次。

**静态内部类**

非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。

静态内部类不能访问外部类的非静态的变量和方法。

**静态导包**

在使用静态变量和方法时不用再指明ClassName，从而简化代码，但可读性大大降低。

```java
import static com.xxx.ClassNam.*;
```

**初始化顺序**

静态变量和静态语句块优于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

最后才是构造函数的初始化。

存在继承的情况下，初始化顺序：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量，普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

### Object通用方法

#### 概览

```java
public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
```

#### equals()

1. 等价关系

   两个对象具有等价关系，需要满足：

   - 自反性：

     ```java
     x.equals(x); // true
     ```

   - 对称性

     ```java
     x.equals(y) == y.equals(x);
     ```

   - 传递性

     ```java
     if(x.equals(y) && y.equals(z))
     	x.equals(z); //true
     ```

   - 一致性

     ```java
     // 多次调用equals方法结果不变
     x.equals(y) == x.equals(y); //true
     ```

   - 与null比较

     ```java
     // 对任何不是null的对象x调用x.equals(null)结果都为false
     x.equals(null); // false
     ```

2. 等价与相等

   - 对于基本类型，==判断两个值是否相等，基本类型没有equals()方法

   - 对于引用类型，==判断两个变量是否引用同一个对象，而equals()判断引用对象是否等价。

     ```java
     Integer x = new Integer();
     Integer y = new Integer();
     System.out.println(e.equals(y)); //true
     System.out.println(x == y); //false
     ```

3. 实现

   - 检查是否为同一个对象的引用，如果是直接返回true；

   - 检查是否是同一个类型，如果不是，直接返回false；

   - 将Object对象进行转型；

   - 判断每个关键域是否相等。

     ```java
     public class EqualExample {
         private int x;
         private int y;
         private int z;
         
         public EqualExample(int x, int y, int z) {
             this.x = x;
             this.y = y;
             this.z = z;
         }
         
         @Override
         public boolean equals(Object o) {
             if(this == o) return true;
             if(o == null || getClass() != o.getClass()) return false;
             EqualExample that = (EqualExample) o;
             if(x != that.x) return false;
             if(y != that.y) return false;
             return z == that.z;
         }
     }
     ```

#### hashCode()

hashCode()返回哈希值，而equals()是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。

在覆盖equals()方法时，应当总是覆盖hashCode()方法，保证等价的两个对象哈希值也相等。

hashSet和HashMap等集合使用了hashCode()方法来计算对象应该存储的位置，因此要将对象添加到这类集合中，需要让对应的类实现hashCode()方法。

下面代码中，新建了两个等价的对象，并将它们添加到HashSet中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是EqualExample没有实现hashCode()方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。

```java
EqualExample e1 = new EqualExample(1,1,1);
EqualExample e2 = new EqualExample(1,1,1);
System.out.println(e1.equals(e2)); //true
HashSet<EqualExample> set = new HashSet<>();
set.add(e1);
set.add(e2);
System.out.println(set.size()); //2
```

理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以降将个域都当成R进制的某一位，然后组成一个R进制的整数。

R一般取31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与2相乘相当于向左移一位，最左边的位丢失。并且一个数与31相乘可以转换成移位和减法：31*x == (x<<5)-x，编译器会自动进行这个优化

```java
@Override
public int hashCode() {
 	int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
```

#### toString()

默认返回ToStringExample@4554617c这种形式，其中@后面的数值位散列码的无符号十六进制表示。

```java
public class ToStringExample {
    private int number;
    
    public ToStringExampe(int number) {
        this.number = number;
    }
}

ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());

// ToStringExample@4554617c
```

#### clone()

1. cloneable

   clone()是Object的protected方法，它不是public，一个类不显示地去重写clone()，其他类就不能直接去调用该类实例的clone()方法。

   ```java
   public class CloneExample {
   	private int a;
   	private int b;
   }
   
   CloneExample e1 = new CloneExample();
   // CloneExample e2 = e1.clone()// clone protected
   ```

   重写clone()：

   ```java
   public class CloneExample {
       private int a;
       private int b;
       
       @Override
       public CloneExample clone() throws CloneNotSupportedException {
           return (CloneExample)super.clone();
       }
   }
   
   CloneExample e1 = new CloneExample();
   try {
       CloneExample e2 = e1.clone();
   } catch (CloneNotSupportedException e) {
       e.printStackTrace();
   }
   
   java.lang.CloneNotSupportedException: CloneExample
   ```

   以上抛出了CloneNotSupportedException，这是因为CloneExample没有实现Cloneable接口。

   应该注意的是，clone（）并不是Cloneable接口的方法，而是Object的一个protected方法。Cloneable接口只是规定，如果一个类没有实现Cloneable接口又调用了clone()方法，就会抛出CloneNotSuppotedException

   ```java
   public class CloneExample implements Cloneable {
       private int a;
       private int b;
       
       @Override
       public Object clone() throws CloneNotSupportedException {
           return super.clone();
       }
   }
   ```

2. 浅拷贝

   拷贝对象和原始对象的引用类型成员变量引用同一个对象。

   ```java
   public class ShallowCloneExample implements Cloneable {
   
       private int[] arr;
   
       public ShallowCloneExample() {
           arr = new int[10];
           for (int i = 0; i < arr.length; i++) {
               arr[i] = i;
           }
       }
   
       public void set(int index, int value) {
           arr[index] = value;
       }
   
       public int get(int index) {
           return arr[index];
       }
   
       @Override
       protected ShallowCloneExample clone() throws CloneNotSupportedException {
           return (ShallowCloneExample) super.clone();
       }
   }
   
   ShallowCloneExample e1 = new ShallowCloneExample();
   ShallowCloneExample e2 = null;
   try {
       e2 = e1.clone();
   } catch (CloneNotSupportedException e) {
       e.printStackTrace();
   }
   e1.set(2, 222);
   System.out.println(e2.get(2)); // 222 浅
   ```

3. 深拷贝

   拷贝对象和原始对象的引用类型成员变量引用不同对象。

   ```java
   public class DeepCloneExample implements Cloneable {
   
       private int[] arr;
   
       public DeepCloneExample() {
           arr = new int[10];
           for (int i = 0; i < arr.length; i++) {
               arr[i] = i;
           }
       }
   
       public void set(int index, int value) {
           arr[index] = value;
       }
   
       public int get(int index) {
           return arr[index];
       }
   
       @Override
       protected DeepCloneExample clone() throws CloneNotSupportedException {
           DeepCloneExample result = (DeepCloneExample) super.clone();
           result.arr = new int[arr.length];
           for (int i = 0; i < arr.length; i++) {
               result.arr[i] = arr[i];
           }
           return result;
       }
   }
   
   DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
   try {
       e2 = e1.clone();
   } catch (CloneNotSupportedException e) {
       e.printStackTrace();
   }
   e1.set(2, 222);
   System.out.println(e2.get(2)); // 2
   
   ```
   
4. clone()的替代方案

   使用clone()方法来拷贝一个对象既复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java书中建议不要使用clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。

   ```java
   public class CloneConstructorExample {
   
       private int[] arr;
   
       public CloneConstructorExample() {
           arr = new int[10];
           for (int i = 0; i < arr.length; i++) {
               arr[i] = i;
           }
       }
   
       public CloneConstructorExample(CloneConstructorExample original) {
           arr = new int[original.arr.length];
           for (int i = 0; i < original.arr.length; i++) {
               arr[i] = original.arr[i];
           }
       }
   
       public void set(int index, int value) {
           arr[index] = value;
       }
   
       public int get(int index) {
           return arr[index];
       }
   }
   
   CloneConstructorExample e1 = new CloneConstructorExample();
   CloneConstructorExample e2 = new CloneConstructorExample(e1);
   e1.set(2, 222);
   System.out.println(e2.get(2)); // 2
   
   ```

### 继承

#### 访问权限

Java中有三个访问权限修饰符：private、protected以及public，如果不加访问修饰符，表示包级可见。

可以对类或类中的成员（字段和方法）加上访问修饰符。

- 类可见表示其他类可以使用这个类创建实例对象；
- 成员可见表示其他类可以用这个类的实例对象访问到该成员。

protected用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。

设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰地隔离开。模块之间只通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。

如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是去满足里氏替换原则。

字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如，AccessExmaple拥有id公有字段，如果在某个时刻，我们想使用int存储id字段，那么就需要修改所有的客户端代码。

```java
public class AccessExample {
	public String id;
}
```

可以使用公有的getter和setter方法来替换公有字段，这样的话就可以控制对字段的修改行为。

```java
public class AccessExample {
	private int id;
	public String getId() {
		return id + "";
	}
    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
```

但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。

```java
public class AccessWithInnerClassExample {
    private class InnerClass {
        int x;
    }
    
    private InnerClass innerClass;
    
    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }
    
    public int getValue() {
        return innerClass.x; // 直接访问
    }
}
```

#### 抽象类与接口

1. 抽象类

   抽象类和抽象方法都使用abstract关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。

   抽象类和普通类的最大区别是，抽象类不能被实例化，只能被继承。

   ```java
   public abstract class AbstractClassExample {
   	protected int x;
       private int y;
       public abstract void func1();
       
       public void func2() {
           System.out.println("func2");
       }
   }
   
   public class AbstractExtendClassExample extends AbstractClassExample {
       @Override
       public void func1() {
           System.out.println("func1");
       }
   }
   
   // AbstractClassExample ac1 = new AbstractClassExample();
   AbstractClassExample ac2 = new AbstractEXtendClassExample();
   ac2.func1();
   ```

2. 接口

   接口是抽象类的延伸，在Java 8之前，它可以看成是一个完全抽象的类，也就是说它不能有任何地方的实现。

   从Java 8开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口维护成本太高了。在Java8之前，如果一个接口想要添加新增的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。

   接口的成员（字段+方法）默认都是public的，并且不允许定义为private或者protected。

   接口的字段默认都是static和final的。

   ```java
   public interface InterfaceExample {
   	void func1();
       
       defualt void func2() {
           System.out.println("func2");
       }
       int x = 123;
       // int y; // not have been init
       public int z = 0;
       // private int k = 0;
       // protected int l = 0;
       // priavte void func3();
   }
   
   public class InterfaceImplementExample implements InterfaceExample {
       @Overried
       public void func1() {
           System.out.println("func1");
       }
   }
   
   // InterfaceExample ie1 = new InterfaceExample();
   InterfaceExample ie2 = new InterfaceImplementExample();
   ie2.func1();
   System.out.println(InterfaceExample.x);
   ```

3. 比较

   - 从设计层面上看，抽象类提供了一种IS-A关系，需要满足里氏替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像一种LIKE-A关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有IS-A关系。
   - 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
   - 接口的字段只能是static和final类型的，而抽象类的字段没有这种限制。
   - 接口的成员只能是public的，而抽象类的成员可以有多种访问权限。

4. 使用选择

   使用接口：

   - 需要让不相关的类都实现一个方法，例如不相关的类都可以实现Compareable接口中的CompareTo()方法；
   - 需要使用多重继承

   使用抽象类：

   - 需要在几个相关的类中共享代码；
   - 需要能控制继承来的成员的访问权限，而不是都为public
   - 需要继承非静态和非常量字段。

   很多情况下，接口优先于抽象类。因为九叩没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从Java8开始，接口也可以有默认的方法实现，使得修改接口的成本也变得很低。

#### super

- 访问父类的构造函数：可以使用super()函数访问父类的构造函数，从而委托父类完成一些初始化工作。应该注意到，子类一定会调用父类构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其他构造函数，那么就可以使用super()函数。

- 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用super关键字来引用父类的方法实现。

  ```java
  public class SuperExample {
      protected int x;
      protected int y;
      public SuperExample(int x, int y) {
          this.x = x;
          this.y = y;
      }
      
      public void func() {
          System.out.println("SuperExample.func()");
      }
  }
  
  public class SuperExtendExample extends SuperExample {
      private int z;
      public SuperExtendExample(int x, int y, int z) {
          super(x, y);
          this.z = z;
      }
      
      @Override
      public void func() {
          super.func();
          System.out.println("SuperExtendExample.func()");
      }
  }
  
  SuperExample e = new SuperExtendExample(1, 2, 3);
  e.func();
  SuperExample.func();
  SuperExtendExample.func();
  ```

#### 重写与重载

1. 重写

   存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。

   为了满足里氏替换原则，重写有以下三个限制：

   - 子类方法的访问权限必须大于等于父类方法；
   - 子类方法的返回类型必须是父类方法返回类型或其子类型；
   - 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型

   使用@Override注解，可以让编译器帮忙检查是否满足上面三个限制条件

   下面示例，SubClass为SuperClass的子类，SubClass重写了SuperClass的func()方法。其中：

   - 子类访问权限为public，大于父类的protected
   - 子类返回类型为ArrayList，是父类返回类型List的子类
   - 子类抛出异常类型为Exception，是父类抛出异常Throwable的子类
   - 子类重写方法使用@Overried注解，从而让编译器自动检查是否满足限制条件

   ```java
   class SuperClass {
       protected List<Integer> func() throws Throwable {
           return new ArrayList<>();
       }
   }
   
   class SubClass extends SuperClass {
       @Override
       public ArrayList<Integer> func() throws Exception {
           return new ArrayList<>();
       }
   }
   ```

   在调用一个方法时，先从本类中查找是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级别为：

   - this.func(this)
   - super.func(this)
   - this.func(super)
   - this.func(super)

   ```java
   class A {
       public void show(A obj) {
           sout("A.show(A)");
       }
       public void show(C obj) {
           sout("A.show(C)");
       }
   }
   
   class B extends A {
       @Override
       public void show(A obj) {
           sout("B.show(A)");
       }
   }
   class C extends B {
       
   }
   class D extends C {
       
   }
   
   
   public static void main(String[] args) {
       A a = new A();
       B b = new B();
       C c = new C();
       D d = new D();
       
       // 在A中存在show(A obj)
       a.show(a);
       // 不存在showb，因此将B转型为其父类A
       a.show(b);
       // b存在从a继承来的showC
       b.show(c);
       // 被不存在showd，但是存在从A继承来的showC，同时将D转型其父类C
       b.show(d);
       
       A ba = new B();
       ba.show(c); // A.show(C)
       ba.show(D); // A.show(C)
   }
   ```

2. 重载

   存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。

   应该注意，返回值不同，其他相同不算重载。

#### 封装继承多态

**Java的四个基本特性：**

- 抽象：将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象。抽象只关注对象有哪些行为和属性，并不关心这些行为的细节
- 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。
- 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对现实细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。
- 多态：指允许不同字类型的对象对同一消息作出不同的响应。

**多态的理解（多态的实现）**

- 方法重载（overload）实现编译时多态性（前绑定）
- 方法重写（override）实现运行时多态性（后绑定），精髓
- 实现多态需要做的：
  - 方法重写（子类继承父类并重写父类中已有的或抽象的方法）
  - 对象造型（用父类型引用 引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）

**项目中多态的应用**

物流管理信息系统，有订购客户和卖房客户，两个客户都可以登陆，有相同的login方法，但是登陆后会进入到不同的页面，也就是在登陆的时候会有不同的操作，两种客户都继承父类的login方法，但对于不同的对象，拥有不同的操作。

**继承的好处和坏处**

好处：

1. 子类能自动继承父类的接口
2. 创建子类对象时，无须创建父类对象

坏处：

1. 破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性
2. 支持扩展，但是往往以增加系统结构的复杂度为代价
3. 不支持动态继承，在运行时，子类无法选择不同的父类
4. 子类不能改变父类的接口



**Java中是否可以覆盖（Override）一个private或者是static的方法？**

Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不使用。

Java中不能覆盖priavte方法，因为private修饰的变量和方法只能在当前类中使用，如果其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

### 反射

每个类都有一个Class对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的.class文件，该文件内容保存着Class对象。

类加载相当于Class对象的加载，类在第一次使用时才动态加载到JVM中。也可以使用Class.forName("com.mysql.jdbc.Driver")这种方式来控制类的加载，该方法会返回一个Class对象。

反射可以提供运行时的类信息，并且这个类可以在运行时才能加载进来，甚至在编译时期该类的.class不存在也可以加载进来。

Class和java.lang.reflect一起对反射提供了支持，java.lang.reflect类库主要包含了以下三个类：

- Field：可以使用get()和set()方法读取和修改Field对象关联的字段；
- Method：可以使用invoke()方法调用与Method对象关联的方法；
- Constructor：可以用Constructor的newInstance()创建新的对象；

反射的优点：

- 可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用外部的用户自定义类。
- 类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员。可视化开发怀旧可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- 调试器和测试工作：调试期需要能够检查一个类里面的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的API定义，以确保一组测试中有较高的代码覆盖率。

反射的缺点：

尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。我们在使用反射技术时，下面几条内容应该牢记于心：

- 性能开销：反射涉及了动态类型的解析，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低的多。我们应该避免在经常被执行的代码或者对性能要求很高的程序中使用反射。
- 安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了
- 内部暴露：由于反射代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致医疗保险之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

### 泛型

```java
public class Box<T> {
    private T t;
    public void set(T t) {
        this.t = t;
    }
    public T get() {
        return t;
    }
}
```

### 注解

Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。

### 特性

#### Java各版本的新特性

##### New highlights in Java SE 8

1. Lambda Expression
2. Pipelines and Streams
3. Date and Time API
4. Default Methods
5. Type Annotations
6. Nashhorn JavaScript Engine
7. Concurrent Accumulators
8. Parallel operations
9. PermGen Error Removed

##### New highlights in Java SE 7

1. Strings in Switch Statement
2. Type Inference for Generic Instance Creation
3. Multiple Exception Handing
4. Support for Dynamic Languages
5. Try with Resources
6. Java nio Package
7. Binary Literals, Underscore in literals
8. Diamond Syntax

#### Java与C++区别

- Java是存粹的面向对象语言，所有对象都继承自java.lang.Object，C++为了兼容C既面向对象也支持面向过程；
- Java通过虚拟机从而实现跨平台特性，而C++依赖于特定的平台；
- Java没有指针，它的引用可以理解为安全指针，而C++具有和C一样的指针；
- Java支持自动垃圾回收，而C++需要手动回收；
- Java不支持多重继承，只能通过实现多个接口来达到相同目的，而C++支持多重继承；
- Java不支持操作符重载，虽然可以对两个String对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而C++可以；
- Java的goto是保留字，但是不可用，C++可用goto。

## Java容器

### 概览

容器主要包括Collection和Map两种，Colletion存储着对象的集合，而Map存储着键值对（两个对象）的映射表。

#### Collection

![image-20200227120334886](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200227120334886.png)

##### Set

- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如HashSet，HashSet的查找的时间复杂度位O(1)，TreeSet则为O(logN)。
- HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用Iterator遍历HashSet得到的结果是不确定的。
- LinkedHashSet：具有HashSet的查找效率，并且内部使用双向链表维护元素的插入顺序。

##### List

- ArrayList：基于动态数组实现，支持随机访问；
- Vector：和ArrayList类似，但它是线程安全的；
- LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中插入和删除元素。不仅如何，LinkedList还可以用作栈、队列和双向队列。

##### Queue

- LinkedList：可以用它来实现双向队列；
- PriorityQueue：基于堆结构实现，可以用它来实现优先队列。

#### Map

![image-20200227120743757](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200227120743757.png)

- TreeMap：基于红黑树实现，
- HashMap：基于哈希表实现
- HashTable：和HashMap类似，但它是线程安全的，这意味着同一时刻多个线程同时写入HashTable不会导致数据不一致。它是遗留类，不应该使用它，而是使用ConcurrentHashMap来支持线程安全，ConcurrentHashMap的效率会更高，因为ConcurrentHashMap引入了分段锁；
- LinkedHashMap：使用双向链表来维护元素的顺序。

### 容器中的设计模式

#### 迭代器模式

![image-20200227120941297](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200227120941297.png)

Colletion继承了Iterable接口，其中的iterator()方法能过产生一个Iterator对象，通过这个对象就可以迭代遍历Collection中的元素。

从JDK1.5之后可以使用foreach方法来遍历实现了Iterable接口的聚合对象。

```java
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
for (String item : list) {
    System.out.println(item);
}
```

#### 适配器模式

java.util.Arrays#asList()可以把数组转换为List类型。

```java
@SafeVarages
public static <T> List<T> asList(T... a)
```

应该注意的是asList()的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。

```java
Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
```

也可以使用以下方式调用asList()

```java
List list = Arrays.asList(1, 2, 3);
```

### 源码分析

基于JDK1.8分析。

在IDEA中double shift调出Search EveryWhere，查找源码文件，找到之后就可以阅读源码。

#### ArrayList

##### 概览

因为ArrayList是基于数组实现的，所以支持快速随机访问。RandomAccess接口标识着该类支持快速随机访问。

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

数组默认大小为10；

```java
private static final int DEFAULT_CAPACITY = 10;
```

![image-20200227131734684](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200227131734684.png)

##### 扩容

添加元素时使用ensureCapacityInternal()方法来保证容量足够，如果不够时，需要使用grow()方法进行扩容，新容量的大小为oldCapacity + (oldCapacity >> 1)，也就是旧容量的1.5倍。

扩容操作需要调用Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建ArrayList对象时就指定大概的容量大小，减少扩容操作的次数。

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!
	elementData[size++] = e;
    return true;
}
```





- 

## Java I/O

### 概览

Java的I/O分为：

- 磁盘操作：File
- 字节操作：InputStream和OutputStream
- 字符操作：Reader和Writer
- 对象操作：Serializable
- 网络操作：socket
- 新的输入/输出：NIO

### 磁盘操作

File类可以用于表示文件和目录的信息，但是它不表示文件的内容。

递归地列出一个目录下所有文件：

```java
public static void listAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }
    if(dir.isFile()) {
        System.out.println(dir.getName());
        return;
    }
    for(File file : dir.listFiles()) {
        listAllFiles(file);
    }
}
```

从Java7开始，可以使用Paths和Files代替File。

### 字节操作

#### 实现文件复制

```java
public static void copyFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutStream(dist);
    
    byte[] buffer = new byte[20 * 1024];
    int cnt;
    
    while((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.wirte(buffer, 0 ,cnt);
    }
    
    in.close();
    out.close();
}
```

#### 装饰者模式

Java I/O使用了装饰者模式来实现。以InputStream为例，

- InputStream是抽象组件；
- FileInputStream是InputStream的子类，属于具体组件，提供了字节流的输入操作；
- FilterInputStream属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能，例如BufferedInputStream为FileInputStream提供缓存功能。![image-20200228233926583](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200228233926583.png)

实例化一个具有缓存功能的字节流对象时，只需要在FileInputStream对象上再套一层BufferedInputStream对象即可。

```java
FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
```

DataInputStream装饰者提供了对更多数据类型进行输入的操作，比如int、double等基本类型。

### 字符操作

#### 编码与解码

编码就是把字符转换为字节，而解码是把字节重新组合成字符。

如果编码和解码过程使用不同的解码方式那么就出现了乱码。

- GBK编码中，中文字符占2个字节，英文字符占1个字节；
- UTF-8编码中，中文字符占3个字节，英文字符占1个字节；
- UTF-16be编码中，中文字符和英文字符都占2个字节。

UTF-16be中的be是指Big Edian，即大端。相应的由UTF-16le，Little Endian，即小端。

Java的内存编码使用双字节编码UTF-16be，这不是指Java只支持这一种编码方式，而是说char这种类型使用UTF-16be进行编码。char类型占16位，也就是两个字节，Java使用这种双字节编码是为了让一个中文或者一个英文都能使用一个char来存储。

#### String的编码方式

String可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为String。

```java
String str1 = "中文";
byte[] bytes = str1.getBytes("UTF-8");
String str2 = new String(bytes, "UTF-8");
System.out.println(str2);
```

在调用无参数getBytes()方法时，默认的编码方式不是UTF-16be。双字节编码的好处是可以使用一个char存储中文和英文，而将String转为bytes[]字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes()的默认编码方式与平台有关，一般为UTF-8。

#### Reader与Writer

不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中的操作通常是字符形式的数据，因此需要提供对字符进行操作的方法。

- InputStreamReader实现从字节流解码成字符流；
- OutputStreamWriter实现字符流编码成字节流。

#### 实现逐行输出文本文件的内容

```java
public static void readFileContent(String filePath) throws IOException {
    FileReader fileReader = new FileReader(filepath);
    BufferedReader bufferedReader = new BufferedReader(fileReader);
    
    String line;
    while((line = bufferedReader.readLine()) != null) {
        System.out.println(line);
    }
    
    // 装饰者模式使得BufferedReader组合了一个Reader对象
    // 在调用BufferedReader的close（）方法时会去调用Reader的close()方法
    // 因此只要一个close调用即可
    bufferedReader.close();
}
```

### 对象操作

#### 序列化

序列化就是将一个对象转换成字节序列，方便存储和传输。

- 序列化：ObjectOutputStream.writeObject()
- 反序列化：ObjectInputStream.readObject()

不会对静态变量进行序列化，因此序列化只是保存对象的状态，静态变量属于类的状态。

#### Serializable

序列化的类需要实现Serializable接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
    A a1 = new A(123, "abc");
    String objectFile = "file/a1";
    
    ObjectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));
    objectOutputStream.writeObject(a1);
    objectOutputStream.close();
    
    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStrea(objectFile));
    A a2 = (A)objectInputStream.readObject();
    objectInputStream.close();
    System.out.println(a2);
}

private static class A implements Serializable {
    private int x;
    private String y;
    
    A(int x, String y) {
        this.x = x;
        this.y = y;
    }
    
    @Override
    public String toString() {
        return "x = " + x + ", y = " + y;
    }
}
```

#### transient

transient关键字可以使一些属性不会被序列化。

ArrayList中存储数据的数组elementData是用transient修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，是的可以只序列化数组中有内容的那部分数据。

```java
private transient Object[] elementData;
```

### 网络操作

Java中的网络支持：

- InetAddress：用于表示网络上的硬件地址，即IP地址；
- URL：统一资源定位符；
- Sockets：使用TCP协议实现网络通信；
- Datagram：使用UDP协议实现网络通信。

#### InetAddress

没有公有的构造函数，只能通过静态方法来创建实例。

```java
InetAddress.getByName(String host);
InetAddress.getByAddress(byts[] address);
```

#### URL

可以直接从URL中读取字节流数据。

```java
public static void main(String[] args) throws IOException {
    URL url = new URL("http://www.baidu.com");
    
    // 字节流
    InputStream is = url.openStream();
    // 字符流
    InputStreamReader isr = new InputStreamReader(is, "UTF-8");
    
    // 提供缓存
    BufferedReader br = new BufferedReader(isr);
    
    String line;
    while((line = br.readLine()) != null) {
        System.out.println(line);
    }
    
    br.close();
    
}
```

#### Socket

- ServerSocket：服务端类
- Socket：客户端类
- 服务端和客户端通过InputStream和OutputStream进行输入输出。

![image-20200229002333804](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229002333804.png)

#### DataGram

- DatagramSocket：通信类
- DatagramPackte：数据包类

### NIO

新的输入输入（NIO）库是在JDK.14引入的，弥补了原来的I/O的不足，提供了高速的、面向块的I/O。

#### 流与块

I/O与NIO最重要的区别是数据打包和传输的方式，I/O以流的方式处理数据，而NIO以块的方式处理数据

面向流的I/O一次处理一个字节数据：一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式谁创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的I/O通常相当慢。

面向块的I/O一次处理一个数据块，按块处理数据比按流处理数据要快的多。但是面向块的I/O缺少一些面向流的I/O所具有的优雅性和简单性。

I/O包和NIO已经很好的集成了，java.io.*已经以NIO为基础重新实现了，所以现在它可以利用NIO的一些特性。例如，java.io.*包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会很快。

#### 通道与缓冲区

##### 通道

通道Channel是对原I/O包中的流的模拟，可以通过它读取和写入数据。

通道与流的不同之处在于，流只能在一个方向上移动（一个流必须是InputStream或者OutputStream的子类），而通道是双向的，可以用于读、写或者同时用于读写。

通道包括以下类型：

- FileChannel：从文件中读写数据；
- DatagramChannel：通过UDP读写网络中的数据；
- SocketChannel：通过TCP读写网络中的数据；
- ServerSocketChannel：可以坚听新进来的TCP链接，对每一个新进来的连接都会创建一个SocketChannel。

##### 缓冲区

发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。

缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

缓冲区包括以下类型：

- ByteBuffer
- CharBuffer
- ShortBufer
- IntBuffer
- LongBuffer
- FloatBuffer
- DoubleBuffer

#### 缓冲区状态变量

- capacity：最大容量；
- position：当前已经读写的字节数；
- limit：还可以读写的字节数。

状态变量的改变过程距离：

1. 新建一个大小为8个字节的缓冲区，此时position为0，而limit=capacity=8。capacity容量不会改变；![image-20200229003918508](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229003918508.png)
2. 从输入通道读取5个字节数据写入缓冲区中，此时position为5，limit保持不变。![image-20200229004000107](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229004000107.png)
3. 在将缓冲区的数据写到输出通道之前，需要先调用flip()方法（切换读写），这个方法将limit设置为当前position，并将position设置为0。![image-20200229004046743](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229004046743.png)
4. 从缓冲区取4个字节到输出缓冲中，此时postion为4。![image-20200229004127065](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229004127065.png)
5. 最后需要调用clear()方法来清空缓冲区，此时position和limit都被设置为最初位置。![image-20200229004226041](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229004226041.png)

#### 文件NIO实例

以下展示了使用NIO快速复制文件的实例：

```java
public static void fastCopy(String src, String dist) throws IOException {
    // 获得源文件的输入字节流
    FileInputStream fin = new FileInputStream(src);
    // 获取输入字节流的文件通道
    FileChannel fcin = fin.getChannel();
    // 获取目标文件的输出字节流
    FileOutputStream fout = new FileOutputStream(dist);
    // 获取输出字节流的文件通道
	FileChannel fcout = fout.getChannel();
    
    // 为缓冲区分配1024字节
    ByteBuffer buffer = ByteBufer.allocateDirect(1024);
    while(true) {
        // 从输入通道中读取谁到缓冲区中
        int r = fcin.read(buffer);
        
        if(r == -1) {
            break;
        }
        
        // 切换读写
        buffer.flip();
        // 把缓冲区的内容写入输出文件
        fcout.write(buffer);
        
        // 清空缓冲区
        buffer.clear();
    }
}
```

#### 选择器

NIO常常被叫做非阻塞IO，主要是因为NIO在网络通信中的非阻塞特性被广泛使用。

NIO实现了IO多路复用中的Reactor模型，一个线程Thread使用一个选择器Selector通过轮询的方式去监听多个通道Channel上的事件，从而让一个线程就可以处理多个事件。

通过配置监听的通道Channel为非阻塞，那么当Channel上的IO事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其他Channel，找到IO之间已经到达的CHannel执行。

因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于IO密集型的应用具有很好的性能。

注意，只有套接字Channel才能配置为非阻塞，而FileChannel不能，为FileChannel配置非阻塞也没有意义。

![image-20200229011553961](/Users/zhaojiangdong/Library/Application Support/typora-user-images/image-20200229011553961.png)

##### 创建选择器

```java
Selector selector = Selector.open();
```

##### 将通道注册到选择器上

```java
ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector, SelectionKey.OP_ACCEPT);
```

通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其他事件，必须等待这个水岸处理完毕才能去处理其他事件，显然这和选择器的作用背道而驰。

在将通道注册到选择器上时，还需要制定要注册的具体事件，主要有以下几类：

- SelectionKey.OP_CONNECT
- SelectionKey.OP_ACCEPT
- SelectionKey.OP_READ
- SelectionKey.OP_WRITE

它们在SelectionKey的定义如下：

```java
public static final int OP_READ = 1 << 0;
public static final int OP_WRITE = 1 << 2;
public static final int OP_CONNECT = 1 << 3;
public static final int OP_ACCEPT = 1 << 4;
```

可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如

```java
int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE
```

##### 监听事件

```java
int num = selector.select();
```

使用select()来监听到达的事件，它会一直阻塞到有至少一个事件到达。

##### 获取到达的事件

```java
Set<SelectionKey> keys = selector.selectorKeys();
Iterator<SelectionKey> keyIterator = keys.iterator();
while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if(key.isAcceptable()){
        //
    } else if (key.isReadable) {
        ///
    }
    keyIterator.remove();
}
```

##### 事件循环

因为一次select()调用不能处理完所有的事件，并且服务端可能需要一直监听事件，因此服务端处理事件的代码一般会放在一个死循环内。

```java
while(true) {
    int num = selector.select();
    Set<SelectionKey> keys = selector.selectedKeys();
    Iterator<SelectionKey> keyIterator = keys.iterator();
    while(keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if(key.isAcceptable()) {
            //
        } else i(key.isReadable()) {
            //
        }
        keyIterator.remove();
    }
}
```

#### 套接字NIO实例

```java
public class NIOServer {

    public static void main(String[] args) throws IOException {

        Selector selector = Selector.open();

        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        ssChannel.configureBlocking(false);
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);

        ServerSocket serverSocket = ssChannel.socket();
        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);
        serverSocket.bind(address);

        while (true) {

            selector.select();
            Set<SelectionKey> keys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = keys.iterator();

            while (keyIterator.hasNext()) {

                SelectionKey key = keyIterator.next();

                if (key.isAcceptable()) {

                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();

                    // 服务器会为每个新连接创建一个 SocketChannel
                    SocketChannel sChannel = ssChannel1.accept();
                    sChannel.configureBlocking(false);

                    // 这个新连接主要用于从客户端读取数据
                    sChannel.register(selector, SelectionKey.OP_READ);

                } else if (key.isReadable()) {

                    SocketChannel sChannel = (SocketChannel) key.channel();
                    System.out.println(readDataFromSocketChannel(sChannel));
                    sChannel.close();
                }

                keyIterator.remove();
            }
        }
    }

    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        StringBuilder data = new StringBuilder();

        while (true) {

            buffer.clear();
            int n = sChannel.read(buffer);
            if (n == -1) {
                break;
            }
            buffer.flip();
            int limit = buffer.limit();
            char[] dst = new char[limit];
            for (int i = 0; i < limit; i++) {
                dst[i] = (char) buffer.get(i);
            }
            data.append(dst);
            buffer.clear();
        }
        return data.toString();
    }
}

public class NIOClient {

    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("127.0.0.1", 8888);
        OutputStream out = socket.getOutputStream();
        String s = "hello world";
        out.write(s.getBytes());
        out.close();
    }
}



```

#### 内存映射文件

内存映射文件I/O是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快得多。

向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。

下面代码行将文件的前1024个字节映射到内存中，map()方法返回一个MappedByteBuffer，它是ByteBuffer的子类。因此，可以像使用其他任何ByteBuffer一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。

```java
MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);
```

#### 对比

NIO与普通I/O的区别：

- NIO是非阻塞的；
- NIO面向块，I/O面向流。

## 面向对象

## 数据结构与算法






## 设计模式

#### 前言

设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并不需要了解底层细节。

#### 创建型

##### 单例

##### 简单工厂

##### 工厂方法

##### 抽象工厂

##### 生成器

##### 原型模式

#### 行为型

##### 责任链

##### 命令

##### 解释器

##### 迭代器

##### 中介者

##### 备忘录

##### 观察者

##### 状态

##### 策略

##### 模版方法

##### 访问者

##### 空对象

#### 结构型

##### 适配器

##### 桥接

##### 组合

##### 装饰

##### 外观

##### 享元

##### 代理

### 面向对象思想

#### 三大特性

##### 封装

利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

优点：

- 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
- 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块
- 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
- 提高软件的可重用性
- 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的

##### 继承

继承实现了 **IS-A** 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。

继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 **向上转型** 。

##### 多态

多态分为编译时多态和运行时多态：

- 编译时多态主要指方法的重载
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

运行时多态有三个条件：

- 继承
- 覆盖（重写）
- 向上转型

下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。

```java
public class Instrument {

    public void play() {
        System.out.println("Instument is playing...");
    }
}Copy to clipboardErrorCopied
    
    
public class Wind extends Instrument {

    public void play() {
        System.out.println("Wind is playing...");
    }
}Copy to clipboardErrorCopied
    
    
public class Percussion extends Instrument {

    public void play() {
        System.out.println("Percussion is playing...");
    }
}Copy to clipboardErrorCopied
    
    
public class Music {

    public static void main(String[] args) {
        List<Instrument> instruments = new ArrayList<>();
        instruments.add(new Wind());
        instruments.add(new Percussion());
        for(Instrument instrument : instruments) {
            instrument.play();
        }
    }
}Copy to clipboardErrorCopied
    
    
    
    
Wind is playing...
Percussion is playing...
```

#### 类图

##### [泛化关系 (Generalization)](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=泛化关系-generalization)

用来描述继承关系，在 Java 中使用 extends 关键字。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg)



```text
@startuml

title Generalization

class Vihical
class Car
class Trunck

Vihical <|-- Car
Vihical <|-- Trunck

@endumlCopy to clipboardErrorCopied
```

##### [实现关系 (Realization)](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=实现关系-realization)

用来实现一个接口，在 Java 中使用 implements 关键字。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg)



```text
@startuml

title Realization

interface MoveBehavior
class Fly
class Run

MoveBehavior <|.. Fly
MoveBehavior <|.. Run

@endumlCopy to clipboardErrorCopied
```

##### [聚合关系 (Aggregation)](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=聚合关系-aggregation)

表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg)



```text
@startuml

title Aggregation

class Computer
class Keyboard
class Mouse
class Screen

Computer o-- Keyboard
Computer o-- Mouse
Computer o-- Screen

@endumlCopy to clipboardErrorCopied
```

##### [组合关系 (Composition)](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=组合关系-composition)

和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg)



```text
@startuml

title Composition

class Company
class DepartmentA
class DepartmentB

Company *-- DepartmentA
Company *-- DepartmentB

@endumlCopy to clipboardErrorCopied
```

##### [关联关系 (Association)](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=关联关系-association)

表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg)



```text
@startuml

title Association

class School
class Student

School "1" - "n" Student

@endumlCopy to clipboardErrorCopied
```

##### [依赖关系 (Dependency)](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=依赖关系-dependency)

和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：

- A 类是 B 类方法的局部变量；
- A 类是 B 类方法的参数；
- A 类向 B 类发送消息，从而影响 B 类发生变化。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg)



```text
@startuml

title Dependency

class Vihicle {
    move(MoveBehavior)
}

interface MoveBehavior {
    move()
}

note "MoveBehavior.move()" as N

Vihicle ..> MoveBehavior

Vihicle .. N

@endumlCopy to clipboardErrorCopied
```

#### 设计原则

##### [S.O.L.I.D](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=solid)

| 简写 | 全拼                                | 中文翻译     |
| ---- | ----------------------------------- | ------------ |
| SRP  | The Single Responsibility Principle | 单一责任原则 |
| OCP  | The Open Closed Principle           | 开放封闭原则 |
| LSP  | The Liskov Substitution Principle   | 里氏替换原则 |
| ISP  | The Interface Segregation Principle | 接口分离原则 |
| DIP  | The Dependency Inversion Principle  | 依赖倒置原则 |

##### [1. 单一责任原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_1-单一责任原则)

> 修改一个类的原因应该只有一个。

换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

##### [2. 开放封闭原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_2-开放封闭原则)

> 类应该对扩展开放，对修改关闭。

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。

##### [3. 里氏替换原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_3-里氏替换原则)

> 子类对象必须能够替换掉所有父类对象。

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

##### [4. 接口分离原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_4-接口分离原则)

> 不应该强迫客户依赖于它们不用的方法。

因此使用多个专门的接口比使用单一的总接口要好。

##### [5. 依赖倒置原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_5-依赖倒置原则)

> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
> 抽象不应该依赖于细节，细节应该依赖于抽象。

##### 高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

- 任何变量都不应该持有一个指向具体类的指针或者引用；
- 任何类都不应该从具体类派生；
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。

##### [其他常见原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=其他常见原则)

除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。

| 简写 | 全拼                              | 中文翻译     |
| ---- | --------------------------------- | ------------ |
| LOD  | The Law of Demeter                | 迪米特法则   |
| CRP  | The Composite Reuse Principle     | 合成复用原则 |
| CCP  | The Common Closure Principle      | 共同封闭原则 |
| SAP  | The Stable Abstractions Principle | 稳定抽象原则 |
| SDP  | The Stable Dependencies Principle | 稳定依赖原则 |

##### [1. 迪米特法则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_1-迪米特法则)

迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

##### [2. 合成复用原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_2-合成复用原则)

尽量使用对象组合，而不是通过继承来达到复用的目的。

##### [3. 共同封闭原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_3-共同封闭原则)

一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。

##### [4. 稳定抽象原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_4-稳定抽象原则)

最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。

##### [5. 稳定依赖原则](https://cyc2018.github.io/CS-Notes/#/notes/面向对象思想?id=_5-稳定依赖原则)

包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。

# 字节跳动面经

## 问题

1. **输入网站之后的整个流程**
2. **TCP/UDP区别，TCP为什么是面向连接的**
3. **用户态和内核态区别**
4. **B+Tree查找为什么是logn**
5. sql语言
6. int、Integer、final关键字
7. hashmap的 get、rehash
8. **jvm如何判断对象是否可被回收，哪些可以作为GC Roots？**
9. redis分布式锁
10. 其他变成语言的内存管理是如何实现的？
11. redis的网络模型，为什么不用线程池而用单线程
12. 操作系统的spinlock与java中的锁的区别
13. mysql的主从复制原理
14. redis的mget与pipeline的区别
15. **三次握手**
16. **握手时产生的序列号是干什么用的**
17. **讲一下接收窗口**
18. **TCP和UDP的本质区别**（本质？可靠与不可靠）
19. **什么时候选择TCP/UDP（应用场景？）**
20. **HTTPS的连接过程**
21. **路由器/交换机是哪一层**
22. **网络层用来干嘛？传输层用来干嘛？**
23. **HTTP可以使用UDP吗**
24. **HTTPS怎么确认收到的包就是服务器发来的**？身份认证
25. 确定发送窗口的大小，如何最大利用带宽，假设延迟100ms，发送端10Mbps，接收端100Mbps
26. **事务的四大特性**（数据库特性ACID）
27. 四种隔离级别
28. 什么是幻读
29. InnoDB（Mysql默认存储引擎）如何防止幻读？MVCC
30. 为什么要分用户态和内核态
31. TCP流量控制和拥塞控制
32. 64位
33. traceroute
34. 经过路由器，什么改变了
35. 程序这么得知中断
36. 寄存器：CPU中存储数据
37. Left join?
38. 分布式锁
39. 面向对象特性，多态这么实现的：多态的意思就是一种概念，多种表现形式，这个才是多态。
    java中体现多态的语法有：
    **同一类中的函数重载**，一个函数名，对应多种函数参数的调用
    **泛型**，一种算法或者一种数据结构，对应多种具体类型
    **接口**，一种接口，对应多个类实现
    **派生类中的函数重写**（很多培训机构将多态等同于派生类的重写，你看到的也不外乎这种谬论）
40. mysql有哪些锁，如何加锁
41. 单例模式实现
42. **get和post的区别**
43. **数据库的主键索引和普通索引那个快**
44. **索引越多越好吗，索引建多了有什么问题**
45. 聚集索引和非聚集索引的区别。看书
46. **innodb索引的数据结构？b+**
47. **b+树的优点**
48. **幻读的概念？幻读和不可重复读的区别**
49. **说一下mvcc的概念，实现的原理，解决的问题**
50. 写了一个sql，查询所有平均成绩大于60的同学：以下假设student是记录姓名和院系的
    sc是记录成绩的
    select a.姓名,a.院系 from student a join sc b on a.id=b.id group by a.姓名,a.院系 having avg(b.成绩)>60；having是对groupby的条件
51. **redis常用数据类型**及底层
52. **redis持久化方式及区别（aof和rdb）**
53. **tcp四次挥手，为什么等待2msl**
54. **https的加密过程，为什么传输时用非对称加密**
55. 说一下springcloud的注册中心
56. 负载均衡策略，ribbon用到的是哪种（轮询）
57. 服务熔断和服务降级
58. hashmap
59. 深拷贝和浅拷贝
60. 值传递和引用传递

    - 值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。复制钥匙

    - 引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。直接给钥匙
61. gc
62. 死锁
63. 线程之间的同步方式（pv？）
64. java的基本数据类型和他们占用的空间大小
65. 说一下二叉树 ，满二叉树，bst avl b+树 b树，红黑树的区别？？？？？？？
66. 说一下数组 链表 哈希表的使用场景，时间复杂度，优劣
67. 说一下操作系统用户态和内核态
68. 说一下操作系统虚拟内存
69. 说一下Linux fork()系统调用的过程，要求讲到内存过程
70. 说一下Linux 无名管道 命名管道的内存过程，底层原理
71. Java创建字符串的方式，比较性能优劣
72. 说一下JVM线程调度过程，什么情况会发生抢占
73. 说一下线程通过继承thread和实现runable接口实现的线程，底层有什么区别？
74. 说一下cookie和session的区别，场景的选择
75. cookie跨域（反向代理）
76. xss攻击
77. 说一下Java内存模型
78. Java内存模型交互操作
79. 如何保证数据一致性
80. volatile如何保证数据一致性
81. volatile的变量，两个线程一起操作会发生什么？（脏读？？？联系对象头？？？？）
82. Intel cpu的数据一致性协议是如何保证数据一致性的？
83. 为什么要有高速缓存，寄存器，内存？
84. 高速缓存的作用
85. 寄存器发生了什么
86. 操作系统的读者写着问题！！（读会发生什么，多个线程读怎么样，如果有线程要写，如何保证写线程不被饿死？
87. 地址空间分配的时机
88. 操作系统内存管理？
89. 什么时候进行地址空间分配
90. 函数调用局部变量？内存分配发生了什么
91. 如果向操作系统请求一个4g的连续空间，会分配吗？过程？
92. 数据库如何保证数据的一致性，如何解决
93. redis分布式锁
94. B树和B+树的区别
95. innodb索引原理
96. myisam的索引原理
97. myisam索引的组织方式
98. 稠密索引是个啥
99. 以下哪个能用索引，为什么
100. 说一下icmp用来干嘛
101. ping原理，ping一个地址，通了会怎么样，不通会怎么样（现象）
102. 虚函数与纯虚函数的区别
103. 继承解释一下
104. 如果输入www.baidu.com如果没有成功如何排查（输入一个url到页面显示其间过程是什么，有哪些技术点）
105. http和https的区别，ssl连接过程，对称加密与非对称加密
106. 如何判断客户端与服务器端是真实存在，而非黑客恶意所为
107. tcp与udp，以及应用场景
108. seesion和cookid的区别
109. 事务特性
110. 隔离级别，默认隔离级别
111. 长连接
112. 数据库索引结构
113. hashmap与hashset的实现原理，源码
114. mybatis与jpa的区别优缺点
115. 红黑树、AVL对比，引申B，B+
116. 网卡收到一条数据到进程处理数据，这之间经历了什么（中断的上半部、下半部，网络协议拆包？）
117. 大数据量（内存够用）下，快排与堆排序的对比（考察缓存命中率的对比）
118. 缓存相关，LRU算法思想，手撕LRU实现
119. 一致性hash
120. 缓存失效，替换原理
121. C++多态原理
122. 32位系统运行大于4G的程序，如何寻址（考察虚拟内存、虚拟地址空间）
123. 手撕完全二叉树寻找最后一行最后一个节点
124. 手撕层序遍历二叉树
125. 手撕二叉树先序、中序，求后序
126. 发展前景，城市

## 算法题

1. dp：硬币，给定一定种类的硬币，求能组成特定价值的最少枚数
2. 链表反转+链表加法
3. dp：股票最佳买卖时机
4. 两数相加（leetcode 2）
5. 数组中每个数右边第一个比它大的元素(LeetCode 1019)
6. 二叉树的最近公共祖先（LeetCode 236）
7. **求x的y次方，想出比直接for循环更好的方案**
8. 求绝对众数
9. 二叉树，输出所有和为n的路径（可以从中间结点到中间结点）
10. 链表对折
11. m*n的方格一端到另一端有多少种方法
12. 编程题：有1 2 5 10 块，n块有多少种拿法
13. 找出链表中第一个公共节点
14. 二叉树的公共祖先
    1. 不用递归怎么做
    2. 写出找出路径的算法
15. 最长不重复子序列长度
16. 将数组中所有的0放到数组末尾
17. 三十六进制加法，要求不能转化成十进制
18. 数组n长，每个元素取汁[1,n]，统计数组中不同元素出现的次数
19. 相交链表，多种解法如何优化
20. bst的第k个节点？中序遍历
21. 最长无重复子串？如何记忆优化，
22. 手写快排
23. 给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3。
24. 二叉树蛇形 遍历
25. 找出乱序数组中的第k大的数并输出---------答快排再找-----------能不能优化---------我不会
26. 打印二叉树中路径和为n的路径
27. 求一个数组第K大的数组
28. 求pow(x,y)

## 概率题？

## 设计题  

1. 一个数据库存了以下数据：用户id，登录时间，登出时间；如何找到一天当中的用户峰值（用一个hash map存所有秒数的在线人数）

# 工具

## Git

### 简介

- 版本控制
- 多人协作开发

### 命令

```shell
git init ## 初始化
git status ## 查看本地代码状态
git add . ## 添加修改代码到缓存
git commit -m "提交信息" ##提交
git push 仓库地址 分支# push上去
git branch ## 查看所有分支
git branch cName ## 创建分支cName
git checkout cName ## 切换分支
git checkout -b cName ## 创建并切换分支cName
git branch -a ## ???
git branch -d ## 删除分支

```

多人协作的工作模式：

1. 首先用git push origin branch-name推送自己的修改
2. 如果推送失败，则因为远程分支比本地更新，需要先用git pull视图合并；
3. 如果合并有冲突，则解决冲突，并在本地提交；
4. 没有冲突或者解决掉冲突后，再用git push origin branch-name推送；
5. 如果git pull提示no tracking information，则说明本地分支和远程分支未关联，使用git branch --set-upstream-to branch-name origin/branch-name;



https://www.jianshu.com/p/1a58c9b65fa9



# 其他

- 你有什么优势，和其他同学相比
- 你有哪些不足
- github和博客上分享过哪些东西
- 日后学习的打算
- 有什么要问的



# 补充知识点

## XSS攻击

### 简介

XSS跨站脚本攻击：黑客想尽一切方法将一段脚本内容放到目标网站的目标浏览器上解释执行。

- 攻击者：黑客

- 受害者：目标网站的目标用户的浏览器

- 攻击方法：脚本

### XSS类型

#### 反射型

发出请求时，XSS代码出现在URL中，作为输入提交到服务器，服务器解释后响应，在响应内容中出现这段XSS代码，最后由浏览器解释执行！

#### 存储型

存储型XSS和反射型XSS的区别：

提交的XSS代码会存储在服务器上，下次请求目标页面的时候不需要再次提交XSS代码。存储的位置可以是数据库、内存、文件系统等。

典型的例子就是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容就会从数据库查询出来并显示，在浏览器上与正常的HTML和JS解析执行，触发XSS攻击。

#### DOM型

DOM型XSS和存储型XSS、反射型XSS的区别：

DOM型XSS代码不需要服务器解析响应的直接参与，触发XSS只需要浏览器的DOM解析，完全是客户端的问题。



# 总结

## 计算机基础



1. 计算机网络

   1. 从输入 URL 到页面加载完成，中间发生了什么（基本必问的问题了，因为这个问题能考察对计算机网络整体的掌握程度，以及方便面试官扩展问题）；
   2. 多进程多线程浏览器（比如 Chrome），主控进程，插件进程，GPU进程，每个 tab 一个进程，tab 进程内有网络请求线程等；
   3. 协议栈各层各说一些协议（记一下常用的）；
   4. HTTP（基本描述，Method，协议版本及新版本特点，请求响应报文结构，常用请求头字段，常见响应状态码（每类记几个），RFC规范（知道这个词儿是啥就行了）等）；
   5. 单拎出来的缓存问题，结合状态码 304 可能问到，相关头字段，If-Modified-Since 和 Last-Modified，If-None-Match 和 ETag，它们的区别等；
   6. 单拎出来的 cookie 和 session 问题，搞清楚它们是干啥的，相关的头字段，其中 session 可能扩展到分布式上；
   7. 单拎出来的跨域问题，了解下浏览器同源（协议，域名，端口）政策，对后端的限制（AJAX等，前端问题暂不考虑），解决方法（JSONP，WebSocket，CORS），CORS（Cross-Origin Resource Sharing）相关内容，头字段 Origin，Access-Control-Allow-Origin 等；
   8. HTTPS（基本描述，主要作用，和 HTTP 的区别，SSL/TLS 握手过程，为什么过程要这样设计，对称/非对称加密，公私钥，证书，签名，CA，浏览器校验，加密算法（这个我并不懂）等）；
   9. DNS（基本概念，流程，缓存，hosts 文件，DNS服务器层级，迭代/递归查询等）；
   10. SOCKS（了解下这是干啥的，以及基本流程）；
   11. 传输层（端到端通信服务，多路分解与多路复用，端口号的作用，套接字）；
   12. TCP（必问，需要清晰掌握，简单列举一下）
       1. 基本特点，报文头大小与具体结构，序号/确认号作用，控制位及各自含义，可选头的时间戳（简单了解）；
       2. 面向连接，三握四挥（记清楚），握手的 SYN 洪泛攻击，挥手的 FIN-WAIT-2 以及 TIME-WAIT 状态，两次挥手后的 TCP 半开，四次挥手后的等待，MSL 时间，time-wait 的快速回收，fin-wait-2 的设定时间；
       3. TCP 连接能否感知对方是否在线（规范不能，实际可以），TCP 保活机制（SO_KEEPALIVE），保活参数（保活定时，失活前检查参数等），应用层面保活（心跳包，ping/pong 包等））；
       4. 可靠传输，结合序号/确认号说明，停止并等待 ARQ，结合流水线/滑动窗口的连续 ARQ，超时重传机制，RTT，RTO，差错恢复机制，GBN，SR，快速重传（冗余 ARK）等；
       5. 流量控制，目的（防止接收方缓存溢出导致分组丢失），基本原理，不足及改进（匹配相差一个 RTT，接单了解一下）；
       6. 拥塞控制，目的（避免网络拥塞），基本原理，慢启动，拥塞避免，快速回复，快速重传，AIMD（加法增大乘法减小），导致网络通讯波动（同时进入控制状态，时大时小），随机早期检测算法（了解一下）；
   13. UDP（可能作为对比来问，无连接，尽力而为，面向报文，无各种控制，一对一，一对多，多对多，首部大小及结构，校验和计算过程（求和，溢出回卷，反码，校验等），可能间插着问问正反补码）；
   14. TCP，UDP 伪首部，虚拟的数据结构，参与计算校验和，简单了解；
   15. 网络层（主机到主机间的逻辑通信）；
   16. IP （感觉其实传输层以下问的不多，能说出来就行了。v4/v6，点分十进制，各类地址空间，DNS，NAT，DHCP，路由寻址，EGP（BGP 看一下留个印象），IGP（RIP，OSPF 留个印象））；
   17. ICMP（知道类型 0 和类型 8 报文是啥（Echo 响应与请求），ping 的流程）；
   18. ARP（地址解析协议，了解一下流程什么的）；
   19. MAC（介质访问控制协议，简单了解一下）；

2. 关系数据库（实际上主要指 MySQL）

   1. 范式，背下来吧；
   2. 基本 sql 语法（这个我真记的不咋行，因为平时用也都是要查查的）；
   3. 数据结构（B 树，B+ 树，插入分裂，删除合并等，结合 MySQL InnoDB，结合聚簇索引，B+ 树的好处（B+ 树方便遍历，内容在叶子所以效率稳定，IO 吞吐更大开销低））；
   4. 索引
      1. 哈希索引（InnoDB 自适应）；
      2. 聚簇索引/非聚簇索引；
      3. 主键索引/唯一索引/二级索引；
      4. 单列索引/联合索引；
      5. 覆盖索引；
      6. 最左匹配，查询回表等；
      7. 索引优缺点（加快检索速度，加快多表连接，额外空间开销，维护索引的额外时间开销）；
      8. 适合不适合建立索引的字段等；
      9. 索引无法使用的情况（模糊匹配，OR 前后没有同时使用，联合索引的最左匹配等）；
   5. 事务（集中式）
      1. 事务的基本概念，事务的提交，回滚等；
      2. ACID特性；
      3. 事务的并发问题（第一二类丢失更新，脏读，不可重复读，幻读）；
      4. 隔离级别（读未提交，读已提交，可重复读，串行化）；
      5. 事务的支持，InnoDB；
   6. 数据库锁
      1. 锁的概念和大类别（悲观并发控制，乐观并发控制，MVCC 等）；
      2. 数据库锁的类别（主要是悲观锁，表锁/叶锁/行锁，意向锁，共享锁/排它锁，更新锁，记录锁/间隙锁/Next-Key锁等）；
      3. InnoDB，索引加锁，行锁的使用（比较执行代价），行锁死锁（所以行锁复杂），意向锁（解决行表锁冲突），行锁（记录/间隙/Next-Key），更新锁（避免先S后X的死锁）等；
      4. 锁时效性（临时锁，持续锁）；
      5. 加锁协议（一/二/三级加锁协议，二段锁协议（充分条件），一次封锁法等）；
      6. MVCC 的概念，时间戳版本号，快照版本与当前版本，适用场景等。

3. NOSQL（主要指 Redis，本人仅限于有限的使用和了解）

   1. 基本数据类型；
   2. 部分支持事务，单线程（串行，无锁）等；
   3. 淘汰策略（六种，可能挑出来 LRU 问）；
   4. 持久化问题（RDB 快照与 AOF 操作日志）；
   5. zset 的数据结构（跳表，了解一下）；
   6. 消息队列（不是 Redis 的设计目标）。

4. 基础数据结构

   1. 数组，链表，树，堆，队列，栈，图，都看一看概念，别到时候卡壳，结合语言；
   2. BST，AVL，红黑都了解一下。DFS，BFS 结合回溯法和分支法。图感觉我们搬砖的用的也不多，看看最短路径之类的；

5. 基础算法方面

   时间/空间复杂度的含义，基本二分，变种二分，基本排序以及它们的各种特点，六大基础算法类型等；

   小心动规。。。

6. 其他

   1. 进程与线程（可以结合语言说）；
   2. 死锁等；
   3. 分布式数据库事务，CAP，BASE，二次提交协议等；
   4. 正则表达式，简单了解一下；
   5. 设计模式，简单了解一下；
   6. 面向对象概念，特点，原则；
   7. 各种工具的使用，如 Git，Maven等；
   8. Linux 的基本使用；
   9. IO模型（同步/异步，阻塞/非阻塞），BIO，NIO，AIO，IO多路复用等；
   10. 反向***，负载均衡，微服务架构的注册和管理，多节点缓存，CDN 内容分发网络，DNS 轮询等，可能结合具体的工具说，如 Nginx，ZooKeeper 等；
   11. Twitter雪花算法了解一下；
   12. 海量请求问题，海量数据问题；

## Java 相关（非 Java 的同学简单参考下）

1. 有时间的把《Java 编程思想》，《Java 核心技术 卷 I》，《深入理解 Java 虚拟机》翻一下；
2. 基础知识，如重载重写，继承多态，关键字等，记清楚；
3. Java 数组，容器集合包/类，常用容器，以及相应静态工具包/类，HashMap 底层（红黑树警告），ConcurrentHashMap 原理等（1.8前后变化，分段锁变成 CAS 了）；
4. IO/NIO 包，主要结合 IO 模型说（实际上 IO 包已经用 NIO 包重新实现过了）；
5. 并发（包），Java 关键字，锁等
   1. Thread，Runnable，Callable，Future，ThreadLocal 等，会用，知道区别；
   2. 线程池体系，ExecutorService，ScheduledExecutorService 等接口，ThreadPoolExecutor，ForkJoinPool 等实现类，Executors 静态工厂类，线程池的核心参数，几种不同类型的工厂线程池等，会用，了解一下；
   3. 几种常用的阻塞队列，这里很大可能会让写个简单的阻塞队列（生产者消费者），参考下 ArrayBlockingQueue 里面的，用 ReentrantLock 和 Condition 简单写一下就好了；
   4. 几种并发构件，倒计时栅栏，循环栅栏这些，说实话我不常用，简单了解下吧；
   5. synchronized 关键字，首先知道它是干啥的，其次了解咋实现的，我认为至少要讲到 monitor 面试官才会满意，其间可能牵扯到堆中对象头结构（这里还可能牵扯到数组的 length 属性咋来的），还可能牵扯到锁优化（偏向锁，自旋锁，轻量级锁，锁粗化，锁消除（这里还可能牵扯到对象逃逸等），对象头的 Mark Word 复用等）；
   6. Lock，主要是 ReentrantLock，要了解 AQS 的基本工作原理，包括同步队列和 Condition 的等待队列等（和 monitor 的队列很像），了解它的 states 状态是用 CAS 算法更新的，了解公平/非公平，了解自旋/挂起；
   7. 了解 CAS 的基本原理，知道 Java 中的 Unsafe 类（知道用这个东西就行了，直接操作内存的，基本用不到）；
   8. 原子类，信号量，了解一下；
   9. 了解经典的进程线程模型（内核线程，轻量级线程，用户线程等），了解 Java 的线程调度策略（抢占式，系统决定），了解 Java 线程优先级（不一一对应，程序不应该依赖于优先级）；
   10. 了解 JMM，了解可见性问题（由此引出 volatile 关键字），知道 volatile 能解决可见性（区别于原子性）和重排序问题，由此引出有序性的先行发生原则（happens-before）。
6. JVM 运行时内存区域（虚拟机栈，本地方法栈，程序计数器，堆，方法区（1.8前后变化，永久代被元空间替代了）等，了解栈和堆的区别（小细节：非逃逸对象的栈上分配），了解线程私有区域和共享区域等（比如一个怪问题，布尔值所占的空间大小））；
7. 垃圾回收算法，引用计数法，可达性分析法（引出强软弱虚四种引用），两次标记（引出 finalize 方法），标记清除（碎片，CMS），标记复制（Eden，Survivor，分配担保，新生代），标记整理（老年代），分代，GC 停顿，Stop The World（砸瓦鲁多），安全点/区域等；
8. 垃圾回收器（七个，记一下特点）；
9. JVM 对象分配回收策略（Eden 优先，大对象直接进老年代，长期存活进老年代，动态年龄判定等）；
10. 类加载器（Bootstrap，Extension，Application 以及自定义的），双亲委派（能否破坏，loadClass 方法），加载流程（加载，验证，准备，解析，初始化），加载时候生成方法区对应的类的数据结构，以及生成对应的 class 对象（小细节问题：数组没有对应的类，怎么生成的），准备过程（分配类变量空间，赋值后延到初始化），初始化过程（结合 Java 新建对象各部分执行顺序分析）；
11. class 对象引出反射，引出***（Java ***和 CGLib，了解一下）；
12. 框架（主要指 Spring）了解一下，IOC 和 AOP 的概念与原理，感觉框架问的并不多（实际上 Java 问的就很少）。

## 总结

总的来说差不多就是这样，可能有遗漏。

说起来面试，其实也有一定的运气成分在。

本人没有什么面试经验，字节这次算是第一次正经面试（想想也是够野的），而且还在实习，复习时间少的可怜，感觉很多地方都答的一般。

本来我都没敢投（听说太菜会被记录），想先拿其他的试试，结果 OPPO 把我简历挂了，一气之下就投了，也是塞翁失马，焉知非福啊。

所以，人，一定要有梦想！

愿各位八月能斩获佳绩，与诸君共勉。